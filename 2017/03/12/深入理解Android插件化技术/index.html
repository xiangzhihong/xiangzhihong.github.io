<!DOCTYPE HTML>
<html>
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no">
    <link rel="dns-prefetch" href="//t11.baidu.com">
    <!--SEO-->



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>深入理解Android插件化技术 | 向志洪</title>


    <link rel="alternate" href="/atom.xml" title="向志洪" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css?rev=9.12.0">


<link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    <div class="hide">
    <script src="https://s4.cnzz.com/z_stat.php?id=1261768793&web_id=1262140174" language="JavaScript"></script>
    </div>
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?13764659765";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
	
	<script src="https://cdn1.lncld.net/static/js/av-min-1.2.1.js"></script>
    <script>AV.initialize("aj42pgqDHRSVhMknqDb3JMeg-gzGzoHsz", "qbRaoHOP9NMWPOow8PandkH3");</script>
</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header">
    <div class="main-header-box">
        <a class="branding" href="/" title="">
            <img src="/img/header_logo.png" alt="Snippet 博客主题">
        </a>
        <h2 class="text-hide">Snippet主题</h2>
        <img src="/img/header_logo.png" alt="Snippet 博客主题" class="hide">
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class=""><a href="/">首页</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/前端/">前端</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/后端/">后端</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/Java/">Java</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/Python/">Python</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/Android/">Android</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/iOS/">iOS</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/React Native/">React Native</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/小程序/">小程序</a></li>
                        
                            <li role="presentation" class=""><a href="/categories/杂谈/">杂谈</a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="深入理解Android插件化技术">
            
            深入理解Android插件化技术
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <span>Android</span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            Android
            
        </span>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2017/03/12</span>
    </span>
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>336</strong>天之前发表，文中内容可能已经过时。
            </p>
            
    </div>
    
    <div class="post-body">
        <p>插件化技术可以说是Android高级工程师所必须具备的技能之一，从2012年插件化概念的提出（Android版本），到2016年插件化的百花争艳，可以说，插件化技术引领着Android技术的进步。本篇文章转载自腾讯bugly，觉得写得不错，转载分享给大家。</p>
<h1 id="插件化提要"><a href="#插件化提要" class="headerlink" title="插件化提要"></a>插件化提要</h1><p><img src="http://img.blog.csdn.net/20180114185313720" alt="这里写图片描述"></p>
<p>可以说，插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制，相关原理请大家自行百度。</p>
<h2 id="插件化发展历史"><a href="#插件化发展历史" class="headerlink" title="插件化发展历史"></a>插件化发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p>
<ul>
<li>插件中代码的加载和与主工程的互相调用</li>
<li>插件中资源的加载和与主工程的互相访问</li>
<li>四大组件生命周期的管理</li>
</ul>
<p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。<br><img src="http://img.blog.csdn.net/20180114185632199" alt="这里写图片描述"></p>
<p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。<br><strong>第二代</strong>：为了同时达到插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。<br><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里今年开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p>
<h1 id="插件化原理"><a href="#插件化原理" class="headerlink" title="插件化原理"></a>插件化原理</h1><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>Android中常用的有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// DexClassLoaderpublic class DexClassLoader extends BaseDexClassLoader &#123;    public DexClassLoader(String dexPath, String optimizedDirectory,</div><div class="line">            String libraryPath, ClassLoader parent) &#123;        super(dexPath, new File(optimizedDirectory), libraryPath, parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// PathClassLoader</div><div class="line"></div><div class="line">public class PathClassLoader extends BaseDexClassLoader &#123;    public PathClassLoader(String dexPath, ClassLoader parent) &#123;     </div><div class="line">   super(dexPath, null, null, parent);</div><div class="line">    &#125; </div><div class="line">    </div><div class="line"> public PathClassLoader(String dexPath, String libraryPath,</div><div class="line">            ClassLoader parent) &#123;    </div><div class="line">    super(dexPath, null, libraryPath, parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。所以我们可以用DexClassLoader去加载外部的apk，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//第一个参数为apk的文件目录</div><div class="line">//第二个参数为内部存储目录</div><div class="line">//第三个为库文件的存储目录</div><div class="line">//第四个参数为父加载器</div><div class="line">new DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent)</div></pre></td></tr></table></figure>
<p>其实，关于类加载更详细的内容，笔者也深入剖析过，可以查看下面的链接：<a href="http://blog.csdn.net/xiangzhihong8/article/details/52880327" target="_blank" rel="external">类加载机制详解</a></p>
<h2 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h2><p>ClassLoader调用loadClass方法加载类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; </div><div class="line">       //首先从已经加载的类中查找</div><div class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);    </div><div class="line">    if (clazz == null) &#123;</div><div class="line">            ClassNotFoundException suppressed = null;     </div><div class="line">           try &#123;   </div><div class="line">                //如果没有加载过，先调用父加载器的loadClass</div><div class="line">                clazz = parent.loadClass(className, false);</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                suppressed = e;</div><div class="line">            &#125;      </div><div class="line">        if (clazz == null) &#123;        </div><div class="line">                try &#123;           </div><div class="line">       </div><div class="line">                  //父加载器都没有加载，则尝试加载</div><div class="line">                    clazz = findClass(className);</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                    e.addSuppressed(suppressed);       </div><div class="line">                     throw e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">            return clazz;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出ClassLoader加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时才会调用自身的findClass方法加载，该机制很大程度上避免了类的重复加载。</p>
<h3 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a>DexPathList</h3><p>这里要重点说一下DexClassLoader的DexPathList。DexClassLoader重载了findClass方法，在加载类时会调用其内部的DexPathList去加载。DexPathList是在构造DexClassLoader时生成的，其内部包含了DexFile。如下图所示：<br><img src="http://img.blog.csdn.net/20180114190418050" alt="这里写图片描述"></p>
<p>DexPathList的loadClass会去遍历DexFile直到找到需要加载的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; </div><div class="line">       //循环dexElements，调用DexFile.loadClassBinaryName加载class</div><div class="line">        for (Element element : dexElements) &#123;</div><div class="line">            DexFile dex = element.dexFile;    </div><div class="line">        if (dex != null) &#123;</div><div class="line">                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);   </div><div class="line">                     if (clazz != null) &#123;   </div><div class="line">                       return clazz;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">      if (dexElementsSuppressedExceptions != null) &#123;</div><div class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</div><div class="line">        &#125;     </div><div class="line">         return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>腾讯的qq空间热修复技术正是利用了DexClassLoader的加载机制，将需要替换的类添加到dexElements的前面，这样系统会使用先找到的修复过的类。</p>
<h3 id="单DexClassLoader与多DexClassLoader"><a href="#单DexClassLoader与多DexClassLoader" class="headerlink" title="单DexClassLoader与多DexClassLoader"></a>单DexClassLoader与多DexClassLoader</h3><p>通过给插件apk生成相应的DexClassLoader便可以访问其中的类，这边又有两种处理方式，有单DexClassLoader和多DexClassLoader两种结构。<br>对于多DexClassLoader结构来说，可以用下面的模型来标识。<br><img src="http://img.blog.csdn.net/20180114190739289" alt="这里写图片描述"><br>对于每个插件都会生成一个DexClassLoader，当加载该插件中的类时需要通过对应DexClassLoader加载。这样不同插件的类是隔离的，当不同插件引用了同一个类库的不同版本时，不会出问题，RePlugin采用的就是此方案。</p>
<p>对于单DexClassLoader来说，其模型如下：<br><img src="http://img.blog.csdn.net/20180114190907812" alt="这里写图片描述"><br>将插件的DexClassLoader中的pathList合并到主工程的DexClassLoader中。这样做的好处时，可以在不同的插件以及主工程间直接互相调用类和方法，并且可以将不同插件的公共模块抽出来放在一个common插件中直接供其他插件使用。Small采用的是这种方式。</p>
<p>插件和主工程的互相调用涉及到以下两个问题：<br><strong>插件调用主工程</strong><br>在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类。<br><strong>主工程调用插件</strong></p>
<ul>
<li>若使用多ClassLoader机制，主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定的限制。</li>
<li>若使用单ClassLoader机制，主工程则可以直接通过类名去访问插件中的类。该方式有个弊病，若两个不同的插件工程引用了一个库的不同版本，则程序可能会出错，所以要通过一些规范去避免该情况发生。</li>
</ul>
<p>关于双亲委托更详细的资料，大家也可以访问我博客之前的介绍：<a href="http://blog.csdn.net/xiangzhihong8/article/details/65446152" target="_blank" rel="external">classloader双亲委托模式</a></p>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>Android系统通过Resource对象加载资源，下面代码展示了该对象的生成过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//创建AssetManager对象 </div><div class="line">AssetManager assets = new AssetManager();</div><div class="line"> //将apk路径添加到AssetManager中</div><div class="line">  if (assets.addAssetPath(resDir) == 0)&#123;              </div><div class="line">    return null;  </div><div class="line">&#125;</div><div class="line"> //创建Resource对象</div><div class="line"></div><div class="line">r = new Resources(assets, metrics, getConfiguration(), compInfo);</div></pre></td></tr></table></figure>
<p>因此，只要将插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问。</p>
<p>具体实现时，由于AssetManager并不是一个public的类，需要通过反射去创建，并且部分Rom对创建的Resource类进行了修改，所以需要考虑不同Rom的兼容性。</p>
<h3 id="资源路径的处理"><a href="#资源路径的处理" class="headerlink" title="资源路径的处理"></a>资源路径的处理</h3><p>和代码加载相似，插件和主工程的资源关系也有两种处理方式：</p>
<ul>
<li>合并式：addAssetPath时加入所有插件和主工程的路径；</li>
<li>独立式：各个插件只添加自己apk路径</li>
</ul>
<p><img src="http://img.blog.csdn.net/20180114191404985" alt="这里写图片描述"></p>
<p>合并式由于AssetManager中加入了所有插件和主工程的路径，因此生成的Resource可以同时访问插件和主工程的资源。但是由于主工程和各个插件都是独立编译的，生成的资源id会存在相同的情况，在访问时会产生资源冲突。</p>
<p>独立式时，各个插件的资源是互相隔离的，不过如果想要实现资源的共享，必须拿到对应的Resource对象。</p>
<h3 id="Context的处理"><a href="#Context的处理" class="headerlink" title="Context的处理"></a>Context的处理</h3><p>通常我们通过Context对象访问资源，光创建出Resource对象还不够，因此还需要一些额外的工作。 对资源访问的不同实现方式也需要不同的额外工作。以VirtualAPK的处理方式为例。<br>第一步：创建Resource</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (Constants.COMBINE_RESOURCES) &#123;</div><div class="line">    //插件和主工程资源合并时需要hook住主工程的资源</div><div class="line">    Resources resources = ResourcesManager.createResources(context, apk.getAbsolutePath());</div><div class="line">    ResourcesManager.hookResources(context, resources);  </div><div class="line">      return resources;</div><div class="line">&#125; else &#123;  </div><div class="line">      //插件资源独立，该resource只能访问插件自己的资源</div><div class="line">    Resources hostResources = context.getResources();</div><div class="line">    AssetManager assetManager = createAssetManager(context, apk);  </div><div class="line">        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步：hook主工程的Resource<br>对于合并式的资源访问方式，需要替换主工程的Resource，下面是具体替换的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void hookResources(Context base, Resources resources) &#123; </div><div class="line">   try &#123;</div><div class="line">            ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, resources);</div><div class="line">            Object loadedApk = ReflectUtil.getPackageInfo(base);</div><div class="line">            ReflectUtil.setField(loadedApk.getClass(), loadedApk, &quot;mResources&quot;, resources);</div><div class="line"></div><div class="line">            Object activityThread = ReflectUtil.getActivityThread(base);</div><div class="line">            Object resManager = ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mResourcesManager&quot;);       </div><div class="line">     if (Build.VERSION.SDK_INT &lt; 24) &#123;</div><div class="line">                Map&lt;Object, WeakReference&lt;Resources&gt;&gt; map = (Map&lt;Object, WeakReference&lt;Resources&gt;&gt;) ReflectUtil.getField(resManager.getClass(), resManager, &quot;mActiveResources&quot;);</div><div class="line">                Object key = map.keySet().iterator().next();</div><div class="line">                map.put(key, new WeakReference&lt;&gt;(resources));</div><div class="line">            &#125; else &#123;                // still hook Android N Resources, even though it&apos;s unnecessary, then nobody will be strange.</div><div class="line">                Map map = (Map) ReflectUtil.getFieldNoException(resManager.getClass(), resManager, &quot;mResourceImpls&quot;);</div><div class="line">                Object key = map.keySet().iterator().next();</div><div class="line">                Object resourcesImpl = ReflectUtil.getFieldNoException(Resources.class, resources, &quot;mResourcesImpl&quot;);</div><div class="line">                map.put(key, new WeakReference&lt;&gt;(resourcesImpl));</div><div class="line">            &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div></pre></td></tr></table></figure>
<p>注意下上述代码hook了几个地方，包括以下几个hook点：<br>替换了主工程context中LoadedApk的mResource对象。<br>将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理。<br>第三步：关联resource和Activity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</div><div class="line">activity.setIntent(intent);</div><div class="line">//设置Activity的mResources属性，Activity中访问资源时都通过mResources</div><div class="line"></div><div class="line">ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources());</div></pre></td></tr></table></figure>
<p>上述代码是在Activity创建时被调用的（后面会介绍如何hook Activity的创建过程），在activity被构造出来后，需要替换其中的mResources为插件的Resource。由于独立式时主工程的Resource不能访问插件的资源，所以如果不做替换，会产生资源访问错误。</p>
<p>做完以上工作后，则可以在插件的Activity中放心的使用setContentView，inflater等方法加载布局了。</p>
<h3 id="解决资源冲突"><a href="#解决资源冲突" class="headerlink" title="解决资源冲突"></a>解决资源冲突</h3><p>合并式的资源处理方式，会引入资源冲突，原因在于不同插件中的资源id可能相同，所以解决方法就是使得不同的插件资源拥有不同的资源id。</p>
<p>资源id是由8位16进制数表示，表示为0xPPTTNNNN。PP段用来区分包空间，默认只区分了应用资源和系统资源，TT段为资源类型，NNNN段在同一个APK中从0000递增。如下表所示：<br><img src="http://img.blog.csdn.net/20180114191720075" alt="这里写图片描述"></p>
<p>所以思路是修改资源ID的PP段，对于不同的插件使用不同的PP段，从而区分不同插件的资源。具体实现方式有两种：</p>
<ul>
<li>修改aapt源码，编译期修改PP段。</li>
<li>修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。</li>
</ul>
<h1 id="四大组件支持"><a href="#四大组件支持" class="headerlink" title="四大组件支持"></a>四大组件支持</h1><p>Android开发中有一些特殊的类，是由系统创建的，并且由系统管理生命周期。如常用的四大组件，Activity，Service，BroadcastReceiver和ContentProvider。 仅仅构造出这些类的实例是没用的，还需要管理组件的生命周期。其中以Activity最为复杂，不同框架采用的方法也不尽相同。下面以Activity为例详细介绍插件化如何支持组件生命周期的管理。 大致分为两种方式：</p>
<ul>
<li>ProxyActivity代理</li>
<li>预埋StubActivity，hook系统启动Activity的过程</li>
</ul>
<h2 id="ProxyActivity代理"><a href="#ProxyActivity代理" class="headerlink" title="ProxyActivity代理"></a>ProxyActivity代理</h2><p>ProxyActivity代理的方式最早是由dynamic-load-apk提出的，其思想很简单，在主工程中放一个ProxyActivy，启动插件中的Activity时会先启动ProxyActivity，在ProxyActivity中创建插件Activity，并同步生命周期。下图展示了启动插件Activity的过程。<br><img src="http://img.blog.csdn.net/20180114191928737" alt="这里写图片描述"><br>具体的过程如下：</p>
<ol>
<li>首先需要通过统一的入口（如图中的PluginManager）启动插件Activity，其内部会将启动的插件Activity信息保存下来，并将intent替换为启动ProxyActivity的intent。</li>
<li>ProxyActivity根据插件的信息拿到该插件的ClassLoader和Resource，通过反射创建PluginActivity并调用其onCreate方法。</li>
<li>PluginActivty调用的setContentView被重写了，会去调用ProxyActivty的setContentView。由于ProxyActivity重写了getResource返回的是插件的Resource，所以setContentView能够访问到插件中的资源。同样findViewById也是调用ProxyActivity的。</li>
<li>ProxyActivity中的其他生命周期回调函数中调用相应PluginActivity的生命周期。</li>
</ol>
<p><strong>理解ProxyActivity代理方式主要注意两点：</strong></p>
<ul>
<li>ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数，如onResume，onStop，onBackPressedon，KeyUponWindow，FocusChanged等需要转发给插件。</li>
<li>PluginActivity中所有调用context的相关的方法，如setContentView，getLayoutInflater，getSystemService等都需要调用ProxyActivity的相应方法。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>插件中的Activity必须继承PluginActivity，开发侵入性强。</li>
<li>如果想支持Activity的singleTask，singleInstance等launchMode时，需要自己管理Activity栈，实现起来很繁琐。</li>
<li>插件中需要小心处理Context，容易出错。</li>
<li>如果想把之前的模块改造成插件需要很多额外的工作。</li>
</ul>
<p>该方式虽然能够很好的实现启动插件Activity的目的，但是由于开发式侵入性很强，dynamic-load-apk之后的插件化方案很少继续使用该方式，而是通过hook系统启动Activity的过程，让启动插件中的Activity像启动主工程的Activity一样简单。</p>
<h2 id="hook方式"><a href="#hook方式" class="headerlink" title="hook方式"></a>hook方式</h2><p>在介绍hook方式之前，先用一张图简要的介绍下系统是如何启动一个Activity的。<br><img src="http://img.blog.csdn.net/20180114192244626" alt="这里写图片描述"></p>
<p>上图列出的是启动一个Activity的主要过程，具体步骤如下：</p>
<ol>
<li>Activity1调用startActivity，实际会调用Instrumentation类的execStartActivity方法，Instrumentation是系统用来监控Activity运行的一个类，Activity的整个生命周期都有它的影子。</li>
<li>通过跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈。之后又通过跨进程调用进入到Activity2所在的进程中。</li>
<li>ApplicationThread是一个binder对象，其运行在binder线程池中，内部包含一个H类，该类继承于类Handler。ApplicationThread将启动Activity2的信息通过H对象发送给主线程。</li>
<li>主线程拿到Activity2的信息后，调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2实例。</li>
</ol>
<p>下面介绍如何通过hook的方式启动插件中的Activity，需要解决以下两个问题：</p>
<ul>
<li>插件中的Activity没有在AndroidManifest中注册，如何绕过检测。</li>
<li>如何构造Activity实例，同步生命周期</li>
</ul>
<p>解决方法有很多种，以VirtualAPK为例，核心思路如下：</p>
<ol>
<li>先在Manifest中预埋StubActivity，启动时hook上图第1步，将Intent替换成StubActivity。</li>
<li>hook第10步，通过插件的ClassLoader反射创建插件Activity</li>
<li>之后Activity的所有生命周期回调都会通知给插件Activity</li>
</ol>
<h3 id="替换系统Instrumentation"><a href="#替换系统Instrumentation" class="headerlink" title="替换系统Instrumentation"></a>替换系统Instrumentation</h3><p>VirtualAPK在初始化时会调用hookInstrumentationAndHandler，该方法hook了系统的Instrumentaiton类，由上文可知该类和Activity的启动息息相关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void hookInstrumentationAndHandler() &#123; </div><div class="line">   try &#123;  </div><div class="line">         //获取Instrumentation对象</div><div class="line">        Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(this.mContext);   </div><div class="line">              //构造自定义的VAInstrumentation</div><div class="line">        final VAInstrumentation instrumentation = new VAInstrumentation(this, baseInstrumentation); </div><div class="line">                     //设置ActivityThread的mInstrumentation和mCallBack</div><div class="line">        Object activityThread = ReflectUtil.getActivityThread(this.mContext);</div><div class="line">        ReflectUtil.setInstrumentation(activityThread, instrumentation);</div><div class="line">        ReflectUtil.setHandlerCallback(this.mContext, instrumentation); </div><div class="line">         this.mInstrumentation = instrumentation;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>该段代码将主线程中的Instrumentation对象替换成了自定义的VAInstrumentation类。在启动和创建插件activity时，该类都会偷偷做一些手脚。</p>
<h3 id="hook-activity启动过程"><a href="#hook-activity启动过程" class="headerlink" title="hook activity启动过程"></a>hook activity启动过程</h3><p>VAInstrumentation类重写了execStartActivity方法，相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public ActivityResult execStartActivity(</div><div class="line">    //省略了无关参数</div><div class="line">    Intent intent) &#123;</div><div class="line">//转换隐式intent</div><div class="line">    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent); </div><div class="line">   if (intent.getComponent() != null) &#123;  </div><div class="line">      //替换intent中启动Activity为StubActivity</div><div class="line">        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    //调用父类启动Activity的方法&#125;</div><div class="line">public void markIntentIfNeeded(Intent intent) &#123; </div><div class="line">   if (intent.getComponent() == null) &#123;  </div><div class="line">         return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String targetPackageName = intent.getComponent().getPackageName();</div><div class="line">    String targetClassName = intent.getComponent().getClassName();    // search map and return specific launchmode stub activity</div><div class="line">    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123;</div><div class="line">        intent.putExtra(Constants.KEY_IS_PLUGIN, true);</div><div class="line">        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);</div><div class="line">        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);</div><div class="line">        dispatchStubActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>execStartActivity中会先去处理隐式intent，如果该隐式intent匹配到了插件中的Activity，将其转换成显式。之后通过markIntentIfNeeded将待启动的的插件Activity替换成了预先在AndroidManifest中占坑的StubActivity，并将插件Activity的信息保存到该intent中。其中有个dispatchStubActivity函数，会根据Activity的launchMode选择具体启动哪个StubActivity。VirtualAPK为了支持Activity的launchMode在主工程的AndroidManifest中对于每种启动模式的Activity都预埋了多个坑位。</p>
<h3 id="hook-Activity的创建过程"><a href="#hook-Activity的创建过程" class="headerlink" title="hook Activity的创建过程"></a>hook Activity的创建过程</h3><p>上一步欺骗了系统，让系统以为自己启动的是一个正常的Activity。当来到图 3.2的第10步时，再将插件的Activity换回来。此时调用的是VAInstrumentation类的newActivity方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Activity newActivity(ClassLoader cl, String className, Intent intent)&#123;</div><div class="line">    try &#123;</div><div class="line">        cl.loadClass(className);</div><div class="line">    &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">        //通过LoadedPlugin可以获取插件的ClassLoader和Resource</div><div class="line">        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);</div><div class="line">                //获取插件的主Activity</div><div class="line">        String targetClassName = PluginUtil.getTargetActivity(intent);</div><div class="line">                if (targetClassName != null) &#123; </div><div class="line">                   //传入插件的ClassLoader构造插件Activity</div><div class="line">            Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</div><div class="line">            activity.setIntent(intent);</div><div class="line">                    //设置插件的Resource，从而可以支持插件中资源的访问</div><div class="line">            try &#123;</div><div class="line">                ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources());</div><div class="line">            &#125; catch (Exception ignored) &#123; </div><div class="line">                                   // ignored.</div><div class="line">            &#125;  </div><div class="line">          return activity;</div><div class="line">        &#125;</div><div class="line">    &#125;    return mBase.newActivity(cl, className, intent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于AndroidManifest中预埋的StubActivity并没有具体的实现类，所以此时会发生ClassNotFoundException。之后在处理异常时取出插件Activity的信息，通过插件的ClassLoader反射构造插件的Activity。</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>插件Activity构造出来后，为了能够保证其正常运行还要做些额外的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; </div><div class="line">   final Intent intent = activity.getIntent();</div><div class="line">       if (PluginUtil.isIntentFromPlugin(intent)) &#123;</div><div class="line">        Context base = activity.getBaseContext();</div><div class="line">               try &#123;</div><div class="line">            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);</div><div class="line">            ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, plugin.getResources());</div><div class="line">            ReflectUtil.setField(ContextWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());</div><div class="line">            ReflectUtil.setField(Activity.class, activity, &quot;mApplication&quot;, plugin.getApplication());</div><div class="line">            ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());</div><div class="line">               // set screenOrientation</div><div class="line">            ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent)); </div><div class="line">              if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;</div><div class="line">                activity.setRequestedOrientation(activityInfo.screenOrientation);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mBase.callActivityOnCreate(activity, icicle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码主要是将Activity中的Resource，Context等对象替换成了插件的相应对象，保证插件Activity在调用涉及到Context的方法时能够正确运行。</p>
<p>经过上述步骤后，便实现了插件Activity的启动，并且该插件Activity中并不需要什么额外的处理，和常规的Activity一样。那问题来了，之后的onResume，onStop等生命周期怎么办呢？答案是所有和Activity相关的生命周期函数，系统都会调用插件中的Activity。原因在于AMS在处理Activity时，通过一个token表示具体Activity对象，而这个token正是和启动Activity时创建的对象对应的，而这个Activity被我们替换成了插件中的Activity，所以之后AMS的所有调用都会传给插件中的Activity。</p>
<h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><p>四大组件中Activity的支持是最复杂的，其他组件的实现原理要简单很多，简要概括如下：</p>
<ul>
<li><strong>Service</strong>：Service和Activity的差别在于，Activity的生命周期是由用户交互决定的，而Service的生命周期是我们通过代码主动调用的，且Service实例和manifest中注册的是一一对应的。实现Service插件化的思路是通过在manifest中预埋StubService，hook系统startService等调用替换启动的Service，之后在StubService中创建插件Service，并手动管理其生命周期。</li>
<li><strong>BroadCastReceiver</strong>：解析插件的manifest，将静态注册的广播转为动态注册。</li>
<li><strong>ContentProvider</strong>：类似于Service的方式，对插件ContentProvider的所有调用都会通过一个在manifest中占坑的ContentProvider分发。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>VirtualAPK通过替换了系统的Instrumentation，hook了Activity的启动和创建，省去了手动管理插件Activity生命周期的繁琐，让插件Activity像正常的Activity一样被系统管理，并且插件Activity在开发时和常规一样，即能独立运行又能作为插件被主工程调用。</p>
<p>其他插件框架在处理Activity时思想大都差不多，无非是这两种方式之一或者两者的结合。在hook时，不同的框架可能会选择不同的hook点。如360的RePlugin框架选择hook了系统的ClassLoader，即图3.2中构造Activity2的ClassLoader，在判断出待启动的Activity是插件中的时，会调用插件的ClassLoader构造相应对象。另外RePlugin为了系统稳定性，选择了尽量少的hook，因此它并没有选择hook系统的startActivity方法来替换intent，而是通过重写Activity的startActivity，因此其插件Activity是需要继承一个类似PluginActivity的基类的。不过RePlugin提供了一个Gradle插件将插件中的Activity的基类换成了PluginActivity，用户在开发插件Activity时也是没有感知的。</p>
    </div>

    <div class="post-footer">   
        <div>
            
                转载声明: 商业转载请联系作者获得授权,非商业转载请注明出处 © Snippet
            
        </div>
        <div>
            
                版权声明: <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">
知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议（CC BY-NC-ND 3.0）
</a>
            
        </div>  
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2017/03/13/抓包神器Charles使用/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
    
    
        <a href="/2017/03/09/Kotlin之基本语法/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
    
</div>


    <div id="comments">
        <div id="uyan_frame"></div>
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2120654"></script>
    </div>
                </main>
                <aside class="col-md-4 sidebar">
        
        <div class="widget notification">
        <h3 class="title">网站公告</h3>
        <div>
            <p>主题Snippet v1.1.0版本即将上线，敬请期待~ <br>
主题下载：<a href="https://github.com/shenliyang/hexo-theme-snippet" title="fork me" target="_blank">Snippet主题</a> <br>
<hr>前端工程师一枚，专注于前端Node、React和移动端Android和Ios开发，欢迎骚扰。
<br>联系方式：qq群:278792776（移动群）、515980159（React群）、188716429（猎头hr群）
</p>
        </div>
    </div>
        
        <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/"><i class="fa" aria-hidden="true">Android</i></a><span class="category-list-count">41</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/系统/"><i class="fa" aria-hidden="true">系统</i></a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/"><i class="fa" aria-hidden="true">Google</i></a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Google/VR/"><i class="fa" aria-hidden="true">VR</i></a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/"><i class="fa" aria-hidden="true">Java</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/"><i class="fa" aria-hidden="true">Kotlin</i></a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWA/"><i class="fa" aria-hidden="true">PWA</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/"><i class="fa" aria-hidden="true">Python</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/"><i class="fa" aria-hidden="true">React Native</i></a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/"><i class="fa" aria-hidden="true">Spring</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/"><i class="fa" aria-hidden="true">android</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/"><i class="fa" aria-hidden="true">iOS</i></a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/"><i class="fa" aria-hidden="true">ios</i></a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/"><i class="fa" aria-hidden="true">python</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/"><i class="fa" aria-hidden="true">人工智能</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/"><i class="fa" aria-hidden="true">区块链</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/"><i class="fa" aria-hidden="true">小程序</i></a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术人生/"><i class="fa" aria-hidden="true">技术人生</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/"><i class="fa" aria-hidden="true">机器学习</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/"><i class="fa" aria-hidden="true">编程语言</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/"><i class="fa" aria-hidden="true">设计模式</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资料库/"><i class="fa" aria-hidden="true">资料库</i></a><span class="category-list-count">1</span></li></ul>
    </div>
        
        <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/"><i class="fa" aria-hidden="true">二月 2018</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/"><i class="fa" aria-hidden="true">一月 2018</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/"><i class="fa" aria-hidden="true">十二月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/"><i class="fa" aria-hidden="true">十一月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/"><i class="fa" aria-hidden="true">十月 2017</i></a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/"><i class="fa" aria-hidden="true">九月 2017</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/"><i class="fa" aria-hidden="true">八月 2017</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/"><i class="fa" aria-hidden="true">七月 2017</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/"><i class="fa" aria-hidden="true">六月 2017</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/"><i class="fa" aria-hidden="true">五月 2017</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/"><i class="fa" aria-hidden="true">四月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/"><i class="fa" aria-hidden="true">三月 2017</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/"><i class="fa" aria-hidden="true">二月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/"><i class="fa" aria-hidden="true">一月 2017</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/"><i class="fa" aria-hidden="true">十二月 2016</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/"><i class="fa" aria-hidden="true">十一月 2016</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/"><i class="fa" aria-hidden="true">十月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/"><i class="fa" aria-hidden="true">九月 2016</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/"><i class="fa" aria-hidden="true">八月 2016</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/"><i class="fa" aria-hidden="true">七月 2016</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/"><i class="fa" aria-hidden="true">六月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/"><i class="fa" aria-hidden="true">五月 2016</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/"><i class="fa" aria-hidden="true">四月 2016</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/"><i class="fa" aria-hidden="true">三月 2016</i></a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/"><i class="fa" aria-hidden="true">二月 2016</i></a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/"><i class="fa" aria-hidden="true">一月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/"><i class="fa" aria-hidden="true">九月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/"><i class="fa" aria-hidden="true">六月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/"><i class="fa" aria-hidden="true">五月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/"><i class="fa" aria-hidden="true">四月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/"><i class="fa" aria-hidden="true">三月 2015</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/"><i class="fa" aria-hidden="true">一月 2015</i></a><span class="archive-list-count">1</span></li></ul>
    </div>
        
        <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
      
        <a href="/tags/Spring/" style="font-size: 1em">Spring</a> <a href="/tags/Python/" style="font-size: 1em">Python</a> <a href="/tags/Android/" style="font-size: 1em">Android</a> <a href="/tags/新特性/" style="font-size: 1em">新特性</a> <a href="/tags/深入系统/" style="font-size: 1em">深入系统</a> <a href="/tags/系统服务/" style="font-size: 1em">系统服务</a> <a href="/tags/android/" style="font-size: 1em">android</a> <a href="/tags/混淆打包/" style="font-size: 1em">混淆打包</a> <a href="/tags/硬件/" style="font-size: 1em">硬件</a> <a href="/tags/Angular2/" style="font-size: 1em">Angular2</a> <a href="/tags/前端开发/" style="font-size: 1em">前端开发</a> <a href="/tags/iOS/" style="font-size: 1em">iOS</a> <a href="/tags/React-Native/" style="font-size: 1em">React Native</a> <a href="/tags/FlexBox布局/" style="font-size: 1em">FlexBox布局</a> <a href="/tags/Google/" style="font-size: 1em">Google</a> <a href="/tags/VR/" style="font-size: 1em">VR</a> <a href="/tags/小程序/" style="font-size: 1em">小程序</a> <a href="/tags/Java/" style="font-size: 1em">Java</a> <a href="/tags/后端/" style="font-size: 1em">后端</a> <a href="/tags/垃圾回收/" style="font-size: 1em">垃圾回收</a> <a href="/tags/Kotlin/" style="font-size: 1em">Kotlin</a> <a href="/tags/编程语言/" style="font-size: 1em">编程语言</a> <a href="/tags/OpenGL/" style="font-size: 1em">OpenGL</a> <a href="/tags/Node/" style="font-size: 1em">Node</a> <a href="/tags/Promise/" style="font-size: 1em">Promise</a> <a href="/tags/调试/" style="font-size: 1em">调试</a> <a href="/tags/eact-Native/" style="font-size: 1em">eact Native</a> <a href="/tags/打包/" style="font-size: 1em">打包</a> <a href="/tags/原生/" style="font-size: 1em">原生</a> <a href="/tags/前端/" style="font-size: 1em">前端</a> <a href="/tags/入门/" style="font-size: 1em">入门</a> <a href="/tags/ios/" style="font-size: 1em">ios</a> <a href="/tags/swift/" style="font-size: 1em">swift</a> <a href="/tags/AR/" style="font-size: 1em">AR</a> <a href="/tags/Xcode/" style="font-size: 1em">Xcode</a> <a href="/tags/知识库/" style="font-size: 1em">知识库</a> <a href="/tags/webpack/" style="font-size: 1em">webpack</a> <a href="/tags/gulp/" style="font-size: 1em">gulp</a> <a href="/tags/https/" style="font-size: 1em">https</a> <a href="/tags/Swift/" style="font-size: 1em">Swift</a> <a href="/tags/gif/" style="font-size: 1em">gif</a> <a href="/tags/mac/" style="font-size: 1em">mac</a> <a href="/tags/环境/" style="font-size: 1em">环境</a> <a href="/tags/原理/" style="font-size: 1em">原理</a> <a href="/tags/杂谈/" style="font-size: 1em">杂谈</a> <a href="/tags/react/" style="font-size: 1em">react</a> <a href="/tags/个人博客/" style="font-size: 1em">个人博客</a> <a href="/tags/流量/" style="font-size: 1em">流量</a> <a href="/tags/区块链/" style="font-size: 1em">区块链</a> <a href="/tags/微信/" style="font-size: 1em">微信</a> <a href="/tags/全栈/" style="font-size: 1em">全栈</a> <a href="/tags/搭建网站/" style="font-size: 1em">搭建网站</a> <a href="/tags/机器学习/" style="font-size: 1em">机器学习</a> <a href="/tags/算法/" style="font-size: 1em">算法</a> <a href="/tags/深入理解/" style="font-size: 1em">深入理解</a> <a href="/tags/内存分配/" style="font-size: 1em">内存分配</a> <a href="/tags/PWA/" style="font-size: 1em">PWA</a> <a href="/tags/人工智能/" style="font-size: 1em">人工智能</a> <a href="/tags/设计模式/" style="font-size: 1em">设计模式</a>
    </div>
  </div>
        
        <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="http://blog.csdn.net/xiangzhihong8/" class="fa" target="_blank">作者博客</a>
        
            <a href="https://yq.aliyun.com/u/xiangzhihong" class="fa" target="_blank">阿里云博客</a>
        
        </div>
    </div>
        
    </aside>
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<!--page counter part-->
<script>
function addCount (Counter) {
        url=$('.article-date').attr('href').trim();
        title = $('.article-title').text().trim();
        var query=new AV.Query(Counter);
        //use url as unique idnetfication
        query.equalTo("url",url);
        query.find({
            success: function(results){
                if(results.length>0)
                {
                    var counter=results[0];
                    counter.fetchWhenSave(true); //get recent result
                    counter.increment("time");
                    counter.save();
                }
                else
                {
                    var newcounter=new Counter();
                    newcounter.set("title",title);
                    newcounter.set("url",url);
                    newcounter.set("time",1);
                    newcounter.save(null,{
                        success: function(newcounter){
                        //alert('New object created');
                        },
                        error: function(newcounter,error){
                        alert('Failed to create');
                        }
                        });
                }
            },
            error: function(error){
                //find null is not a error
                alert('Error:'+error.code+" "+error.message);
            }
        });
}
$(function(){
        var Counter=AV.Object.extend("Counter");
        //only increse visit counting when intering a page
        if ($('.article-title').length == 1)
           addCount(Counter);
        var query=new AV.Query(Counter);
        query.descending("time");
        // the sum of popular posts
        query.limit(10); 
        query.find({
            success: function(results){
                    for(var i=0;i<results.length;i++)    
                    {
                        var counter=results[i];
                        title=counter.get("title");
                        url=counter.get("url");
                        time=counter.get("time");
                        // add to the popularlist widget
                        showcontent=title+" ("+time+")";
                        //notice the "" in href
                        $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                    }
                },
            error: function(error){
                alert("Error:"+error.code+" "+error.message);
            }
            }
        )
        });
</script>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017 
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>
<script src="/assets/highlight.pack.js?rev=@@hash"></script>
  <script>
    hljs.initHighlightingOnLoad(); //初始化代码高亮 
  </script>

<script src="/js/app.js?rev=@@hash"></script>
</body>
