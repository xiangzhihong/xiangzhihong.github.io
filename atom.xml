<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向志洪</title>
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiangzhihong.com/"/>
  <updated>2018-03-17T07:46:01.931Z</updated>
  <id>http://www.xiangzhihong.com/</id>
  
  <author>
    <name>xiangzhihong</name>
    <email>1044817967@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter环境搭建</title>
    <link href="http://www.xiangzhihong.com/2018/03/01/Flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiangzhihong.com/2018/03/01/Flutter环境搭建/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-17T07:46:01.931Z</updated>
    
    <content type="html"><![CDATA[<p>这几年，移动跨平台的趋势可以说是越来越明显，技术实现上也是百花争艳，不过究其实现，无外乎有那么几种。</p>
<p>Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能。<br>代码转换流：将某个语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发。<br>编译流：将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件。<br>虚拟机流：通过将某个语言的虚拟机移植到不同平台上来运行。<br>这方面具体的介绍可以查看我之前文章的介绍：移动跨平台开发方案总结。相比较于目前比较好的跨平台开发，有几个比较好的框架：React Native，Flutter和Weex。对于React Native 想必大家应该不陌生，ReactNative 简称是RN ，是 Facebook于15年开源的一个跨平台的框架，目前已经趋于稳定。Flutter则是由Google基于Dart语言开发的一个移动跨平台开发框架，实际上就是以前的Sky SDK，是React Native的竞争对手。Weex 则是阿里开发的一套简单易用的跨平台开发方案，使用较少，没有前面两个名气大。</p>
<p>Flutter 和 React Native 区别<br>在正式介绍Flutter之前，让我们先来看一下Flutter和React Native实现上的一些异同。<br>对React Native 稍有了解的读者都知道， React Native 是基于组件进行开发的，这和原生APP的开发思路是一致的，不同的是 React Native提供的组件都是继承自原生Native 的 View 组件，通过调用原生的平台组件来实现UI的绘制工作。比如React Native 中的 ListView 在 Android 中就是继承自 ListView ，还有 RecycleView，对于IOS来说则是TableView组件。</p>
<p>然而 Flutter 则不同，它的所有 UI 组件都是一帧一帧画出来的。Flutter不需要底层的转换操作，因而在界面绘制上更加准确灵活。其次它还非常人性化的贴近了平台的特性，比如 Android 的 Material Design 在 Flutter 就默认支持了进去。</p>
<p>编写语言方面，两平台都是为了推广自己的技术，Flutter 使用的是 Dart 语言开发（基本没怎么听说过），而 React Native 则使用 JSX来开发的，借鉴了React的很多东西。</p>
<p>Dart简介<br>相信并没有几个读者知道还有 Dart 这种语言，说实在的我也没怎么听过。Dart 是Google于2011年推出的定位应用编程的语言，据说目的是取代传统的JS。相比同时代的go定位服务器系统，Dart可以说并不是很成功。学习Dart可以通过中文社区来学习：<a href="http://www.cndartlang.com/。当然，Dart也提供了在线编写运行代码的功能，官方地址为：https://www.dartlang.org/。" target="_blank" rel="external">http://www.cndartlang.com/。当然，Dart也提供了在线编写运行代码的功能，官方地址为：https://www.dartlang.org/。</a></p>
<p>Flutter环境搭建<br>Flutter是Google推出的一款是移动端跨平台开发框架，使用Dart语言编写，一套代码即可同时在Android和iOS平台运行，支持android 4.1以上 和 iOS8以上版本，官方地址为：<a href="https://flutter.io/。如果想要了解更多的内容，也可以通过官方的文档来了解：https://flutter.io/faq/#what-is-flutter。" target="_blank" rel="external">https://flutter.io/。如果想要了解更多的内容，也可以通过官方的文档来了解：https://flutter.io/faq/#what-is-flutter。</a></p>
<p>1，下载SDK<br>“工欲善其事，必先利其器”，学习任何一门技术都需要先搭建相关的开发环境，并来一个Hello Word。搭建Flutter环境，读者可以通过Flutter托管在Github上的源码地址来学习。</p>
<p>1，首先，在mac的Terminal输入命令将Flutter SDK下载到本地。命令如下：</p>
<p>git clone -b beta <a href="https://github.com/flutter/flutter.git" target="_blank" rel="external">https://github.com/flutter/flutter.git</a><br>1<br>2<br>由于我是Mac 系统，那么Flutter SDK 下载完后的完整路径为：Users/xiangzhihong/Flutter/flutter/ 。接下来需要配置环境变量，打开终端依次输入如下命令：</p>
<p>cd $HOME<br>open -e .bash_profile<br>1<br>2<br>添加 Flutter SDK 的路径：</p>
<p>export PATH=${PATH}:/Users/xiangzhihong/Flutter/flutter/bin:$PATH<br>1<br>然后使用下面的命令更新刚配置的环境变量。</p>
<p>source .bash_profile<br>1<br>然后使用命令行“flutter doctor”来检测其他的一些依赖，安装 Futter 剩余依赖项。</p>
<p>cd ./flutter<br>flutter doctor<br>1<br>2<br>这个命令会检查环境并在窗口显示报告，Dart SDK与Flutter捆绑在一起;没有必要单独安装Dart。<br>这里写图片描述<br>最后，Flutter SDK下载后的路径： /Users/用户名/flutter，要注意的是flutter文件夹下面有多个同名的flutter文件夹，真正的SDK路径只到顶层flutter文件夹。</p>
<p>这里写图片描述</p>
<p>依赖安装完成后，如果不意外，输出内容如下：</p>
<p>Doctor summary (to see all details, run flutter doctor -v):<br>[✓] Flutter (Channel dev, v0.1.7, on Mac OS X 10.12.6 16G1212, locale zh-Hans-CN)<br>[✓] Android toolchain - develop for Android devices (Android SDK 27.0.0)<br>[!] iOS toolchain - develop for iOS devices (Xcode 9.2)<br>    ✗ libimobiledevice and ideviceinstaller are not installed. To install, run:<br>        brew install –HEAD libimobiledevice<br>        brew install ideviceinstaller<br>    ✗ ios-deploy not installed. To install:<br>        brew install ios-deploy<br>[✓] Android Studio (version 3.0)<br>[✓] Connected devices (1 available)</p>
<p>这里写图片描述</p>
<p>2, 安装idea插件<br>到jetbrains的官网下载idea开发工具，并为idea添加Flutter插件。<br>这里写图片描述<br>安装完成后重启idea，在新建项目的时候左侧菜单栏有Dart和Flutter说明这两个安装完成了，右边红色方框设置Flutter SDK。<br>这里写图片描述</p>
<p>3，测试运行项目<br>新建一个Flutter工程，工程名不能含大写字母。<br>这里写图片描述<br>如果在创建的过程中出现如下错误，那么Close Project，然后重新打开即可。<br>如果我们只想简单的实现”Hello World”，用下面的代码替换掉main.dart里面的代码即可。</p>
<p>import ‘package:flutter/material.dart’;<br>void main(){<br>  runApp(new Center(child: new Text(‘Hello Flutter!’)));<br>}</p>
<p>然后选择模拟器运行即可。<br>这里写图片描述</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几年，移动跨平台的趋势可以说是越来越明显，技术实现上也是百花争艳，不过究其实现，无外乎有那么几种。&lt;/p&gt;
&lt;p&gt;Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能。&lt;br&gt;代码转换流：将某个语言转成 Objective-C、Java 或 
    
    </summary>
    
      <category term="Flutter" scheme="http://www.xiangzhihong.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://www.xiangzhihong.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android9.0新特性曝光，你准备好了吗</title>
    <link href="http://www.xiangzhihong.com/2018/02/25/Android9.0%E6%96%B0%E7%89%B9%E6%80%A7%E6%9B%9D%E5%85%89%EF%BC%8C%E4%BD%A0%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%90%97/"/>
    <id>http://www.xiangzhihong.com/2018/02/25/Android9.0新特性曝光，你准备好了吗/</id>
    <published>2018-02-24T16:00:00.000Z</published>
    <updated>2018-03-17T07:35:07.267Z</updated>
    
    <content type="html"><![CDATA[<p>Android9.0最早出现在2018年1月25日的谷歌官网上，初步代号已经确定为“Pistachio Ice Cream”(开心果冰淇淋)，不过按照Google的惯例，如此长的三个单词代号，通常都只会在安卓新版本开发初期使用，后期会更换为更简单的单个或双个单词代号。那么Android9.0究竟带来了哪些新的特性呢，让我们先来一探究竟。</p>
<h2 id="刘海设计"><a href="#刘海设计" class="headerlink" title="刘海设计"></a>刘海设计</h2><p>安卓P 9.0的一个核心变化就是会支持类似iPhone X的刘海屏设计，能更好地优化屏幕内容布局，让系统和应用充分利用整个屏幕，尤其是刘海左右两侧的角落。<br>随着屏幕面板的成熟，今年会有越来越多的安卓手机也用上刘海屏，据说甚至包括华为。虽然iPhone X的刘海设计颇受争议，但是在Google看来，这种设计肯定会流行开来。当然，除了安卓系统支持，手机厂商、应用开发者也必须适配刘海屏，因此预计大规模的刘海屏安卓手机要到今年底或明年初才会出现。</p>
<h2 id="黑白模式切换"><a href="#黑白模式切换" class="headerlink" title="黑白模式切换"></a>黑白模式切换</h2><p>Android黑夜模式曾在Android6.0的时候出现过。可遗憾的是，谷歌迟迟没将其引入正式版。现在Android9.0上有所应用，这对于续航敏感和有关灯玩手机习惯的用户来说，新的功能特性无疑将更加舒爽、亲和。另外，像是Pixel2这样搭载OLED屏的手机也将受益，因为OLED屏有黑色完全不发光的特性，实现主动省电。</p>
<h2 id="其他性能优化"><a href="#其他性能优化" class="headerlink" title="其他性能优化"></a>其他性能优化</h2><p>自Android6.0版本之后，Android持续的对性能进行相关优化，相信此版本也不例外，在此版本中，Google改进了助手可集成于应用之中、优化电池续航、支持多屏和可折叠屏幕等等。</p>
<p>除此之外，原生Android系统还加入了以下的一些功能或者是将来会加入的一些功能，这些功能通常是现在的一些第三方Rom厂商已经开始使用的一些优化功能。</p>
<h3 id="加入长截图"><a href="#加入长截图" class="headerlink" title="加入长截图"></a>加入长截图</h3><p>相信很多用户都遇见过因为想要截取的内容仅比一个屏幕长度多一行字而截两张图的情况。如果有了滚动截屏功能，用户就可以把全部内容截取到一张图中，方便了好多。现在原生系统开始支持这一特性。<br><img src="http://img.blog.csdn.net/20180228095428299" alt="这里写图片描述"></p>
<h3 id="改善自带文件管理器"><a href="#改善自带文件管理器" class="headerlink" title="改善自带文件管理器"></a>改善自带文件管理器</h3><p>像电脑一样，安卓一直都允许用户管理手机上的文件，但安卓却没有自带文件管理器。好在从6.0棉花糖开始，原生安卓就加入了自带的文件管理器。<br><img src="http://img.blog.csdn.net/20180228095551106" alt="这里写图片描述"><br>现在，系统将自带这一功能，自带文件管理器比第三方APP简洁得多，而且该有的功能都有，包括本地和网盘文件管理。可是竟然没有快捷方式。<br><img src="http://img.blog.csdn.net/20180228100312810" alt="这里写图片描述"><br>要打开自带的文件管理器，用户需要进入“设置”，然后点击“存储”，然后等待存储数据读取完毕，之后再点击“文件”。如此繁琐的步骤简直是反人类。这个问题在最新的安卓8.1依然存在。希望谷歌能在未来的版本内加入一个类似“文件管理器”APP图标的快捷方式。</p>
<h3 id="加入护眼模式"><a href="#加入护眼模式" class="headerlink" title="加入护眼模式"></a>加入护眼模式</h3><p>早期，手机只有“夜间模式”，仅是单纯地把画面调成了暗色调。现在，不少手机都有了“护眼模式”，比如iOS的“Night Shift”和厂商定制安卓的护眼模式。然而原生安卓就没有这个功能。<br><img src="http://img.blog.csdn.net/20180228100408931" alt="这里写图片描述"></p>
<h3 id="不信任的来源应用安装逻辑"><a href="#不信任的来源应用安装逻辑" class="headerlink" title="不信任的来源应用安装逻辑"></a>不信任的来源应用安装逻辑</h3><p>为了切断手机恶意程序的最大来源，安卓系统允许用户禁止手机从不信任来源安装APP。如果用户开启了这个限制，每次从未授权来源安装软件时，系统都会提示不能安装，除非解除安装来源的限制。这个和ios的策略是一样的。<br><img src="http://img.blog.csdn.net/20180228100548110" alt="这里写图片描述"></p>
<p>但是，不同厂商系统的操作逻辑不一样。在三星的TouchWiz上，在未授权来源安装APP时，用户可以允许这一次未知来源安装，但不会更改“不允许未知来源安装”的全局设置。这样既可以允许这次安装，又不用再“翻山越岭”回到安全设置界面再次启用安装限制(不启用的话手机会失去保护)。</p>
<h3 id="自带日历震动提示"><a href="#自带日历震动提示" class="headerlink" title="自带日历震动提示"></a>自带日历震动提示</h3><p>安卓自带的谷歌日历什么都好，唯一缺点就是震动提示几乎察觉不到。如果我在今天设一个晚上6点提示我吃饭的提醒。碰巧手机没开铃声的话，到了晚上6点，谷歌日历仅会以不到一秒的时长震动一下。<br><img src="http://img.blog.csdn.net/20180228100747222" alt="这里写图片描述"></p>
<p>如此不明显的震动很容易被错过。要知道微信、短信等应用的通知都会至少震动两下。一般用户只在事件很重要的情况下才设置日历提醒。这种还不如“蚊子叫”来得明显的震动提示实在是耽误事。</p>
<h3 id="允许定制主屏搜索栏"><a href="#允许定制主屏搜索栏" class="headerlink" title="允许定制主屏搜索栏"></a>允许定制主屏搜索栏</h3><p>每次打开一个原生安卓系统的手机，你都会注意到屏幕顶部大大的“谷歌搜索栏”(Pixel系列在底部)。为什么就不能让用户定制这个搜索栏呢?Chrome浏览器里我都能把默认搜索引擎改成百度。而且不仅不能改，还不能把它从屏幕上去掉。<br><img src="http://img.blog.csdn.net/20180228100909652" alt="这里写图片描述"></p>
<h3 id="应用多开"><a href="#应用多开" class="headerlink" title="应用多开"></a>应用多开</h3><p>有不少第三方定制安卓都有应用多（双）开的功能，比如MIUI的“应用分身”。虽然有些应用分身体验并不好，而且还很费电，但总比没有强。<br><img src="http://img.blog.csdn.net/20180228101108986" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android9.0最早出现在2018年1月25日的谷歌官网上，初步代号已经确定为“Pistachio Ice Cream”(开心果冰淇淋)，不过按照Google的惯例，如此长的三个单词代号，通常都只会在安卓新版本开发初期使用，后期会更换为更简单的单个或双个单词代号。那么A
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>智能合约，代币（Token）区块链技术概念</title>
    <link href="http://www.xiangzhihong.com/2018/02/16/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%8C%E4%BB%A3%E5%B8%81%EF%BC%88Token%EF%BC%89%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.xiangzhihong.com/2018/02/16/智能合约，代币（Token）区块链技术概念/</id>
    <published>2018-02-15T16:00:00.000Z</published>
    <updated>2018-03-17T07:36:49.258Z</updated>
    
    <content type="html"><![CDATA[<p>智能合约（Smart  Contract）是区块链一个重要的功能。说到智能合约，我们得把视野从比特币转到以太坊，因为完整的支持智能合约是以太坊和比特币的重大差别。</p>
<p>让我们发个币吧</p>
<p>听说区块链上可以发币，想发行一个自己的币 ①？来，直接上代码！</p>
<p>我希望你即使不懂代码，也要放下对未知的恐惧，静下心来一行一行读。毕竟这代码简单到大多数人都能看懂。</p>
<p>contract XMT {</p>
<pre><code>mapping (address =&gt; uint) public balanceOf;



function XMT() public {

    balanceOf[msg.sender] = 1000;

}



function transfer(address to, uint value) public {

    require(balanceOf[msg.sender] &gt;= value);

    require(balanceOf[to] + value &gt;= balanceOf[to]);

    balanceOf[msg.sender] -= value;

    balanceOf[to] += value;

}
</code></pre><p>}</p>
<p>惊人之处来了。如上代码不是概念性的伪代码，而是可以运行的真实代码。</p>
<p>首先它定义了一个记录每个账户有多少余额的数组： balanceOf 。</p>
<pre><code>mapping (address =&gt; uint) public balanceOf;
</code></pre><p>看不懂的同学就把它当作有两列的表格，第一列是账号，第二列是余额。用 balanceOf [ 账号 ] 就可以查到这个账号的余额，也可以更改余额。</p>
<p>接下来是两个功能：初始化和转账。</p>
<p>初始化函数XMT( )很简单，就是合约建立的时候，任性的把1000个币全都给创建者。</p>
<pre><code>balanceOf[msg.sender] = 1000;
</code></pre><p>大家要问，币是怎么产生的？没什么产生过程，想给谁多少就是多少。初始的时候写一个亿也就有了一个亿的币。如此随意的就能产生币，希望会引发大家在夜深人静的时候，对于货币到底是什么这样的深层思考。</p>
<p>我们接着看：</p>
<p>转账代码 transfer( ) 核心是两句：</p>
<pre><code>balanceOf[msg.sender] -= value;

balanceOf[to] += value;
</code></pre><p>谁发起的转账，就把他(msg.sender)的账户余额减去转账金额(value)那么多，然后把收款人(to)的余额加上那么多②。</p>
<p>别小看这两句话。仔细琢磨一下，这其实就是账户和转账的本质。这简单的两句话是银行体系这么多年花了多少的硬件软件，人力物力才能达到的效果。</p>
<p>大家常常听说谁谁谁又发币了。从技术角度，就是在以太坊上部署了包含这三行代码的一个合约。在以太坊的官方网站上就有一段100多行的标准代码：<a href="https://ethereum.org/token。这段代码里面还有其他一些功能，比如可以给这个代币指定名称，符号，还有授权转账，销毁等功能。大家只要拷贝这个代码，指定你的新币的名称（比如" target="_blank" rel="external">https://ethereum.org/token。这段代码里面还有其他一些功能，比如可以给这个代币指定名称，符号，还有授权转账，销毁等功能。大家只要拷贝这个代码，指定你的新币的名称（比如</a> Xiaomao Token），符号（比如：XMT） ⑦，还有初始发行量比如：1,000,000,000)，一个新的币就诞生了。整个过程3分钟应该够了。把参数改一下再部署一下代码，第二个新币又诞生了。</p>
<p>这新生的货币，虽然没啥用，但在安全性方面和以太币天生是一样的。这就像家长给孩子发了一些饭票，而这饭票的防伪技术和美元一模一样。看起来相当的大材小用，但如果把发货币成本降到几乎为零，把防伪能力提升到已知的最高水平，随着时间的推移，难说不会产生什么重要的应用。</p>
<p>部署代码</p>
<p>代码看懂了，下一步呢？怎么运行这代码？这代码到底在哪里运行呢？接着我们看部署过程。</p>
<p>部署代码，你需要在以太坊的客户端里，把这段代码粘贴进去，并且按“部署”按钮。客户端就会把这种人可以读懂的代码③编译成字节码，然后生成一笔从你的地址，发给一个空地址（0x0）的交易，并把字节码存在一个给定的字段里面（叫input），签名后发到整个网络上。接下来的操作和普通交易完全一样。矿工收到了以后立刻开始打包，算nonce，找到了以后再发送给全网络。这个可以被执行的代码，就永久的以只可读取不可更改的方式，存在了区块链上。</p>
<p>智能合约建立后会返回一个地址。每个币都唯一的对应于一个智能合约，也就是对应于一个地址。比如著名的EOS币，就是地址为 0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0 的智能合约发行的。你可以把这个地址想象成以太坊世界里的门牌号。币是以这个唯一的门牌号来区分的，而不是那三位的名字。</p>
<p>调用合约</p>
<p>现在，合约的代码安全的存在区块链上了。那么接下来这些代码什么时候执行呢？</p>
<p>一个智能合约里面有多个函数。调用智能合约里的一个函数，和发起一笔普通转账交易一样。很多的客户端已经内置进去了。你提供合约的地址，提供调用的函数，以及传入参数，然后发送消息就开始执行了⑤。你可以把它理解为从门牌号的屋子里面拿东西或者放东西进到给定的屋子。</p>
<p>消息发出以后，所有的矿工都执行这段代码，并且试图把结果打包到自己的数据块中，胜出的矿工获得挖矿的收益。所有的节点收到这个新的区块，也用自己的虚拟机执行一遍代码，确认结果和收到的块内结果无异之后才当作合法区块接受。</p>
<p>区块链就是通过这种超额的浪费，看似无意义的算nonce，看似无意义的反反复复，没完没了的执行同一段代码，来保证了一个安全的系统。这事儿就跟早上叠被子晚上还得展开一样，看似不产生价值，实则是房（shu）间（ju）整（an）洁（quan）不可或缺的一环。</p>
<p>花费 Gas</p>
<p>既然代码要被所有节点反复执行，那么问题就来了：要是谁写了巨长无比的代码，或者谁写了有问题的代码，死循环不结束了怎么办？以太坊的解决方法就是引入gas，每执行一个操作都是收费的。怎么收费呢？</p>
<p>首先每个交易的代码执行量越大，需要的gas就越多。字节码每一个操作都有固定的gas花销。以发币代码为例，如下是以太坊给我发的账单。总共执行了320步字节码的操作。有的操作很便宜，比如压栈(PUSH1)，只要3个单位的gas，有的就很贵，比如在区块链上存数据(SSTORE)就一下子花了20,000个单位，而读取数据(SLOAD) 中等， 200个单位。如下加在一起就是1,300,213个单位的gas。只要执行这段代码，就是要这么多gas，好像汽车修理店工时的概念。</p>
<p>提交的时候每个人都可以出价，声明自己愿意为每个单位gas付多少钱(price)。这个有点像修理店的每工时的价钱。比如你可以出8 gwei/gas，或20 gwei/gas ⑥。矿工们大多数都是按照这个价钱排序优先打包出钱多的。出钱少就慢，甚至没人理。</p>
<p>矿工的费用 =  gas单位数 * 单位价格。</p>
<p>如下图所示交易，1,300,213 gas * 2 gwei/gas = 2,600,426 gwei，或0.002600426 以太币，折合1.832美元。最终把这笔交易打包进区块链的矿工获得这部分费用。</p>
<p>除了价格以外，还需要指定一个gas limit，就是你为了这段代码最多愿意付多少单位的gas。这就是为了预防代码出现问题，无限循环下去，直到把你的账户里的钱耗尽为止。如上图，gas limit设为1,300,213个，这段代码实际上也只用了1,300,213个单位的gas，还好，正好没有超过限制。否则超过了程序执行会嘎然而止，已经花的gas不退。</p>
<p>智能合约的价值</p>
<p>智能合约第一次认可了代码的自主权。代码可以拥财产，可以和人一样平等的在区块链上交易。一个合约的代码一旦发布，谁都改不了了，连上帝都无能为力。这就是信任的来源。大家可以像坚信自然定律一样坚信这个合约如代码所写的执行。你不需要相信任何人，只需要认真的读智能合约的代码，就可以确定性的知道这个合约将如何执行。</p>
<p>如上从技术层面简单的介绍了一下智能合约的过程。但智能合约和区块链真正的价值不在技术，而是它们对于价值传递以及信任建立的贡献。</p>
<p>我们看到的人类发展总是多条线并进，一条是生产效率，蒸汽机，电力，计算机，互联网，人工智能等都在这条线上；区块链是生产关系的进步这条线上的，这条线上曾经有过货币，现代公司制度，股票，现在有了区块链。</p>
<p>晚一些我再聊一下它对信任的贡献，还有可能对于社会的改变。</p>
<p>后注</p>
<p>① 很多专业人士希望把token翻译成通证，而不是代币。“通证”更加符合单词原意，符合事物本质，也希望避免被当作货币监管。这像极了“网志”和“博客”两个译名之争。结果博客被接受，更加准确，拗口，后来出现的网志不再有人提起。这个结果或许可以预测通证这个翻译的结果。</p>
<p>②Transfer函数前面的两句require，第一个是要求你的余额必须大于转账金额，第二个是要求转账金额不要过大以至于大于256位整数能容纳的数字。msg.sender 是内置的，可以获取消息的发送人的地址。</p>
<p>③可以搜索Remix，或MyEtherWallet。Solidity的语法和JavaScript很像，专门用于以太坊上编写智能合约。</p>
<p>④这里解释一下技术细节。建立合约的时候，用户发起一笔发款人为自己，收款人为空地址 0x0 的交易，并把字节码放到交易里面叫做输入（Input）的字段里面。矿工就会生成一个新的合约地址并把代码存在这个地址里。</p>
<p>⑤技术实现，其实是在交易数据的Input字段加上了一个编码后的数字。比如这串数字：a9059cbb00000000000000000000000007fdf7518745170e3d9de26874578b6c0a72b9dc0000000000000000000000000000000000000000000000000000000000000010</p>
<p>颜色是我为了区分加的，前四字节a9059cbb是函数名 ，”transfer(address,uint256)”这个字符串的SHA3-256哈希结果a9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b的前4位，用来指定是哪一个函数，根据函数定义，就知道后32位是第一个参数：地址 ，也就是0x07fdf7518745170e3d9de26874578b6c0a72b9dc。接下来32个字节是</p>
<p>金额 ，相当于十进制16。大家看得出，现在的区块链从抽象水平上基本上还停留在计算机的DOS和汇编语言的时代。</p>
<p>⑥ 1 gwei 就是 1,000,000,000 个wei。这个g就跟内存单位多少GB的G是一个概念，就是10亿的意思。10的18次方个wei就等于一个以太币。所以1 gwei看起来很大，其实也就是10的9次方分之1个以太币而已。一个以太币在我写这篇文章的时候是764美元，你大概有概念了是多少钱了吧。</p>
<p>⑦ 发币时候指定的名称，符号，仅仅就是一个字付串，是可以重复的。你可以发一个币叫USD，RMB，或任何你能想象的名字。Token是以发行这个Token的智能合约的地址唯一指定的，和名字无关。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;智能合约（Smart  Contract）是区块链一个重要的功能。说到智能合约，我们得把视野从比特币转到以太坊，因为完整的支持智能合约是以太坊和比特币的重大差别。&lt;/p&gt;
&lt;p&gt;让我们发个币吧&lt;/p&gt;
&lt;p&gt;听说区块链上可以发币，想发行一个自己的币 ①？来，直接上代码！&lt;/
    
    </summary>
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Gradle构建缓存</title>
    <link href="http://www.xiangzhihong.com/2018/02/15/%E4%BD%BF%E7%94%A8Gradle%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAKotlin%E7%BC%93%E5%AD%98/"/>
    <id>http://www.xiangzhihong.com/2018/02/15/使用Gradle方式构建Kotlin缓存/</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2018-03-17T07:33:32.943Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 1.2.21 允许 Kotlin 项目使用构建缓存，通过 Gradle 的构建缓存功能，可以提升 Kotlin 代码的编译速度，加快开发周期。本文将结合实际例子，介绍利用 Gradle 加速 Kotlin 代码编译的原理、配置示例以及在 IDE 中的使用方法。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>构建缓存的工作原理是在缓存中存储编译过的类、测试结果和其它构建工序，同时记录所有的任务输入，包括输入文件内容、相关的类路径和任务配置。其模型如下图所示：<br><img src="http://img.blog.csdn.net/20180221143237236" alt="这里写图片描述"></p>
<p>下面的图标展示了在 Gradle 的持续集成中使用构建缓存和不使用构建缓存所收集到的构建时间。<br><img src="http://img.blog.csdn.net/201802211433338" alt="这里写图片描述"></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>你现在就可以尝试使用 Gradle 的构建缓存。只需要遵循下面几个步骤：</p>
<h2 id="1，Clone-Spek"><a href="#1，Clone-Spek" class="headerlink" title="1，Clone Spek"></a>1，Clone Spek</h2><p>使用以下命令clone Spek.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/spekframework/spek.git</div><div class="line">cd spek</div></pre></td></tr></table></figure>
<p>Spek 2.x分支（其默认分支）已经有我们后续要介绍的 构建缓存的所有先决条件。</p>
<p>##2，构建和填充缓存<br>下面的命令会构建 Spek 并填充本地构建缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">❯ ./gradlew assemble --build-cache</div><div class="line"></div><div class="line">BUILD SUCCESSFUL in 10s</div><div class="line">21 actionable tasks: 21 executed</div></pre></td></tr></table></figure>
<p>使用–build-cache标识，可以让 Gradle 在一个独立的任务结果缓存中存储任务结果。</p>
<p>##3，删除 / 更改构建结果<br>这模拟了在另一台机器上的情况或者做了一次改变并stash（存储）这次改变的情况。演示的最快方法是使用clean任务。</p>
<h2 id="4，-从构建缓存中重新构建"><a href="#4，-从构建缓存中重新构建" class="headerlink" title="4， 从构建缓存中重新构建"></a>4， 从构建缓存中重新构建</h2><p>当我们重新构建时，从构建缓存中拉取所有编译过的 Kotlin 源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">❯ ./gradlew assemble --build-cache</div><div class="line"></div><div class="line">BUILD SUCCESSFUL in 2s</div><div class="line">21 actionable tasks: 11 executed, 10 from cache</div></pre></td></tr></table></figure>
<p>到此就配置完成了，通过使用 Gradle 的构建缓存，你重用了编译过的 Kotlin 类，而不是又重新编译！构建速度差不多快了 5 倍！可以看到，Kotlin 编译任务从构建缓存中拉取缓存结果；而:jar和:processResources任务没有从缓存中拉取，因为它们本地生成 JAR 包和复制文件的速度比从缓存中拉取缓存结果的速度更快。另外 Gradle 构建缓存也支持缓存:test任务。当持续集成的一个实例填充了一个 共享的构建缓存（开发者可以从中拉取）时，Gradle 构建缓存会特别有效。下文罗列了实现这点的 更多资源的链接。</p>
<h1 id="老项目如何使用"><a href="#老项目如何使用" class="headerlink" title="老项目如何使用"></a>老项目如何使用</h1><p>首先，你需要确保正在使用 Gradle 4.3 或者更高版本，这样才能选择 Kotlin Gradle Plugin 来使用新的 Gradle APIs。你可以方便地使用 Gradle wrapper 升级 Gradle。</p>
<p>然后，你需要确保正在使用 Kotlin 1.2.20 或更高版本来进行编译。你在自己的构建脚本build.gradle中的buildscript {}块中配置类似如下的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.21&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们需要让 Gradle 使用构建缓存。有 3 种启用构建缓存的方法：</p>
<ul>
<li>在命令行中使用–build-cache来为当前构建启用构建缓存。</li>
<li>在$PROJECT_ROOT/gradle.properties中增加org.gradle.caching=true来为整个项目启用构建缓存。</li>
<li>在$GRADLE_HOME/gradle.properties中增加org.gradle.caching=true来为当前用户的所有构建启用构建缓存。</li>
</ul>
<p><strong>注意</strong>: Android 开发者即使设置了android.enableBuildCache=true，也仍需要按照上述方法启用构建缓存，因为 Gradle 的构建缓存是独立于 Android 的构建缓存的。</p>
<p>我们可以选择通过将 run 和 test actions 委派给 Gradle 的方式，来利用 IDE 的构建缓存。</p>
<h1 id="在-IntelliJ-中启用构建缓存"><a href="#在-IntelliJ-中启用构建缓存" class="headerlink" title="在 IntelliJ 中启用构建缓存"></a>在 IntelliJ 中启用构建缓存</h1><p>如果你使用 IntelliJ 来执行 Gradle actions，你需要在 IDE 配置中勾选“Delegate IDE build/run actions to Gradle（将 IDE 构建 / 运行动作委派给 Gradle）”，从而在 IntelliJ 中构建和运行测试时利用构建缓存。<br><img src="http://img.blog.csdn.net/20180221143956923" alt="这里写图片描述"></p>
<h1 id="缓存-kapt-任务"><a href="#缓存-kapt-任务" class="headerlink" title="缓存 kapt 任务"></a>缓存 kapt 任务</h1><p>目前即使使用–build-cache，针对kapt的缓存也默认是禁用的，因为 Gradle 还没有一种方法来映射注解处理器的输入和输出。你可以通过在kapt配置中将useBuildCache设置为true来明确启用针对 Kotlin 注解处理任务的构建缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kapt &#123;</div><div class="line">useBuildCache = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：<br>你可以通过下列资源来了解更多关于利用 Gradle 构建缓存的信息：</p>
<p><a href="https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_configure" target="_blank" rel="external">https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_configure</a><br><a href="https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_configure_remote" target="_blank" rel="external">https://docs.gradle.org/current/userguide/build_cache.html#sec:build_cache_configure_remote</a><br><a href="https://guides.gradle.org/using-build-cache/#debugging_and_diagnosing_cache_misses" target="_blank" rel="external">https://guides.gradle.org/using-build-cache/#debugging_and_diagnosing_cache_misses</a><br><a href="https://docs.gradle.org/current/userguide/build_cache.html#sec:task_output_caching_details" target="_blank" rel="external">https://docs.gradle.org/current/userguide/build_cache.html#sec:task_output_caching_details</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin 1.2.21 允许 Kotlin 项目使用构建缓存，通过 Gradle 的构建缓存功能，可以提升 Kotlin 代码的编译速度，加快开发周期。本文将结合实际例子，介绍利用 Gradle 加速 Kotlin 代码编译的原理、配置示例以及在 IDE 中的使用方法。
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>React Native 的开源协议</title>
    <link href="http://www.xiangzhihong.com/2018/02/12/React%20Native%E5%B0%86license%E4%BF%AE%E6%94%B9%E4%B8%BAMIT%E6%84%8F%E6%AC%B2%E4%BD%95%E4%B8%BA/"/>
    <id>http://www.xiangzhihong.com/2018/02/12/React Native将license修改为MIT意欲何为/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-03-17T07:31:48.914Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，Facebook 在 GitHub 上修改了 React Native 的开源协议（由Facebook BSD+Patents 修改为MIT），这意味着 React Native 将同 React 一样不再使用 Facebook BSD+Patents 协议，而是使用 MIT 协议。</p>
<p>#背景知识<br>BSD、MIT 和 Apache v2 是常用的三个开源软件协议，但 Facebook 使用的却是 BSD+Patents 协议，Patents 协议是 Facebook 的“特产”，称为专利附属条款，被视为 Facebook 用于解决开源代码中可能出现的专利纠纷的防御措施。</p>
<p>Patents 协议是 2015 年 Facebook 添加的，大致内容是使用基于 Facebook BSD+Patents 协议的开源项目的开发者，未来要是因为专利问题与 Facebook 产生纠纷，那么 Facebook 将有权停止你使用该开源项目，也就是说如果你起诉 Facebook，那么你所使用他们的开源技术开发的产品要么得停用，要么得用别的技术迁移重构，这对企业来说是一个重大的灾难。</p>
<p>虽然这个附属协议引起了社区开发者们强烈地不满，上书诉求不断，但是都没能改变 Facebook 的决定，因为 Facebook 认为这样的协议虽然会让他们失去一些用户，但从长远来看，可以让他们在诉讼上减少金钱和时间的浪费。</p>
<p>但是到了 2017 年 7 月，开源组织 Apache 软件基金会将基于 Facebook BSD+Patents 协议的开源软件列入黑名单让事情出现了转机，同年 9 月，WordPress、百度等大型公司宣布停用 React（Native) 开源项目以规避风险，此后，Facebook 才公开发表声明，表示从 v16 开始，React 将不再使用 BSD+Patents 协议，而是采用 MIT 协议。</p>
<p>由于去年 9 月 Facebook 只是宣布将 React、Jest、Flow 和 Immutable.js 执行 MIT 协议，但同作为 Facebook 黄金级别的开源项目 React Native 却维持 BSD+Patents 协议，这自然引发开发者的热议与不满。在经过开发者几个月的努力之下，Facebook 终于为之所动，让 React Native 采用 MIT 标准。</p>
<p>Facebook 在社区的压力下进行退让，让开发者对 Facebook 的开源项目重拾信心，这种抛弃单惠协议，重持开源精神的做法也让 React Native 开发者狂欢！</p>
<p>大家可以到以下地址进行投诉和查看RN的最新情况：<br><a href="https://github.com/facebook/react-native/issues/16069" target="_blank" rel="external">https://github.com/facebook/react-native/issues/16069</a><br><a href="https://github.com/facebook/react-native/issues/16079" target="_blank" rel="external">https://github.com/facebook/react-native/issues/16079</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天，Facebook 在 GitHub 上修改了 React Native 的开源协议（由Facebook BSD+Patents 修改为MIT），这意味着 React Native 将同 React 一样不再使用 Facebook BSD+Patents 协议，而是使
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android+TensorFlow+CNN+MNIST实现手写数字识别</title>
    <link href="http://www.xiangzhihong.com/2018/02/08/Android+TensorFlow+CNN+MNIST%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://www.xiangzhihong.com/2018/02/08/Android+TensorFlow+CNN+MNIST实现手写数字识别/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-02-11T03:32:44.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>TensorFlow： 1.2.0</li>
<li>Python： 3.6</li>
<li>Python IDE： PyCharm 2017.2</li>
<li>Android IDE： Android Studio 3.0</li>
</ul>
<h2 id="训练与评估"><a href="#训练与评估" class="headerlink" title="训练与评估"></a>训练与评估</h2><p>训练和评估部分主要目的是生成用于测试用的pb文件，其保存了利用TensorFlow python API构建训练后的网络拓扑结构和参数信息，实现方式有很多种，除了cnn外还可以使用rnn，fcnn等。<br>其中基于cnn的函数也有两套，分别为tf.layers.conv2d和tf.nn.conv2d， tf.layers.conv2d使用tf.nn.conv2d作为后端处理，参数上filters是整数，filter是4维张量。原型如下：</p>
<h3 id="convolutional-py文件"><a href="#convolutional-py文件" class="headerlink" title="convolutional.py文件"></a>convolutional.py文件</h3><p>def conv2d(inputs, filters, kernel_size, strides=(1, 1), padding=’valid’, data_format=’channels_last’,<br>dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer=None,<br>bias_initializer=init_ops.zeros_initializer(), kernel_regularizer=None, bias_regularizer=None,<br>activity_regularizer=None, kernel_constraint=None, bias_constraint=None, trainable=True, name=None,<br>reuse=None)</p>
<h3 id="gen-nn-ops-py-文件"><a href="#gen-nn-ops-py-文件" class="headerlink" title="gen_nn_ops.py 文件"></a>gen_nn_ops.py 文件</h3><p>def conv2d(input, filter, strides, padding, use_cudnn_on_gpu=True, data_format=”NHWC”, name=None)<br>官方Demo实例中使用的是layers module，结构如下：</p>
<ul>
<li>Convolutional Layer #1：32个5×5的filter，使用ReLU激活函数</li>
<li>Pooling Layer #1：2×2的filter做max pooling，步长为2</li>
<li>Convolutional Layer #2：64个5×5的filter，使用ReLU激活函数</li>
<li>Pooling Layer #2：2×2的filter做max pooling，步长为2</li>
<li>Dense Layer #1：1024个神经元，使用ReLU激活函数，dropout率0.4<br>(为了避免过拟合，在训练的时候，40%的神经元会被随机去掉)</li>
<li>Dense Layer #2 (Logits Layer)：10个神经元，每个神经元对应一个类别（0-9）</li>
</ul>
<p>核心代码在cnn_model_fn(features, labels, mode)函数中，完成卷积结构的完整定义，核心代码如下：<br><img src="http://img.blog.csdn.net/2018021110052588" alt="这里写图片描述"></p>
<p>也可以采用传统的tf.nn.conv2d函数, 核心代码如下:<br><img src="http://img.blog.csdn.net/20180211100635272" alt="这里写图片描述"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>核心是使用API接口： TensorFlowInferenceInterface.java</li>
<li>配置gradle 或者 自编译TensorFlow源码导入jar和so compile<br>‘org.tensorflow:tensorflow-android:1.2.0’</li>
<li>导入pb文件.pb文件放assets目录，然后读取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String actualFilename = labelFilename.split(“file:///android_asset/“)[1];</div><div class="line">Log.i(TAG, “Reading labels from: “ + actualFilename);</div><div class="line">BufferedReader br = null;</div><div class="line">br = new BufferedReader(new InputStreamReader(assetManager.open(actualFilename)));</div><div class="line">String line;</div><div class="line">while ((line = br.readLine()) != null) &#123;</div><div class="line">c.labels.add(line);</div><div class="line">&#125;</div><div class="line">br.close();</div></pre></td></tr></table></figure>
<ul>
<li>TensorFlow接口使用如下：<br><img src="http://img.blog.csdn.net/20180211100843563" alt="这里写图片描述"></li>
</ul>
<p>最终的测试效果为：<br><img src="http://img.blog.csdn.net/20180211100929993" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180211100947212" alt="这里写图片描述"></p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h2><p>MNIST，最经典的机器学习模型之一，包含0~9的数字，28*28大小的单色灰度手写数字图片数据库，其中共60,000 training examples和10,000 test examples。<br>文件目录如下，主要包括4个二进制文件，分别为训练和测试图片及Label。<br><img src="http://img.blog.csdn.net/20180211101452932" alt="这里写图片描述"></p>
<p>如下为训练图片的二进制结构，在真实数据前（pixel），有部分描述字段（魔数，图片个数，图片行数和列数），真实数据的存储采用大端规则。<br>（大端规则，就是数据的高字节保存在低内存地址中，低字节保存在高内存地址中）</p>
<p><img src="http://img.blog.csdn.net/20180211101546490" alt="这里写图片描述"></p>
<p>在具体实验使用，需要提取真实数据，可采用专门用于处理字节的库struct中的unpack_from方法，核心方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct.unpack_from(self._fourBytes2, buf, index)</div></pre></td></tr></table></figure>
<p>MNIST作为AI的Hello World入门实例数据，TensorFlow封装对其封装好了函数，可直接使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnist = input_data.read_data_sets(‘MNIST’, one_hot=True)</div></pre></td></tr></table></figure>
<h2 id="CNN（Convolutional-Neural-Network）"><a href="#CNN（Convolutional-Neural-Network）" class="headerlink" title="CNN（Convolutional Neural Network）"></a>CNN（Convolutional Neural Network）</h2><p>CNN，英文Convolutional Neural Network，中文全称卷积神经网络，即所谓的卷积网（ConvNets）。卷积（Convolution）可谓是现代深度学习中最最重要的概念了，它是一种数学运算，读者可以从下面链接<a href="http://www.qiujiawei.com/convolution/" target="_blank" rel="external">理解卷积Convolution</a>中卷积相关数学机理，包括分别从傅里叶变换和狄拉克δ函数中推到卷积定义，我们可以从字面上宏观粗鲁的理解成将因子翻转相乘卷起来。卷积动画模型如下图所示：<br><img src="http://img.blog.csdn.net/20180211102305841" alt="这里写图片描述"></p>
<p>神经网络：一个由大量神经元（neurons）组成的系统，如下图所示：<br><img src="http://img.blog.csdn.net/20180211102351322" alt="这里写图片描述"><br>其中，x表示输入向量，w为权重，b为偏值bias，f为激活函数。</p>
<p>Activation Function 激活函数： 常用的非线性激活函数有Sigmoid、tanh、ReLU等等，公式如下所示。</p>
<ul>
<li><strong>Sigmoid函数</strong>：函数饱和使梯度消失（神经元在值为 0 或 1 的时候接近饱和，这些区域，梯度几乎为 0）。同时，sigmoid 函数不是关于原点中心对称的（无0中心化）。</li>
<li><strong>tanh</strong>： 存在饱和问题，但它的输出是零中心的，因此实际中 tanh 比 sigmoid 更受欢迎。</li>
<li><strong>ReLU函数</strong>：ReLU 对于 SGD 的收敛有巨大的加速作用，只需要一个阈值就可以得到激活值，而不用去算一大堆复杂的（指数）运算。缺点是：需要合理设置学习率（learning rate），防止训练时dead，还可以使用Leaky ReLU/PReLU/Maxout等代替。<br><img src="http://img.blog.csdn.net/2018021110271226" alt="这里写图片描述"></li>
<li><p><strong>Pooling池化</strong>：一般分为平均池化mean pooling和最大池化max pooling，如下图所示[21]为max pooling，除此之外，还有重叠池化（OverlappingPooling）[24]，空金字塔池化（Spatial Pyramid<br>Pooling）</p>
<p> <strong>平均池化</strong>：计算图像区域的平均值作为该区域池化后的值。<br><strong>最大池化</strong>：选图像区域的最大值作为该区域池化后的值。</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20180211102916270" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180211102944106" alt="这里写图片描述"></p>
<h2 id="CNN-Architecture"><a href="#CNN-Architecture" class="headerlink" title="CNN Architecture"></a>CNN Architecture</h2><p><strong>三层神经网络</strong>：分别为输入层（Input layer）,输出层（Output layer）,隐藏层（Hidden layer），如下图所示。<br><img src="http://img.blog.csdn.net/20180211103302239" alt="这里写图片描述"></p>
<p><strong>CNN层级结构</strong>： 斯坦福cs231n中阐述了一种[INPUT-CONV-RELU-POOL-FC]，如上图右边图片所示，分别为输入层，卷积层，激励层，池化层，全连接层。</p>
<p>CNN通用架构分为如下三层结构：</p>
<ul>
<li>Convolutional layers 卷积层</li>
<li>Pooling layers 汇聚层</li>
<li>Dense (fully connected) layers 全连接层<br><img src="http://img.blog.csdn.net/20180211103441940" alt="这里写图片描述"></li>
</ul>
<p>用动画演示如下图：<br><img src="http://img.blog.csdn.net/20180211103625385" alt="这里写图片描述"></p>
<h2 id="Regression-Softmax"><a href="#Regression-Softmax" class="headerlink" title="Regression + Softmax"></a>Regression + Softmax</h2><p>机器学习有监督学习（supervised learning）中两大算法分别是分类算法和回归算法，分类算法用于离散型分布预测，回归算法用于连续型分布预测。<br>回归的目的就是建立一个回归方程用来预测目标值，回归的求解就是求这个回归方程的回归系数。<br>其中回归（Regression）算法包括Linear Regression，Logistic Regression等， Softmax Regression是其中一种用于解决多分类（multi-class classification）问题的Logistic回归算法的推广，经典实例就是在MNIST手写数字分类上的应用。</p>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><p>Linear Regression是机器学习中最基础的模型，其目标是用预测结果尽可能地拟合目标label。</p>
<h3 id="多元线性回归模型定义"><a href="#多元线性回归模型定义" class="headerlink" title="多元线性回归模型定义"></a>多元线性回归模型定义</h3><p><img src="http://img.blog.csdn.net/20180211103736126" alt="这里写图片描述"></p>
<h3 id="多元线性回归求解"><a href="#多元线性回归求解" class="headerlink" title="多元线性回归求解"></a>多元线性回归求解</h3><p><img src="http://img.blog.csdn.net/20180211103808629" alt="这里写图片描述"></p>
<h3 id="Mean-Square-Error-MSE"><a href="#Mean-Square-Error-MSE" class="headerlink" title="Mean Square Error (MSE)"></a>Mean Square Error (MSE)</h3><ul>
<li>Gradient Descent（梯度下降法）</li>
<li>Normal Equation（普通最小二乘法）</li>
<li>局部加权线性回归（LocallyWeightedLinearRegression, LWLR<br>)：针对线性回归中模型欠拟合现象，在估计中引入一些偏差以便降低预测的均方误差。</li>
<li><p>岭回归（ridge regression)和缩减方法。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>Normal Equation相比Gradient Descent，计算量大（需计算X的转置与逆矩阵），只适用于特征个数小于100000时使用；当特征数量大于100000时使用梯度法。当X不可逆时可替代方法为岭回归算法。LWLR方法增加了计算量，因为它对每个点做预测时都必须使用整个数据集，而不是计算出回归系数得到回归方程后代入计算即可，一般不选择。</p>
</li>
</ul>
<p>##调优<br> 平衡预测偏差和模型方差（高偏差就是欠拟合，高方差就是过拟合），通常有以下几种解决方案：</p>
<ul>
<li>获取更多的训练样本 - 解决高方差</li>
<li>尝试使用更少的特征的集合 - 解决高方差</li>
<li>尝试获得其他特征 - 解决高偏差</li>
<li>尝试添加多项组合特征 - 解决高偏差</li>
<li>尝试减小 λ - 解决高偏差</li>
<li>尝试增加 λ -解决高方差</li>
</ul>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><p>Softmax Regression估值函数（hypothesis）。<br><img src="http://img.blog.csdn.net/20180211104123217" alt="这里写图片描述"><br>Softmax Regression代价函数（cost function）。<br><img src="http://img.blog.csdn.net/20180211104212230" alt="这里写图片描述"></p>
<p>用实例来表示如下图所示：<br><img src="http://img.blog.csdn.net/20180211104252262" alt="这里写图片描述"></p>
<p>Softmax Regression &amp; Logistic Regression：</p>
<ul>
<li>多分类 &amp; 二分类。Logistic Regression为K=2时的Softmax Regression。</li>
<li>针对K类问题，当类别之间互斥时可采用Softmax Regression，当非斥时，可采用K个独立的Logistic Regression。</li>
</ul>
<p>总的来说， Softmax Regression适用于类别数量大于2的分类，本例中用于判断每张图属于每个数字的概率。</p>
<p>#附录<br><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">[01]Mnist官网</a><br><a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/" target="_blank" rel="external">[02]Visualizing MNIST: An Exploration of Dimensionality Reduction</a><br><a href="https://www.tensorflow.org/tutorials/layers" target="_blank" rel="external">[03]TensorFlow Mnist官方实例</a><br><a href="https://github.com/martin-gorner/tensorflow-mnist-tutorial" target="_blank" rel="external">[04]Sample code for “Tensorflow and deep learning, without a PhD”</a><br><a href="https://www.youtube.com/watch?v=G4G7dWBi3II" target="_blank" rel="external">[05]Convex functions</a><br><a href="http://52opencourse.com/133/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E8%AF%BE-%E6%AD%A3%E5%88%99%E5%8C%96-regularization" target="_blank" rel="external">[06]斯坦福大学机器学习第七课-正则化-regularization</a><br><a href="https://github.com/lawlite19/MachineLearning_Python" target="_blank" rel="external">[07]MachineLearning_Python</a><br><a href="https://cs231n.github.io/convolutional-networks/" target="_blank" rel="external">[08]Stanford University’s Convolutional Neural Networks for Visual Recognition course materials 翻译</a><br><a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">[09]July CNN笔记：通俗理解卷积神经网络</a><br><a href="http://www.qiujiawei.com/convolution/" target="_blank" rel="external">[10]理解卷积Convolution</a><br><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="external">[11]Imagenet classification with deep convolutional neural networks</a><br><a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="external">[12]Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a><br><a href="https://mlnotebook.github.io/post/CNN1/" target="_blank" rel="external">[13]Convolutional Neural Networks-Basics</a><br><a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="external">[14]A technical report on convolution arithmetic in the context of deep learning</a><br><a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="external">[15]Google官方Demo</a><br><a href="https://codelabs.developers.google.com/?cat=TensorFlow" target="_blank" rel="external">[16]Google官方Codelab</a><br><a href="https://hackernoon.com/deep-learning-cnns-in-tensorflow-with-gpus-cba6efe0acc2" target="_blank" rel="external">[17]deep-learning-cnns-in-tensorflow Github</a><br><a href="https://github.com/Nilhcem/tensorflow-classifier-android" target="_blank" rel="external">[18]tensorflow-classifier-android</a><br><a href="https://blog.mindorks.com/creating-custom-model-for-android-using-tensorflow-3f963d270bfb" target="_blank" rel="external">[19]creating-custom-model-for-android-using-tensorflow</a><br><a href="https://github.com/mari-linhares/mnist-android-tensorflow" target="_blank" rel="external">[20]TF-NN Mnist实例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TensorFlow： 1.2.0&lt;/li&gt;
&lt;li&gt;Python： 3.6&lt;/li&gt;
&lt;li&gt;Python I
    
    </summary>
    
      <category term="python" scheme="http://www.xiangzhihong.com/categories/python/"/>
    
    
      <category term="Python" scheme="http://www.xiangzhihong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>iOS关键组件iBoot源代码泄露</title>
    <link href="http://www.xiangzhihong.com/2018/02/07/iOS%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6iBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
    <id>http://www.xiangzhihong.com/2018/02/07/iOS关键组件iBoot源代码泄露/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-11T03:28:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>昨天（2月7日），有匿名开发者在 GitHub 上传了 iOS 核心组件的源代码，这可能会促进黑客和安全研究人员找到 iOS 漏洞，并使 iPhone 陷入危险境地。git地址：<a href="https://github.com/h1x0rz3r0/iBoot。" target="_blank" rel="external">https://github.com/h1x0rz3r0/iBoot。</a><br><img src="http://img.blog.csdn.net/201802082212557" alt="这里写图片描述"><br>不过，8日早上已经看不到相关的源码信息了，该项目已经转为Private，相关信息可以查看下面的链接：<br><a href="https://github.com/github/dmca/blob/master/2018/2018-02-08-Apple.md" target="_blank" rel="external">https://github.com/github/dmca/blob/master/2018/2018-02-08-Apple.md</a></p>
<p>iBoot 是 iOS 关键的源代码之一，在 GitHub 上被标记为“iBoot”，它确保了操作系统的可信任启动，换句话说，它是加载 iOS 的程序，是开启 iPhone 运行的第一个进程，它加载并验证内核是否被苹果正确签名，然后执行，就像 windows系统的 BIOS 一样。</p>
<p><strong>该代码适用于 iOS 9，但是部分代码可能在 iOS 11 中仍有使用。</strong><br>尽管在近几年，iOS 和 macOS 的某些代码已经逐渐开源，但苹果本质上还是非常不乐意向公众开放源代码。而且苹果已经十分注意 iBoot 的安全性和其代码的私密性， 如果通过苹果的赏金计划向其报告启动过程中的 bug，可最高获得 20 万美元。iOS 和 Mac OSX 内部系列书籍的作者 Jonathan Levin 说：“这是 iOS 历史上最大的漏洞，也将是一件大事。”</p>
<p><img src="http://img.blog.csdn.net/20180208221630225" alt="这里写图片描述"></p>
<p>Levin 说代码似乎是真正的 iBoot 代码，因为它与他自己逆向工程的代码一致。熟悉 iOS 的另一位安全研究人员也表示，他们认为代码是真实的，但他们不知道谁在泄漏，苹果到目前为止也没有回应。</p>
<p>Levin 说，通过访问 iBoot 的源代码，iOS 安全研究人员可以更好地找到可能导致设备泄密或越狱的漏洞。这意味着黑客们可以更轻松地找到允许他们破解或解密 iPhone 的漏洞和 bug。也许，这种泄漏最终可能会让高级程序员在非苹果平台上模拟 iOS。</p>
<p>以前版本的 iBoot 中的漏洞使得破解者和黑客可以通过 iPhone 的锁屏解密用户的数据。但是新的 iPhone 有一个名为 Secure Enclave Processor 的芯片，它加强了设备的安全性。</p>
<p>Levin 补充说道，对于普通用户来说，这意味越狱会更加容易。这些越狱过去相对容易实现，并且很普遍，但是现在使用最新的 iOS 设备是非常困难的，这些设备具有先进的安全机制，即使是高技能的研究人员也很难找到 bug，因为他们需要在开始探测设备之前，得先让设备越狱。</p>
<p>这些安全改进已经有效地将曾经流行的越狱社区扼杀在摇篮中。现在，在 iOS 中查找 bug 和漏洞是需要大量时间和资源的，因此产生的漏洞非常有价值。这就是为什么越狱社区会为源代码的泄露或任何公开发布的漏洞而感到兴奋。</p>
<p>这个源代码在去年首次出现，由 Jailbreak subreddit 上的一个名为“ apple_internals ” 的 Reddit 用户发布。这个帖子没有得到太多的关注，因为用户是新的，而且没有足够的 Reddit karma； 这个帖子很快沉下去了。但它在 GitHub 上再次出现意味着它可能在地下越狱社区和 iOS 黑客圈中广泛流传。</p>
<p>Levin 说：“iBoot 是苹果一直坚持的一个组件，他们仍然在加密它的 64 位代码。而现在，它却以源代码形式开放了。”</p>
<p>该文章的英文链接为：<br><a href="https://motherboard.vice.com/en_us/article/a34g9j/iphone-source-code-iboot-ios-leak" target="_blank" rel="external">https://motherboard.vice.com/en_us/article/a34g9j/iphone-source-code-iboot-ios-leak</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天（2月7日），有匿名开发者在 GitHub 上传了 iOS 核心组件的源代码，这可能会促进黑客和安全研究人员找到 iOS 漏洞，并使 iPhone 陷入危险境地。git地址：&lt;a href=&quot;https://github.com/h1x0rz3r0/iBoot。&quot; ta
    
    </summary>
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>区块链游戏大全</title>
    <link href="http://www.xiangzhihong.com/2018/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B8%B8%E6%88%8F%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.xiangzhihong.com/2018/02/01/区块链游戏大全/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-11T03:31:20.671Z</updated>
    
    <content type="html"><![CDATA[<p>“数字货币”和”区块链技术”这两个关键词在互联网平台炒的火热，多数网友在完全不懂金融学和交易技术的情况下，竟全程无障碍地参与了这场”货币大战”，可以说，区块链游戏是继比特币和以太坊技术之后，区块链的有一大实战应用。2017年底到2018年初，数十家互联网公司和竞相推出各类区块链游戏，抢占市场先机，这些新型的区块链游戏有哪些？<br><img src="http://img.blog.csdn.net/20180208135118442" alt="这里写图片描述"></p>
<p>从目前区块链技术的发展形势来看，这类新型游戏非常具备颠覆传统交易方式和投资方式的潜力，但并不是每一个项目都能获得成功。区块链技术到底是什么？为什么具有如此大的魔力？简而言之，区块链技术其实是数字货币的底层技术，是实现”去中心化”的安全交易方式，所谓”去中心化”是指去掉第三方交易平台的权威性，采用全民记账、公开透明的方式形成交易区块，这样的概念传递到游戏行业，便形成了全新的”区块链游戏”形式。</p>
<h2 id="1，百度莱茨狗"><a href="#1，百度莱茨狗" class="headerlink" title="1，百度莱茨狗"></a>1，百度莱茨狗</h2><p><img src="http://img.blog.csdn.net/20180208140521750" alt="这里写图片描述"><br>百度区块链实验室，拥有的企业级区块链解决方案，以及面向用户的应用级区块链解决方案。该实验室深入底层技术、平台化、区块链应用以及前瞻性领域研究，目前的技术已应用于多条核心业务线，支撑了超500亿元资产的真实性问题。同时，该实验室也是Hyperledger的核心董事会成员，致力于提升区块链行业的技术发展，推动全球区块链技术规范和标准的建立。</p>
<h2 id="2，以太猫"><a href="#2，以太猫" class="headerlink" title="2，以太猫"></a>2，以太猫</h2><p><img src="http://img.blog.csdn.net/20180208140434404" alt="这里写图片描述"><br>《Crypto Kitties》是全球最火的区块链游戏之一，也是最早的区块链游戏，于去年11月上线。以网页为载体，游戏特色是利用区块链技术生成基因不同的猫咪，玩家购买猫咪后可交配养育新的小奶猫，每只猫对应着真实的市场价值，运气好的玩家得到稀有特征的小猫能够大赚一笔，目前第一代猫咪市场价格已高达7000多美元，最贵的电子猫市场标价340万美元。这款游戏将”收藏小猫”这种概念转换为新型投资方式，成千上万的用户加入这场货币大战后，电子猫对应的市场价值越来越高，本作的成功为区块链宠物养成类游戏奠定了基调。</p>
<h2 id="3，网易招财猫"><a href="#3，网易招财猫" class="headerlink" title="3，网易招财猫"></a>3，网易招财猫</h2><p><img src="http://img.blog.csdn.net/20180208141117448" alt="这里写图片描述"><br>受《Crypto Kitties》启发，网易开发了这款”云养猫”游戏，目前还处于十分神秘的内测阶段，游戏中预售的猫咪仅限网易娱乐的员工购买，首轮投放1500只，每只售价1000金币，按照10金币等于1元人民币的规则，玩家购买一只初始猫咪需要花费100元，可通过网易、支付宝、微信、QQ等方式支付。这款游戏能不能掀起国内云养猫的热潮，将”区块链游戏玩法”普及开来，还要看上线之后的表现，目前大多数玩家持观望态度，当然，也有不少”投资狂魔”跃跃欲试，毕竟，花100元买到初始猫，如果游戏火了，岂不是赚翻。</p>
<h2 id="4，宝利马"><a href="#4，宝利马" class="headerlink" title="4，宝利马"></a>4，宝利马</h2><p><img src="http://img.blog.csdn.net/20180208141202404" alt="这里写图片描述"></p>
<p>目前大多数区块链游戏都采用”云养宠物”的形式，壕鑫互联借这样的理念打造了一款宠物养成社区游戏，名叫《宝利马》，与”充值购买宠物”式玩法不同，《宝利马》玩家是通过共享资源获取宝利马积分，以此购买区块链技术生成的基因各异的宠物马。宝利马积分用处也不局限于此，用户积累积分后可用于免费体验各类游戏、游戏道具、加速服务、高清直播等服务。</p>
<p>##5，加密狗<br><img src="http://img.blog.csdn.net/20180208141258987" alt="这里写图片描述"><br>《加密狗》基于区块链平台Achain开发，模拟数字货币交易，用区块链生成的宠物狗吸引用户购买，通过收藏、交配和售出的游戏形式为普通群众”科普”典型的区块链玩法。虽然是模仿《加密猫》的游戏，因”新游更具市场潜力”这一特点，《加密狗》上线一周时间项目营收已突破500万美元。</p>
<h2 id="6，玩客猴"><a href="#6，玩客猴" class="headerlink" title="6，玩客猴"></a>6，玩客猴</h2><p><img src="http://img.blog.csdn.net/20180208141800880" alt="这里写图片描述"><br>基于区块链自动生成技术开发的”养猴游戏”于2017年12月27日上线，这是纯中国特色的区块链玩法游戏，因为流通货币是万客日记自家的链克币。玩家绑定链克钱包地址后可购买小猴子，养育需要支付一定费用，但成熟后的小猴市场价值更高，最终的交易价格会参考小猴品质、人工饲养费总额等。另外，小猴生育后玩家获取的小小猴可继续养育和出售喔~</p>
<p>##7，fair.game<br><img src="http://img.blog.csdn.net/20180208141936394" alt="这里写图片描述"><br>fair.game是基于以太坊智能合约的游戏平台，与”养猫养狗养马养鱼”的宠物养成类游戏不同，这款游戏平台上线的游戏类型多数偏”赌博化”，赌博形式和支付方式采用区块链技术理念，更加安全和公正，目前平台支持老虎机、德州扑克等游戏。</p>
<p>##8，宠物星球<br><img src="http://img.blog.csdn.net/20180208142146494" alt="这里写图片描述"><br>各大厂商都在做区块链宠物，但大多局限于”某一种”生物，GAME网团队另出新意，直接做了一家区块链宠物店，这里的宠物应有尽有，花样十足。《宠物星球》基于波场TRON区块链技术开发，用户购买的宠物和其他数字资产永久保存在个人名下，单个宠物基础售价：200波场比TRON。</p>
<p>##9，以太小怪兽<br><img src="http://img.blog.csdn.net/20180208142258287" alt="这里写图片描述"><br>以太坊全新的区块链游戏玩法，游戏模式类似《口袋妖怪》，玩家在Etheremon的世界中通过花费以太币一定概率抓取怪兽，各种形态的小怪兽们个性十足，外形呆萌可爱。除了养育玩法，玩家在游戏中可训练自家”宠物”与对手战斗。这款游戏一经推出风靡互联网平台，成千上万用户竞相涌入平台认购怪兽，直接导致以太坊网络拥堵，交易速度降低，该游戏主要集中在国外的一些玩家。</p>
<p>##10，区块企鹅<br><img src="http://img.blog.csdn.net/2018020814234944" alt="这里写图片描述"><br>基于《以太猫》的玩法，许多厂商开发出很多”云养宠物”的区块链游戏，日本某团队推出的《Cloudpenguins》也是同样的类型。《Cloudpenguins》游戏通用货币是CPC，采用传统的区块链宠物生成法则，每只企鹅都有独立的基因和个性，在此基础上，附加宠物蛋新玩法，玩家在进行企鹅繁殖时能够有一定几率得到宠物蛋，宠物蛋有可能孵化出更稀有的企鹅，这算是”意外淘金”的玩法。</p>
<p>区块链技术的透明、公正性颠覆了传统认知，革新了市场投资方向，电子宠物不再是一堆”Crtl C”+”Cryl V”的虚拟数据，通过区块链的操控方式，宠物们仿佛是真正”活了过来”，并在市场上拥有了真实价值。腾讯某高管曾经表示，游戏的最终目的是打破虚拟与现实之间的壁垒，如今这类游戏的繁盛，是否在一定程度上接近了”游戏真谛”呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“数字货币”和”区块链技术”这两个关键词在互联网平台炒的火热，多数网友在完全不懂金融学和交易技术的情况下，竟全程无障碍地参与了这场”货币大战”，可以说，区块链游戏是继比特币和以太坊技术之后，区块链的有一大实战应用。2017年底到2018年初，数十家互联网公司和竞相推出各类区
    
    </summary>
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Google发布Android KTX预览版</title>
    <link href="http://www.xiangzhihong.com/2018/01/29/Google%E5%8F%91%E5%B8%83Android%20KTX%E9%A2%84%E8%A7%88%E7%89%88/"/>
    <id>http://www.xiangzhihong.com/2018/01/29/Google发布Android KTX预览版/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-02-11T03:30:27.510Z</updated>
    
    <content type="html"><![CDATA[<p>前天，Google 发布了 <a href="https://github.com/android/android-ktx" target="_blank" rel="external">Android KTX</a> 预览版，Android KTX 是一组扩展程序，它能使 Android 上的 Kotlin 代码更简洁，从而提高开发者的编程体验。</p>
<p>大家知道，Google在2017年的Google I/O大会上将Kotlin列为第一开发语言之后，便不遗余力的支持Kotlin。Android KTX 中支持 Android 框架的部分现在可在 GitHub 库中找到，同时，Google 承诺在即将到来的支持库版本中提供涵盖 Android 支持库的 Android KTX 的其他部分。那么，相比于通用的Kotlin，Android KTX究竟做了哪些方面的优化呢，下面通过一些示例来简单对比下。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="字符串转换为-URI"><a href="#字符串转换为-URI" class="headerlink" title="字符串转换为 URI"></a>字符串转换为 URI</h3><p>通常情况下为 Uri.parse(uriString)，但是 Android KTX 会为字符串添加一个扩展函数，使字符串更加自然地转换为 URI。<br><img src="http://img.blog.csdn.net/20180207104354052" alt="这里写图片描述"></p>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>编辑 SharedPreferences 是非常常见的用例，使用 Android KTX 后，代码稍微短些，能更自然地读取和写入。<br><img src="http://img.blog.csdn.net/20180207104458907" alt="这里写图片描述"></p>
<h3 id="平移路径差异"><a href="#平移路径差异" class="headerlink" title="平移路径差异"></a>平移路径差异</h3><p>例如，下面是将两个路径之间的距离改变了 100px。<br><img src="http://img.blog.csdn.net/20180207104619428" alt="这里写图片描述"></p>
<h3 id="在视图onPreDraw-的动作"><a href="#在视图onPreDraw-的动作" class="headerlink" title="在视图onPreDraw 的动作"></a>在视图onPreDraw 的动作</h3><p>下面的示例触发了视图中 onPreDraw 的回调，如果没有 Android KTX，你需要编写相当多的代码。<br><img src="http://img.blog.csdn.net/20180207104930125" alt="这里写图片描述"></p>
<p>除了上面介绍的一些API之外，还有很多其他的特性，详细的介绍读者可以访问Android KTX开源地址：<a href="https://github.com/android/android-ktx。" target="_blank" rel="external">https://github.com/android/android-ktx。</a></p>
<h1 id="Android集成"><a href="#Android集成" class="headerlink" title="Android集成"></a>Android集成</h1><p>要在你的 Android Kotlin 项目中开始使用 Android KTX，需要在应用模块 build.gradle的脚本文件中添加以下配置脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    google()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation &apos;androidx.core:core-ktx:0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在同步项目之后，这些扩展将自动出现在 IDE 的自动完成列表中，选择扩展程序会将必要的导入语句添加到你的文件中。</p>
<p><strong>注意</strong>：不过需要注意的是，Android KTX目前还是一个预览版本，预览期间 API 可能会发生变化，也就是说，在正式版到来之前，不要在重要的 Android 项目中使用它，因为正式版可能会发生一些变化。</p>
<h1 id="Android-KTX未来发展趋势"><a href="#Android-KTX未来发展趋势" class="headerlink" title="Android KTX未来发展趋势"></a>Android KTX未来发展趋势</h1><p>Google 表示，现在的预览版本是一个开始，在接下来的几个月里，他们会根据开发者的反馈和贡献加入 API 进行迭代，当 API 稳定后，Google 会承诺 API 的兼容性，并计划将 Android KTX 作为 Android 支持库的一部分。</p>
<p>1，可以通过如下地址来提交相关的建议和修改意见：<br><a href="https://github.com/android/android-ktx/issues/new" target="_blank" rel="external">https://github.com/android/android-ktx/issues/new</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天，Google 发布了 &lt;a href=&quot;https://github.com/android/android-ktx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android KTX&lt;/a&gt; 预览版，Android KTX 是一组扩展程序，它能使
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenCV的跳一跳外挂实现原理</title>
    <link href="http://www.xiangzhihong.com/2017/12/27/%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.xiangzhihong.com/2017/12/27/基于OpenCV的跳一跳外挂实现原理/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:17:06.972Z</updated>
    
    <content type="html"><![CDATA[<p>最近，微信跳一跳小游戏迅速走红并且在朋友圈刷屏，游戏的规则很简单，就是控制一个小矮子再各个墩子上跳来跳去。由于游戏比较简单，一时间大家都玩起来了，这也带动了一些作弊的产生。Android和iOS的小程序都可以刷分，如果想要刷分，可以参考下面这个开源项目：<a href="https://zhuanlan.zhihu.com/p/32452473" target="_blank" rel="external">Python刷分</a>。<br><img src="http://img.blog.csdn.net/20180123152801301" alt="这里写图片描述"><br>今天要给大家讲的是如何使用OpenCV来给Android小程序刷分。<br>其实，刷分的思路都是一致的：通过Android手机的ADB来截取屏幕，然后通过对截图进行分析，算出来玩家与下一个落脚点的距离，然后通过距离算出来需要按压多长时间的屏幕，之后再通过发送ADB指令来模拟按下屏幕达到自动刷分的目的。也就是说，这个外挂的核心就是取得玩家与下一个落脚点的距离，有了距离之后，一切都好说了。</p>
<h2 id="OpenCV简介"><a href="#OpenCV简介" class="headerlink" title="OpenCV简介"></a>OpenCV简介</h2><p>OpenCV熟悉编程的人一定知道，是一个著名的开源计算机视觉库，实现了图像处理和计算机视觉方面的很多通用算法。要想在Python上运行OpenCV只需要使用pip安装就好，在Terminal中执行pip install opencv-python即可。OpenCV的官网地址为：<a href="https://opencv.org/。" target="_blank" rel="external">https://opencv.org/。</a></p>
<p>使用OpenCV时一般是用于分析图片灰度图，因为我这里需要画框划线进行标记，所以为了方便就直接读RGB彩图了，这样因为一个像素三个通道所以会慢一点，之后投入使用直接分析灰度图就好。</p>
<p>##实践</p>
<p>下面就来看看如何使用OpenCV来完成Android的跳一跳如何刷分吧。</p>
<h3 id="1，玩家位置识别"><a href="#1，玩家位置识别" class="headerlink" title="1，玩家位置识别"></a>1，玩家位置识别</h3><p>首先需要做的就是识别玩家的位置，玩家的形状不变，是一个紫色的棋子，那么可以使用OpenCV带有的图像模板匹配来找出玩家的位置。首先来一个图片，如下：<br><img src="http://img.blog.csdn.net/20180123154748138" alt="这里写图片描述"></p>
<p>然后就可以使用Python读取了，对于游戏场景，我们使用下图为例，名字为1.png。<br><img src="http://img.blog.csdn.net/20180123155005836" alt="这里写图片描述"></p>
<h4 id="1-1图像模板匹配"><a href="#1-1图像模板匹配" class="headerlink" title="1.1图像模板匹配"></a>1.1图像模板匹配</h4><p>在OpenCV中调用matchTemplate函数即可实现模板匹配。<br><img src="http://img.blog.csdn.net/20180123155356228" alt="这里写图片描述"></p>
<p>相关的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import cv2 as cv</div><div class="line"></div><div class="line">img = cv.imread(&quot;1.png&quot;)</div><div class="line">player_template = cv.imread(&apos;player.png&apos;)</div><div class="line">player = cv.matchTemplate(img, player_template, cv.TM_CCOEFF_NORMED)</div><div class="line"></div><div class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(player)</div></pre></td></tr></table></figure>
<p>通过调用上面的代码即可进行模板匹配，最后一行的max_loc则是匹配出来的位置，因为玩家是一个宽度50高度150像素的图形（在我的iPhone 6s上）。所以再添加以下代码来框出玩家位置。并且画出了玩家的点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">corner_loc = (max_loc[0] + 50, max_loc[1] + 150)</div><div class="line">player_spot = (max_loc[0] + 25, max_loc[1] + 150)</div><div class="line">cv.circle(img, player_spot, 10, (0, 255, 255), -1)</div><div class="line">cv.rectangle(img, max_loc, corner_loc, (0, 0, 255), 5)</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, img)</div><div class="line">cv.waitKey(0)</div></pre></td></tr></table></figure>
<p>之后再运行，这时会打开一张片，可以看见玩家的位置已经被识别出来了。<br><img src="http://img.blog.csdn.net/20180123162715531" alt="这里写图片描述"></p>
<h3 id="2，落脚点识别"><a href="#2，落脚点识别" class="headerlink" title="2，落脚点识别"></a>2，落脚点识别</h3><p>接下来就要识别落脚点了，但是蹲蹲千变万化，有方形的，有圆形的。所以刚才的模板识别就用不上了，即使使用的话成功率也很低，这个时候就需要用到边缘检测了。</p>
<p>####2.1 Canny边缘检测<br>OpenCV带有Canny算法的实现来帮助我们得到图形的边缘。在做边缘检测之前首先需要对图片进行高斯模糊处理，高斯模糊主要作用就是去除噪声。因为噪声也集中于高频信号，很容易被识别为边缘。高斯模糊可以降低伪边缘的识别。但是由于图像边缘信息也是高频信号，高斯模糊的半径选择很重要，过大的半径很容易让一些弱边缘检测不到。<br><img src="http://img.blog.csdn.net/20180123162913607" alt="这里写图片描述"></p>
<p>例如，下面是示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img_blur = cv.GaussianBlur(img, (5, 5), 0) #高斯模糊</div><div class="line">canny_img = cv.Canny(img_blur, 1, 10) #边缘检测</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, canny_img)</div></pre></td></tr></table></figure>
<p>然后图片就会被边缘识别，这个图是灰度图，每一个像素是 0-255之间任意一个值，黑色为0白色为255。<br><img src="http://img.blog.csdn.net/20180123163350644" alt="这里写图片描述"></p>
<h4 id="2-2图片切片"><a href="#2-2图片切片" class="headerlink" title="2.2图片切片"></a>2.2图片切片</h4><p>其实现在我们已经可以开始分析边缘来找到下一个落脚点了，但是图片中边缘实在是太多，可以通过裁切图片来，首先要知道，下一个落脚点肯定是在整个界面的上1/2。也就是说，图片的下半段可以不要，而且，上面的记分牌也没有任何用处。<br><img src="http://img.blog.csdn.net/20180123163717547" alt="这里写图片描述"></p>
<p>执行以下代码来切除上面的300像素的高度加下半部分图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">height, width = canny_img.shape</div><div class="line">crop_img = canny_img[300:int(height/2), 0:width]</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, crop_img)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180123163905648" alt="这里写图片描述"></p>
<h4 id="2-3消除玩家图片"><a href="#2-3消除玩家图片" class="headerlink" title="2.3消除玩家图片"></a>2.3消除玩家图片</h4><p>但是有一点还是很烦，上图的左下角还有一部分玩家的头部，有时候如果玩家需要向左上角跳，这个头的存在可能会造成一定的干扰，所以需要写代码消除它，因为我们已经知道了玩家的坐标了，所以把那个范围的像素全设成0就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for y in range(max_loc[1], max_loc[1]+150):</div><div class="line">    for x in range(max_loc[0], max_loc[0]+50):</div><div class="line">        canny_img[y][x] = 0</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180123164101930" alt="这里写图片描述"></p>
<h4 id="2-4落脚点判断"><a href="#2-4落脚点判断" class="headerlink" title="2.4落脚点判断"></a>2.4落脚点判断</h4><p>现在只剩下敦敦的边缘了，现在需要得到他的中心点，仔细观察这个图形，发现他是一个菱形，并且有两个点是很容易通过遍历像素点然后分析得到的。<br><img src="http://img.blog.csdn.net/20180123164220374" alt="这里写图片描述"></p>
<p>A点B点是很容易得到的，通过由上到下，由左到右遍历全部像素，A点应该是便利顺序的像素中第一个值为255的点，B点是便利顺序中第一次横坐标最大的点。得到了A,B点的坐标，整个形状的中点 （X3， Y3）其实就是 （X1，Y2）。</p>
<p>可以通过如下代码来判断中心点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">crop_h, crop_w = crop_img.shape</div><div class="line">center_x, center_y = 0, 0</div><div class="line"></div><div class="line">max_x = 0</div><div class="line"></div><div class="line">for y in range(crop_h):</div><div class="line">    for x in range(crop_w):</div><div class="line">        if crop_img[y, x] == 255:</div><div class="line">            if center_x == 0:</div><div class="line">                center_x = x</div><div class="line">            if x &gt; max_x:</div><div class="line">                center_y = y</div><div class="line">                max_x = x</div><div class="line">                </div><div class="line">cv.circle(crop_img, (center_x, center_y), 10, 255, -1)</div><div class="line"></div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, crop_img)</div><div class="line">cv.waitKey(0)</div></pre></td></tr></table></figure>
<p>执行上面的代码，发现程序已经标出了中心点：<br><img src="http://img.blog.csdn.net/20180123164609536" alt="这里写图片描述"></p>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>好了，看一下运行的效果吧。<br><img src="http://img.blog.csdn.net/20180123164746270" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180123164822533" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180123164909107" alt="这里写图片描述"><br>相关源码链接如下：<a href="http://download.csdn.net/download/xiangzhihong8/10220160" target="_blank" rel="external">http://download.csdn.net/download/xiangzhihong8/10220160</a></p>
<p>其实，细心的读者可以发现，图片的中心并非处于绝对的中心位置，大家可以在源码的基础上修改参数的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，微信跳一跳小游戏迅速走红并且在朋友圈刷屏，游戏的规则很简单，就是控制一个小矮子再各个墩子上跳来跳去。由于游戏比较简单，一时间大家都玩起来了，这也带动了一些作弊的产生。Android和iOS的小程序都可以刷分，如果想要刷分，可以参考下面这个开源项目：&lt;a href=&quot;h
    
    </summary>
    
      <category term="Python" scheme="http://www.xiangzhihong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xiangzhihong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2017移动开发年终盘点</title>
    <link href="http://www.xiangzhihong.com/2017/12/27/2017%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B9%B4%E7%BB%88%E7%9B%98%E7%82%B9/"/>
    <id>http://www.xiangzhihong.com/2017/12/27/2017移动开发年终盘点/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:20:46.611Z</updated>
    
    <content type="html"><![CDATA[<p>2017年已经过了大半个月，2017年移动端经历了哪些大事件呢，现在总结如下。</p>
<h1 id="Android-技术动态"><a href="#Android-技术动态" class="headerlink" title="Android 技术动态"></a>Android 技术动态</h1><p>在今年 Google I/O 大会上，谷歌 CEO Sundar Pichai 宣布谷歌的正在从“移动为首位”转变为“AI 高于一切”，所以与往年的开发者大会相比，今年会议的大部分内容都围绕 AI 展开，如 Google 将开放 Tensor Flow、TPU 等软硬件工具给开发者，还发布了一系列人工智能产品如：Google Lens、Google Asistant、Google Home 等，并提出了 Google.ai 计划，相比之下，Android 的内容就少了很多，这也意味着谷歌正在 Android 的基础上逐渐构建自己的人工智能生态系统。在本次大会上，谷歌宣布 Android 的活跃设备数达到了 20 亿，这意味着 Android 系统已成移动行业的霸主。</p>
<h2 id="1-Android-8-0-发布"><a href="#1-Android-8-0-发布" class="headerlink" title="1. Android 8.0 发布"></a>1. Android 8.0 发布</h2><p>今年最受 Android 开发者期待的莫过于 Android 8.0 了，在经过 4 个开发者预览版的洗礼后，北京时间 8 月 22 日谷歌发布了 Android 8.0 的正式版，取名 Android Oreo（奥利奥），简称 Android O，“奥利奥”的名字沿袭了谷歌以甜品取名操作系统的传统。相对上一代版本，Android 8.0 的功能、流畅性和安全性都有了很大地提升，主要表现在以下几个方面：<br><img src="http://img.blog.csdn.net/20180117174856189" alt="这里写图片描述"></p>
<p>   <strong>功能：</strong></p>
<ul>
<li>画中画：支持将手机的电影屏幕缩小成悬浮窗口，在看电影的同时可进行其他应用程序的操作；</li>
<li>Notification Dots：App 在接收通知后，将在图标的右上角生成一个圆形的小点，长安圆点即可显示该 App最近通知，滑动即可清除，无需经过通知栏；</li>
<li>即时应用：这个与微信小程序类似，App 无需安装也可通过点击网址打开 App，不过前提是访问的这个 App 支持这个功能，由于Android Instant Apps 是基于 Google Play 服务构建的，所以国内的 Android 用户暂时无法享用此功能；</li>
<li><p>智能文字选取：能检测出选取的文字是地址还是电话号码，并会根据选取的文字类型打开对应的应用，如地图或拨号功能。</p>
<p><strong>流畅性</strong>：<br>据谷歌透露，Pixel 在 Android 8.0 下的开机速度比上一代系统快了 2 倍；而且针对各种流氓 App 采取严格的控制，不常用的 App 会被强制停止，节省手机耗电量和提高手机流畅性；</p>
<p><strong>安全性：</strong><br>谷歌在 Android 8.0 中内置了 Play Protect 服务，能够自动扫描手机中潜在的恶意 App。</p>
</li>
</ul>
<h2 id="2-Android-studio-3-0-发布"><a href="#2-Android-studio-3-0-发布" class="headerlink" title="2. Android studio 3.0 发布"></a>2. Android studio 3.0 发布</h2><p>10 月 25 日，Android Studio 3.0 正式版发布，此版本将支持 Kotlin 编程语言、支持 Java 8 语言功能、支持 XML 字体预览、支持 Instant App、支持配置和调试 APK 等。其中，开发人员不再需要通过 Android Studio 的插件就可直接在 Android Studio 3.0 中使用 Kotlin，包括重构、自动完成、lint、调试等操作。</p>
<p>##3. ARCore 发布<br>8 月 29 日，Google 了发布构建 AR 应用平台 ARCore，这个项目被看做是 Google 与苹果在 AR 领域上的较量，因为苹果 6 月也推出了 AR 框架 -ARKit，所以 ARKit 也被认定为 ARCore 的对标。而在此之前，谷歌也曾研发过一个 AR 平台 Tango，但由于 Tango 对硬件设备有限制，各方面的性能也比不上 ARCore。在今年 12 月 15 日，谷歌宣布将从 2018 年 3 月 1 日起停止对旗下 AR 平台 Tango 的支持，以后将专注于 ARCore 平台的研究，在 AR 上大展拳脚，不知道将来在 AR 领域的 ARCore 与 ARKit 会不会像现在的 Android 和 iOS 一样各占半壁江山，让我们拭目以待吧。</p>
<h2 id="4-Kotlin-成为-Android-开发一级编程语言"><a href="#4-Kotlin-成为-Android-开发一级编程语言" class="headerlink" title="4. Kotlin 成为 Android 开发一级编程语言"></a>4. Kotlin 成为 Android 开发一级编程语言</h2><p>由于 Kotlin 比 Java 更安全——能够静态检测常见的缺陷、更简洁，而且能兼容 Java 等优点，使它能够短短几年在众多竞争中脱颖而出，成为开发者们的香饽饽。尤其是在今年的 Google 在大会上，谷歌宣布 Kotlin 成为 Android 开发的一级编程语言后，江湖上就开始流传 Java 将被 Kotlin 取代的说法，各大论坛的 Java 与 Kotlin 大战由此展开，各类站队的文章也层出不穷，好不热闹。</p>
<p>11 月初，第一届 Kotlin 的专题会议 KotlinConf 在旧金山开幕，会议上 Kotlin 首席设计师 Andrey Breslav 宣布 Kotlin 将要支持 iOS 和 Web 开发，这也被称做 kotlin 与 Swift 在支持全栈开发上的较量，此消息一出，引发了不少开发者的热议，有开发者表示，kotlin 要想拿下 iOS 估计不是那么容易的事情，毕竟苹果对自己的生态有严格的把控，苹果是不会轻易地给 Swift 的竞争对手机会的，也有人认为 Kotlin 应该先把 Android 的坑填完再去扩张，跨步太大容易摔跤。</p>
<p>但是，不管将来 Kotlin 将来能否统一江湖，但是从目前来看，Kotlin 有了谷歌这座靠山，它的前景还是值得期待的！</p>
<h2 id="5-国内安卓统一推送联盟成立"><a href="#5-国内安卓统一推送联盟成立" class="headerlink" title="5. 国内安卓统一推送联盟成立"></a>5. 国内安卓统一推送联盟成立</h2><p>2017 年 10 月 16 日，安卓统一推送联盟大会在京举办，此次大会由中国工信部旗下的中国信息通信研究院泰尔终端实验室主办，多个互联网企业和手机制造企业出席，并宣布百度、阿里、腾讯、华为、小米、OPPO、vivo、个推为联盟的副理事长单位。</p>
<p>“安卓统一推送联盟”的正式成立标志着安卓手机 App 自启和应用间相互唤醒的毛病将得到改善，国内安卓生态的混乱状态将得到有效解决。未来，安卓手机推送消息时，不必唤醒手机应用，从而保证 App 在未被使用时处于休眠状态，节省手机的内存和电量，安卓用户的体验将更加贴近 iOS。</p>
<h1 id="iOS-技术动态"><a href="#iOS-技术动态" class="headerlink" title="iOS 技术动态"></a>iOS 技术动态</h1><p>苹果 WWDC2017 大会何于 6 月 6 日在圣何塞 McEnery 会议中心召开，苹果发布了四大系统 WatchOS 4、macOS High Sierra、tvOS、iOS 11 的更新，每个系统相较上一个版本都有很大的提升。</p>
<h2 id="1-iOS-11-发布"><a href="#1-iOS-11-发布" class="headerlink" title="1. iOS 11 发布"></a>1. iOS 11 发布</h2><p>iOS 11 于 9 月 13 日凌晨正式发布，9 月 20 日全球正式开放下载，iOS 11 相对上一个版本主要有以下更新：</p>
<ul>
<li>iMessage: 新的 iMessage 集成了 iCloud 功能，所有的信息都能通过 iCloud同步，可删除本地信息，仅存于云端，优化手机本地内存；</li>
<li>Apple Pay: 支持点对点支付，可直接给对方付款，就像微信支付一样方便；</li>
<li>Siri：Siri 的发音将更加自然，并加入了男声，Siri 在 iOS 11中已经内置翻译功能，可以将英语翻译成汉语、法语、德语、意大利语以及西班牙语。除了语音之外，在 iOS 11 系统中，用户还可以通过打字跟 Siri 进行沟通；</li>
<li>支持 AR：在 iOS 11 中，还有一个令人期待的功能 AR，iOS 11 带来了 ARKit，这是苹果全新的 AR应用平台，开发者可以使用内置的摄像机、传感器和处理器在 iOS 设备上开发 AR 体验的应用。</li>
</ul>
<p>此次除了功能上的更新外，根据苹果最新的规定，从 2018 年 1 月 1 日起，iOS 11 将全面停止 32 位应用程序，意味着从 2018 年开始，升级 iOS 11 正式版的系统后，目前 App Store 里的 18.7 万款 32 位的应用将无法搜到或无法打开，而对消费者而言，iPhone 5 和其他仅支持 32 位系统苹果手机将会面临淘汰。</p>
<p>其实早在今年 6 月份，苹果就开始透露了这个消息，而在更早的 2015 年，苹果就向开发者传递了 64 位应用的优势，也暗示着让开发者开发 64 位的应用程序来适配 iPhone 5s 之后的新系统，所以就目前来讲，很多应用基本上都已经有了 64 位的版本，很多仍停留在 32 位的大多都是比较冷门的应用，对用户来说也不是必备的，所以总的来说，影响不会太大。</p>
<h2 id="2-Swift-4-0-发布"><a href="#2-Swift-4-0-发布" class="headerlink" title="2. Swift 4.0 发布"></a>2. Swift 4.0 发布</h2><p>Swift 4.0 在 2017 年 9 月 19 日正式发布，最新的版本主要针对语言本身以及标准库的大量改动和更新，最重要的变化包括新增的 String 功能、扩展集合、归档和序列化等。关于Swift 4.0的相关知识，可以查看如下的链接：<a href="http://swift4.cc/" target="_blank" rel="external">Swift 4.0中文版</a></p>
<p>##3. 苹果“热修复”门事件<br>今年苹果在移动法规上最大的新闻估计就是“热修复”门事件了，今年三月，苹果向所有开发者推送警告邮件，宣布将禁用 App 内部的“动态分发”功能，并要求开发者在自家 App 中删除 JSPatch、Rollout 等相关框架，否则 App 将面临下架或禁止在 App Store 上架。</p>
<p>这一动作，意味着苹果对“热更新”判了死刑，对用户而言，未来更新应用都需重新下载完整的新版数据包。对国外的开发者影响不大，因为国外的开发流程很规范，再者，国外的 Google Play 也一直是禁止热修复的， 基本不会用热修复进行迭代，基本都是一次性交付。</p>
<p>但对国内的开发者而言，这却是致命的打击，由于之前的“热修复”可以直接通过服务器推送并进行下载迭代，可以避开苹果的“二次审核”，App 就能早日上线盈利，但从今以后，这样的“福利”再也没有了。</p>
<p>从根本上来说，还是因为“热更新”破坏了 iOS 生态的“安全性”与“可控性”，这对苹果来说，是无法容忍的。</p>
<h1 id="移动开发热门话题-TOP5"><a href="#移动开发热门话题-TOP5" class="headerlink" title="移动开发热门话题 TOP5"></a>移动开发热门话题 TOP5</h1><p>2017年移动最热门的话题莫过于：移动 AI、性能优化、移动架构、Kotlin、AR/VR。</p>
<p> <strong>移动 AI</strong><br>今年毫无疑问是 AI 年，各种其它领域都羡慕嫉妒恨的想跟 AI 扯上关系，移动也不例外。语音交互的成熟催生了 CUI，另外端上的 AI 也的确是一个趋势，因此有了很多与此相关的分享。</p>
<p>移动电商中的图像算法应用<br>用人工智能来高效测试 App<br>利用 CNN 实现无需联网的智能图像处理<br>对话式交互：从开端到成长<br>基于卷积神经网络在手机端实现文档检测<br>App 如何与 AI 共舞 —AI 为 App 开发赋能<br>深度学习在手机端的应用<br>移动端设备上的深度学习：Android 设备上 TensorFlow 应用与实现<br>安卓车载系统创新功能<br>轻量级 DNN 网络在 Android 上的视觉应用<br>人工智能技术及在移动端应用<br>足球游戏的 AI 实现<br>深度学习在移动端的应用<br>使用 TensorFlow 搭建智能开发系统，自动生成 App UI 代码<br>移动端全机型传感器的自适应计步算法设计</p>
<p> <strong>性能分析与优化：</strong><br>性能优化在移动开发中是一个长盛不衰的话题，移动架构一复杂起来，必然出现性能瓶颈，这时就要去做分析和优化。而在性能分析这一块，APM 越来越受到重视，不少公司都自建了 APM 系统。</p>
<p>iOS App 内存专项实践：封闭系统下的大自由<br>手淘 iOS 性能优化探索<br>Android 系统开机时间优化<br>优化 Android 应用程序的桌面体验<br>360 手机卫士性能提升攻略<br>移动端性能监控方案 Hertz<br>从无到有实现一个性能监控平台是怎样一种体验？<br>移动网络性能优化<br>Android 启动优化 - 异步 dex 加载<br>滴滴出行 iOS 端瘦身实践</p>
<p> <strong>移动架构</strong><br>17 年以来，移动架构很少有大的革新，连 Rx 和函数式的分享都少了不少，感觉架构更加像是一个拓荒的工作，一旦稳定，事情就比较少了。不过架构还是很重要的，选错型的话只能流泪跪着走完了。</p>
<p>共享代码衍生多款应用的定制框架之经验分享<br>58 同城 Android 客户端 Walle 框架演进与实践之路<br>豌豆荚的反作弊技术架构与设计<br>美团点评移动端底层架构实践<br>Android DataBinding:MVVM 架构基石，数据驱动 APP 运转<br>美团客户端架构演进之路<br>Atlas: 手机淘宝 Android 架构实践<br>AOP 技术在 APP 架构上的应用<br>一个 5800 行文件的重构历程</p>
<p> <strong>Kotlin</strong><br>今年也是 Kotlin 年，在 Google IO 之后 Kotlin 着实风光了一把，开发者对于效率的追求是 Kotlin 如此受欢迎的最大原因，而它的势头也很不错，跨平台的野心让更多人有了使用它的理由，如今看起来，它甚至比 Swift 更有前途。</p>
<p>Kotlin from zero to how can it help me?<br>Kotlin 在 Android 开发中最佳实践探讨<br>开发效率的抉择：将 Kotlin 投入 Android 生产环境中<br>Kotlin 跨平台，还有 Native<br>从 Java 到 Kotlin，当机器人不再喝咖啡后<br>用 Kotlin 定制自己的 DSL<br>Android 开发从 Java 到 100% Kotlin 项目实战总结</p>
<p> <strong>AR/VR</strong><br>随着 AI 的落地和苹果谷歌的力推，AR 逐渐来到了我们的身边，最常见的就是各种美颜、直播 App 里的贴纸、表情、试妆等，都是 AR 的应用。AR 作为垂直领域已经值得投入了。</p>
<p>AR/VR 的未来技术趋势<br>Introduction to Google ARCore<br>移动互联网时代的 VR 技术之路<br>从 2D 到 3D，AR 发展中的关键技术<br>如何利用 CPU 计算能力实现更沉浸的 VR 体验<br>虚拟现实产业中 Android 的现状、未来和挑战</p>
<p>2017 年移动开发的公开分享明显减少了，原因这里不多说，对于移动开发者来说，真是听一个少一个，向每一个分享者致敬！</p>
<p>在新的一年里，移动开发前线仍会持续关注移动技术动态，也欢迎开发者继续关注移动开发前线。想知道过去一年国内代表性公司在移动开发上都做了哪些工作，以及 2018 年值得你关注的移动技术有哪些？请见下回分解~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年已经过了大半个月，2017年移动端经历了哪些大事件呢，现在总结如下。&lt;/p&gt;
&lt;h1 id=&quot;Android-技术动态&quot;&gt;&lt;a href=&quot;#Android-技术动态&quot; class=&quot;headerlink&quot; title=&quot;Android 技术动态&quot;&gt;&lt;/a&gt;And
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>号外，号外，《React Native移动开发实战》出版啦</title>
    <link href="http://www.xiangzhihong.com/2017/12/25/%E5%8F%B7%E5%A4%96%EF%BC%8C%E5%8F%B7%E5%A4%96%EF%BC%8C%E3%80%8AReact%20Native%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E5%87%BA%E7%89%88%E5%95%A6/"/>
    <id>http://www.xiangzhihong.com/2017/12/25/号外，号外，《React Native移动开发实战》出版啦/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-02-11T03:21:05.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对不起，我来晚了"><a href="#对不起，我来晚了" class="headerlink" title="对不起，我来晚了"></a>对不起，我来晚了</h1><p>首先要感谢支持和关注我的朋友，感谢人邮的赵老师，还有公司的领导和同事，他们在我写作的过程中给了很多有用的信息，也给了很多有用的建议，为本书的写作提供了很大帮助。感谢，再次感谢！！！</p>
<p>工作6年多以来，一直想写一本自己的书，一方面是对自己工作经历的一个总结，也是对希望写一本书给曾经的自己一个交代，毕竟30岁的人了，搞不了几年的技术了。</p>
<p>我一直有写博客的习惯，喜欢将自己工作和生活的点滴写成博客，分享给大家。说说我写书的缘由吧，最近几年，特别是15年和16年，我朋友圈的好友陆续出了自己的书，出于“跟风”吧，我也打算写一本，不过当时只是规划，没有具体实施。正好17年的1月份，一个人邮出版社的杨老师在csdn上给我留言，问我有没有兴趣写一本书，我问他写什么呢，他说要不就写React Native吧。说实话，那时候我对React Native并不是很熟悉，只是平时工作之余会学习相关的技术，在那之前，我一直从事的是Android和ios开发工作（搞了差不多6年了），虽然之前对React Native也有一定的了解，但深入还是不够的。于是前两个月我都写的很慢，一方面是公司的原因，一方面是对于写作没有很多的心理准备，17年的头两个月我勉强把样张写出来了，然后给出版社了，真正步入写作正轨的是4月份。新年刚过完，我把手头的工作分给了我的同事，手头事情不多，于是我加快了写作的步伐，一个月差不多能完成4章。</p>
<p>历时近6个月的写作，三个月的校验，千呼万唤始出来，第一本书终于出版了，虽然写作中经历了种种曲折，最终还是赶在11月份的出版了。<br><img src="http://img.blog.csdn.net/20171204201408112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在这里要给出版社和自己道歉，本来之前是打算在9月上线的，为的是赶上React Native开发的热潮，结果由于很多未知的原因，一拖再拖，让很多朋友都久等了。</p>
<h1 id="写书之前"><a href="#写书之前" class="headerlink" title="写书之前"></a>写书之前</h1><p>其实，写作之前我一直是拒绝的，写书不仅耗时，而且得到的回报也是不成比例的，搞开发的很多人都知道，写书不如去讲课，那钱比出书来的容易多了。写作之前，我还特意咨询了搞Android的邓平凡老师和搞iOS的关东升老师，也问了下以前携程的同事（16年除出了一本《React Native入门到实战》），不过16年初，React Native并没有真正的普及，也还是处于验证阶段，不过到17年初，很多的创业公司为了节约人力成本，都开始有了相关的开发岗位，并且工资也还不错，也就是这个时候，很多同学，特别是想要从事移动开发的前端同学，有些坐不住了。<br><img src="http://img.blog.csdn.net/20171204204013503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>确实，当我第一次使用React Native开发Android/ios应用的时候，<br>还真是有点小心动，没想到真的可以使用一套代码，解决多平台的需求。</p>
<p>在React Native诞生之前，人们一直在寻找一种可靠的跨平台技术开发方案，这里笔者将这些跨平台技术分为4类（本书的第一节有详细介绍）：</p>
<p>• Web流：也被称为Hybrid技术，它基于Web相关技术来实现界面及功能。<br>• 代码转换流：将某个语言转成Objective-C、Java或C#，然后使用不同平台下的官方<br>工具来开发。<br>• 编译流：将某个语言编译为二进制文件，生成动态库或打包成apk/ipa/xap文件。<br>• 虚拟机流：通过将某个语言的虚拟机移植到不同的平台上来运行。</p>
<h1 id="写作中"><a href="#写作中" class="headerlink" title="写作中"></a>写作中</h1><p>写书确实是一个漫长的过程，不仅漫长，而且枯燥。每天除了上班，就是在写书。第一次写书，好多东西往往是不可预知的，基本上是写到哪，发现有很多延伸的东西，然后又去查资料。</p>
<p>不过，经过一段时间的摸索，我大概确认了此书写作的大体思路，也就有了基本的目录结构，写作速度也逐渐加快。</p>
<p>结合自己的学习经历，再参考了现有书籍的基础之上，本书一共分为11章节，前面讲基础，后面讲项目，做到基础和实战项目相结合，并在适当的地方引入相关的理论，但是并不会深究，本书以入门到实战为主。</p>
<p><img src="http://img.blog.csdn.net/20171204203736315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171204203746999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171204203757243?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>样张可以到如下地址学习：<a href="http://www.epubit.com.cn/file/samplefile/203003060208078052250243067113220145121128058155" target="_blank" rel="external">http://www.epubit.com.cn/file/samplefile/203003060208078052250243067113220145121128058155</a></p>
<p>说说本书为什么叫《React Native移动开发实战》，和之前机械工业的袁林老师的书名字相同，主要是我5月底就已经确认了名字。<br><img src="http://img.blog.csdn.net/20171204204601513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>虽然书名一样，但是内容确大不相同，写作的思路也不一样。</p>
<p>#本书特色<br>本书全面详尽地介绍了 React Native 框架的方方面面，内容涵盖 React Native 基础知识、环境搭建与调试、开发基础、常用组件、常用 API、组件封装、网络与通信、混合开发、热更新与打包部署等章节知识。<br>本书语言简洁，内容丰富，写作思路简单，知识介绍上，逐层深入，并最终通过项目来总结学习成果 。学习时，需要读者具备有一定 Android、iOS 原生开发基础和 CSS 基础。</p>
<ol>
<li>本书各个章节之间逐层深入，如果你有一定的移动开发基础和css基础，可以选择性的阅读，否则，请从第一章开始阅读。</li>
<li>在知识的讲解上，本书尽量使用通俗易懂的讲解方式，不讲过多深入的理论和不常用的知识点，而是将这些深入的知识留给读者之后通过网络学习。</li>
<li>在基础组件和第三方库知识的讲解上，本书罗列了大量的示例，让读者可以轻松的看懂哪些基本的知识    这样就不会没有方向、摸不着头脑, 而是有目的性的去学习。</li>
<li>作为一线的移动开发者，笔者知道怎么学习对于初学者学习来说更好。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20171204205715813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>现在本书只能在异步社区预售，之后会分发到个出版商，本书预售地址：<a href="http://www.epubit.com.cn/book/details/7662#book-resources" target="_blank" rel="external">http://www.epubit.com.cn/book/details/7662#book-resources</a></p>
<h1 id="搞活动，送书了"><a href="#搞活动，送书了" class="headerlink" title="搞活动，送书了"></a>搞活动，送书了</h1><p>为了真正的给广大的读者谋福利，邮电出版社将联合云栖社区和csdn给大家举行送书活动，活动链接之后会发出来（请大家注意）。<br><img src="http://img.blog.csdn.net/20171204210256374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>另外，最近参加云栖的社区评选活动，还请各位帮忙投下票，投票有奖，投票链接：<br><a href="https://yq.aliyun.com/promotion/430?spm=5176.100238.spm-bestcontent.6.TXjRpR&amp;id=people8" target="_blank" rel="external">https://yq.aliyun.com/promotion/430?spm=5176.100238.spm-bestcontent.6.TXjRpR&amp;id=people8</a></p>
<p>重要！重要！重要！，请投17号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对不起，我来晚了&quot;&gt;&lt;a href=&quot;#对不起，我来晚了&quot; class=&quot;headerlink&quot; title=&quot;对不起，我来晚了&quot;&gt;&lt;/a&gt;对不起，我来晚了&lt;/h1&gt;&lt;p&gt;首先要感谢支持和关注我的朋友，感谢人邮的赵老师，还有公司的领导和同事，他们在我写作的过程中给
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiangzhihong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.xiangzhihong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>区块链常见共识算法总结</title>
    <link href="http://www.xiangzhihong.com/2017/12/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B8%B8%E8%A7%81%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xiangzhihong.com/2017/12/18/区块链常见共识算法总结/</id>
    <published>2017-12-17T16:00:00.000Z</published>
    <updated>2018-03-17T07:43:11.011Z</updated>
    
    <content type="html"><![CDATA[<p>这两年，区块链的技术可以说是非常的火爆，不了解点什么都不好说自己是在互联网混的，有人将区块链称之为互联网2.0，可以说区块链将对现有的互联网技术进行改造升级。那么，就让我们一起来了解下什么是区块链吧。</p>
<p>简单来讲，所谓区块链技术，也被称之为分布式账本技术，是一种互联网数据库技术，其特点是去中心化、公开透明，让每个人均可参与数据库记录。在区块链技术中有三个概念需要注意：</p>
<ul>
<li>交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录；</li>
<li>区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识；</li>
<li>链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。</li>
</ul>
<h1 id="区块链核心算法"><a href="#区块链核心算法" class="headerlink" title="区块链核心算法"></a>区块链核心算法</h1><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><p>拜占庭的故事大概是这么说的：拜占庭帝国拥有巨大的财富，周围10个邻邦垂诞已久，但拜占庭高墙耸立，固若金汤，没有一个单独的邻邦能够成功入侵。任何单个邻邦入侵的都会失败，同时也有可能自身被其他9个邻邦入侵。拜占庭帝国防御能力如此之强，至少要有十个邻邦中的一半以上同时进攻，才有可能攻破。然而，如果其中的一个或者几个邻邦本身答应好一起进攻，但实际过程出现背叛，那么入侵者可能都会被歼灭。于是每一方都小心行事，不敢轻易相信邻国。这就是拜占庭将军问题。</p>
<h3 id="拜占庭系统"><a href="#拜占庭系统" class="headerlink" title="拜占庭系统"></a>拜占庭系统</h3><p>将上面的问题衍生到计算机网络，指在一个拥有n台节点的系统，整个系统，对每个请求满足如下条件：</p>
<ul>
<li>所有非拜占庭节点使用相同的输入信息，产生同样的结果；</li>
<li>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。</li>
</ul>
<p>与此同时,在拜占庭系统的实际运行过程中一般假设系统中拜占庭节点不超过m台，并且对每个请求满足2个指标：</p>
<ul>
<li>安全性——任何已经完成的请求都不会被更改，它可以在以后请求看到；</li>
<li>活性——可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。</li>
</ul>
<h2 id="拜占庭系统的核心协议"><a href="#拜占庭系统的核心协议" class="headerlink" title="拜占庭系统的核心协议"></a>拜占庭系统的核心协议</h2><h3 id="1，一致性协议"><a href="#1，一致性协议" class="headerlink" title="1，一致性协议"></a>1，一致性协议</h3><p>一致性协议的目标是使来自客户端的请求在每个服务器上都按照一个确定的顺序执行。在协议中，一般有一个服务器被称作主节点，负责将客户端的请求排序；其余的服务器称作从节点，按照主节点提供的顺序执行请求。所有的服务器都在相同的配置信息下工作，这个配置信息称作view，每更换一次主节点，view就会随之变化。</p>
<p>一致性协议至少包含3个阶段：发送请求、序号分配和返回结果。根据协议设计的不同，可能包含相互交互、序号确认等阶段。</p>
<p>一致性协议解决一致性的方法主要有： </p>
<ul>
<li>服务器之间两两交互，服务器通过将自己获得的信息传递给其他的服务器；</li>
<li>由客户端收集服务器的信息，将收集的信息制作成证明文件再发送给服务器。对于一个包含3m+1台服务器的拜占庭系统，需要收集到2m+1台服务器发送的一致信息，才能保证达成一致的非拜占庭服务器数量大于拜占庭服务器数量。</li>
</ul>
<h3 id="2，检查点协议"><a href="#2，检查点协议" class="headerlink" title="2，检查点协议"></a>2，检查点协议</h3><p>拜占庭系统每执行一个请求，服务器需要记录日志。如果日志得不到及时的清理，就会导致系统资源被大量的日志所占用，影响系统性能及可用性。另一方面，由于拜占庭服务器的存在，一致性协议并不能保证每一台服务器都执行了相同的请求，所以，不同服务器状态可能不一致。例如，某些服务器可能由于网络延时导致从某个序号开始，之后的请求都没有执行。因此，拜占庭系统中设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态。因此，周期性的检查点协议可以定期地处理日志，节约资源，同时及时纠正服务器状态。</p>
<p>处理日志主要解决的问题就是区分那些日志可以清理，那些日志仍然需要保留。如果一个请求已经被m+1台非拜占庭服务器执行，并且某一服务器i能够向其他的服务器证明这一点，那么i就可以将关于这个请求的日志删除。目前，协议普遍采用的方式是服务器每执行一定数量的请求，就将自己的状态发送给所有服务器并且执行一个该协议，如果某台服务器接收到2m+1台服务器的状态，那么其中一致的部分就是至少有m+1非拜占庭服务器经历过的状态，因此，这部分的日志就可以删除，同时将自己状态更新只较新状态。</p>
<h3 id="3，视图更换"><a href="#3，视图更换" class="headerlink" title="3，视图更换"></a>3，视图更换</h3><p>在一致性协议里，已经知道主节点在整个系统中拥有序号分配，请求转发等核心能力，支配着这个系统的运行行为。然而一旦主节点自身发生错误，就可能导致从节点接收到具有相同序号的不同请求，或者同一个请求被分配多个序号等问题，这将直接导致请求不能被正确执行。视图更换协议的作用就是在主节点不能继续履行职责时，将其用一个从节点替换掉，并且保证已经被非拜占庭服务器执行的请求不会被篡改。</p>
<p>视图更换协议一般有两种触发方式：<br>1）只由服务器触发，这一类触发方式中，判断服务器一致性是否达成的工作是由服务器自身负责，客户端不能从请求的整个执行过程中获得服务器运行状况的信息；<br>2）客户端触发，这一类触发方式中，客户端一般负责判断服务器是否达成一致，如果不达成一致，那么就能判断服务器运行出现问题，如果是主节点的问题就会要求服务器更换主节点。</p>
<p>视图更换协议需要解决的问题是如何保证已经被非拜占庭服务器执行的请求不被更改。由于系统达成一致性之后至少有m+1台非拜占庭服务器执行了请求，所以目前采用的方法是：由新的主节点收集至少2m+1台服务器的状态信息，这些状态信息中一定包含所有执行过的请求；然后，新主节点将这些状态信息发送给所有的服务器，服务器按照相同的原则将在上一个主节点完成的请求同步一遍.同步之后,所有的节点都处于相同的状态,这时就可以开始执行新的请求。</p>
<p>由此，在一个分布式的系统中，尽管有坏人，坏人可以做任意事情（不受protocol限制），比如不响应、发送错误信息、对不同节点发送不同决定、不同错误节点联合起来干坏事等等。但是，只要大多数人是好人，就完全有可能去中心化地实现共识。</p>
<h2 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h2><p>PoW是英文Proof of Work的缩写，PoW 对节点提交的区块 B 的格式有如下的要求:<br>                     <strong>H(B)≤target</strong></p>
<p>其中 H 是某种 hash 算法, target 是一个固定的数. 也就是说整个区块的 hash 值要小于某个给定的数 target. 只有当区块满足这个条件时才是一个合法的区块, 这个区块才能够被别的节点接受. 而当某个节点找到了这样的合法的区块, 也就是挖到了矿, 会获得一定的数字货币奖励. 这也就解决了无中心多节点的结果决策问题: 整个网络采用最早找到合法区块的节点的数据.</p>
<p>哈希函数产生的 hash 值是随机的, 而且对原始数据一个很小的改动就能使得 hash 值和之前完全不一样. 为了能得到一个合法的区块, 我们可以往区块里添加一个冗余的整数 nonce, 通过不断地尝试不同的 nonce 来找到合法的区块 (例如可以从 1 开始不断地累加尝试).</p>
<p>target 的值每隔一段时间就会自动调整, 以保证产生区块的时间是基本固定的, 如比特币会保证每十分钟产生一个新的区块. 当 target 的值越小时, 产生区块的难度就越大. 假定 hash 值的最大值是 ：HASHmax , 则每一次尝试能找到合法区块的概率为：<br><img src="http://img.blog.csdn.net/2018030410521422" alt="这里写图片描述"><br> . 从这个公式可以看出 target 越小, 每次尝试能找到合法区块的概率也越小.</p>
<p>在比特币中每过 2016 个块 (两周) 便会调整一下 target 的值, 通过下面的公式进行调整:<br><img src="http://img.blog.csdn.net/20180304104740401" alt="这里写图片描述"><br>其中 t2016表示生成前面 2016 个块所花费的时间. 当花费的时间越短, 最终的 target 值也就越小. 生成块的难度值也可以通过下面的公式得出:<br><img src="http://img.blog.csdn.net/20180304104929725" alt="这里写图片描述"></p>
<p><strong>特点：</strong><br>采用POW算法的优点是，安全, 完全的去中心化, 主流的数字币都采用了这种方案; 如 BTC，LTC。缺点是，效率低, 平均每秒只能处理 5 到 7 个交易;<br>会耗费大量电力;</p>
<p>##PoS<br>PoS是Proof of Stake的缩写，在 PoW 中找到一个合法的区块需要进行大量的计算, 会花费大量的电力和时间. 为了加快生成区块的速度, PoS 中还会综合考虑节点所持有的数字币的份额. PoS 存在很多不同的实现方法, 其中一种混合模式会利用账户余额来调整挖矿难度:<br><img src="http://img.blog.csdn.net/20180304105709306" alt="这里写图片描述"></p>
<p>其中 balance 表示账户余额, t 是一个时间戳, 一般对 t 会有一个时间范围的限制, 例如一个小时, 也就是一个节点最多只能尝试 7200 次。</p>
<p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p>
<p>POS的优点是提高了处理效率; 基于 PoS 的 Ethereum 每秒大概能处理 30 笔交易左右。缺点是没有 PoW 安全, 容易遭受各种攻击。</p>
<h2 id="DPoS"><a href="#DPoS" class="headerlink" title="DPoS"></a>DPoS</h2><p>DPoS 会通过不同的策略在不同的时间通过投票产生一小群节点, 由这些节点来负责新区块的创建、验证和相互监督. DPoS 和 PoS 的主要区别在于前者会选出若干代理人, 由代理人来完成记账。</p>
<p>附：<a href="https://draveness.me/consensus" target="_blank" rel="external">https://draveness.me/consensus</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两年，区块链的技术可以说是非常的火爆，不了解点什么都不好说自己是在互联网混的，有人将区块链称之为互联网2.0，可以说区块链将对现有的互联网技术进行改造升级。那么，就让我们一起来了解下什么是区块链吧。&lt;/p&gt;
&lt;p&gt;简单来讲，所谓区块链技术，也被称之为分布式账本技术，是一种
    
    </summary>
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android KTX举例</title>
    <link href="http://www.xiangzhihong.com/2017/12/16/Android%20KTX%E4%B8%BE%E4%BE%8B/"/>
    <id>http://www.xiangzhihong.com/2017/12/16/Android KTX举例/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2018-03-17T07:41:20.198Z</updated>
    
    <content type="html"><![CDATA[<p>早在今年的1月份，就有报道称谷歌2018年I/O大会将于5月8日至5月10日在加利福尼亚山景城的海岸线露天剧场举行。近日，谷歌公布了本次开发者大会的具体日程安排。在具体细节上，本次开发者大会将围绕Android、增强现实（AR）与虚拟现实（VR）三个主题来展开。<br>在本次开发者大会的首日，会议将从Google Play、Android即时应用、Android KTX，Android Kotlin开发和入门，以及 Android、Android apps for Chrome OS、Android Wear的最新进展。本文就Android KTX相关的知识做相关的讲解，可以看到Google对Kotlin的重视程度也越来越高。关于Android KTX相关的介绍，大家可以访问我之前的介绍：<a href="http://blog.csdn.net/xiangzhihong8/article/details/79277879" target="_blank" rel="external">http://blog.csdn.net/xiangzhihong8/article/details/79277879</a></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h3 id="字符串转为URI"><a href="#字符串转为URI" class="headerlink" title="字符串转为URI"></a>字符串转为URI</h3><p>通常情况下为 Uri.parse(uriString)，但是 Android KTX 会为字符串添加一个扩展函数，使字符串更加自然地转换为 URI。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Kotlin</div><div class="line">val uri = Uri.parse(uriString)</div><div class="line"></div><div class="line">// android KTX</div><div class="line">val uri = uriString.toUri()</div></pre></td></tr></table></figure>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>SharedPreferences也经常使用，使用 Android KTX后，代码也简介不少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// kotlin</div><div class="line">sharedPreferences.edit()</div><div class="line">    .putBoolean(&quot;key&quot;, value)</div><div class="line">    .apply()</div><div class="line"></div><div class="line">// KTX</div><div class="line">sharedPreferences.edit &#123;</div><div class="line">    putBoolean(&quot;key&quot;, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>例如，两个路径之间的距离改变了100px。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// kotlin</div><div class="line">val pathDifference = Path(myPath1).apply &#123;</div><div class="line">    op(myPath2, Path.Op.DIFFERENCE)</div><div class="line">&#125;</div><div class="line"></div><div class="line">canvas.apply &#123;</div><div class="line">  val checkpoint = save()</div><div class="line">  translate(0F, 100F)</div><div class="line">  drawPath(pathDifference, myPaint)</div><div class="line">  restoreToCount(checkpoint)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// KTX</div><div class="line">val pathDifference = myPath1 - myPath2</div><div class="line"></div><div class="line">canvas.withTranslation(y = 100F) &#123;</div><div class="line">    drawPath(pathDifference, myPaint)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="View的onPreDraw监听"><a href="#View的onPreDraw监听" class="headerlink" title="View的onPreDraw监听"></a>View的onPreDraw监听</h3><p>下面的示例触发了视图中 onPreDraw 的回调，如果没有 Android KTX，你需要编写相当多的代码。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// kotlin</div><div class="line">view.viewTreeObserver.addOnPreDrawListener(</div><div class="line">    object : ViewTreeObserver.OnPreDrawListener &#123;</div><div class="line">        override fun onPreDraw(): Boolean &#123;</div><div class="line">            viewTreeObserver.removeOnPreDrawListener(this)</div><div class="line">            actionToBeTriggered()</div><div class="line">            return true</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">// KTX</div><div class="line">view.doOnPreDraw &#123;</div><div class="line">     actionToBeTriggered()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Android集成"><a href="#Android集成" class="headerlink" title="Android集成"></a>Android集成</h3><p>要在你的 Android Kotlin 项目中开始使用 Android KTX，需要在应用模块 build.gradle的脚本文件中添加以下配置脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    google()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation &apos;androidx.core:core-ktx:0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>在上面的Android KTX中，主要是使用了Kotlin 的几个特性，下面就这些特性进行简单的说明。</p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>在Kotlin的Extensions中有过详细的介绍，可以通过以下地址来获取更多的知识：<a href="http://kotlinlang.org/docs/reference/extensions.html。例如，uri的封装就是利用了这个特性。" target="_blank" rel="external">http://kotlinlang.org/docs/reference/extensions.html。例如，uri的封装就是利用了这个特性。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inline fun String.toUri(): Uri = Uri.parse(this)</div></pre></td></tr></table></figure>
<p>其实就是对String做了一个扩展，如果使用Java的就很容易理解，如下所示，这种方式在日常开发中也很容易见到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class StringUtil&#123;</div><div class="line"></div><div class="line">    public static Uri parse(String uriString) &#123;</div><div class="line">        return Uri.parse(uriString);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h3><p>对于Lambdas表达式和高阶函数，对于了解过Kotlin的同学来说并不陌生，<br>可以通过下面的链接来了解详细的介绍：<a href="http://kotlinlang.org/docs/reference/lambdas.html" target="_blank" rel="external">http://kotlinlang.org/docs/reference/lambdas.html</a></p>
<p>还是先来看KTX的相关源码吧。首先对SharedPreferences做了扩展，然后这个扩展函数的参数是一个闭包，当函数最后一个参数是闭包的时候，函数的括号可以直接省略，然后在后面接上闭包就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">inline fun SharedPreferences.edit(action: SharedPreferences.Editor.() -&gt; Unit) &#123;</div><div class="line">    val editor = edit()</div><div class="line">    action(editor)</div><div class="line">    editor.apply()</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在今年的1月份，就有报道称谷歌2018年I/O大会将于5月8日至5月10日在加利福尼亚山景城的海岸线露天剧场举行。近日，谷歌公布了本次开发者大会的具体日程安排。在具体细节上，本次开发者大会将围绕Android、增强现实（AR）与虚拟现实（VR）三个主题来展开。&lt;br&gt;在本
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>移动PWA初探</title>
    <link href="http://www.xiangzhihong.com/2017/11/23/%E7%A7%BB%E5%8A%A8PWA%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.xiangzhihong.com/2017/11/23/移动PWA初探/</id>
    <published>2017-11-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:14:11.871Z</updated>
    
    <content type="html"><![CDATA[<p>在去年上海举办的2017谷歌开发者大会上，PWA作为会议的一个重要内容被推介，笔者作为参会嘉宾看了PWA的内容后，觉得这种技术会是未来移动发展的一个趋势。Google开发技术推广工程师Michael Yeung介绍称，新浪微博正在打造一款全新体验的Web Mobile PWA应用，读者可以通过微博提供的PWA版访问网址：<a href="m.weibo.cn/beta">m.weibo.cn/beta</a>。<br><img src="http://img.blog.csdn.net/20180126140527984" alt="这里写图片描述"></p>
<p>在当前的移动跨平台开发方案中，主要的技术有PWA和Weex、RN（这个笔者在16年专门进行了研究，并出版了相关的书籍）。不过纵观这些移动技术可以发现，PWA是优化web app，RN是用web调用native思路，weex还是使用web栈调用native的思路。</p>
<p>在移动碎片化严重的当前，如何制定一个统一的标准，才是为了移动技术发展的方向，也就是说：“Web不会趋向于Native，而是Native趋向于Web。”。</p>
<h1 id="PWA简介"><a href="#PWA简介" class="headerlink" title="PWA简介"></a>PWA简介</h1><p>PWA全称Progressive Web Apps（渐进式网络应用），该项目由谷歌在2015年主导推出，主要的特性是让Web App的体验能更接近原生应用，显著提高应用加载速度，甚至可以在离线状态下运行，多种手机/PC浏览器已支持加载PWA网页。<br><img src="http://img.blog.csdn.net/20180126141045046" alt="这里写图片描述"><br>所谓的P（Progressive）这里有两层含义，一方面是渐进增强，让WEB APP的体验和功能能够用渐进增强的方式来更接近原生APP的体验及功能；另一方面是指下一代WEB技术，PWA并不是描述一个技术，而是一些技术的合集。PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>
<p>PWA 的主要特点包括下面三点：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>
</ul>
<p>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。</p>
<h2 id="PWA特性"><a href="#PWA特性" class="headerlink" title="PWA特性"></a>PWA特性</h2><p>下面就从安全、性能和体验三个方面来介绍PWA所具有的特性。</p>
<h3 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h3><p>当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。</p>
<p>Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。</p>
<p>更详细的内容可以访问：<a href="https://developers.google.cn/web/fundamentals/primers/service-workers/" target="_blank" rel="external"> Service Worker</a></p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>如果站点加载时间超过 3s，53% 的用户会放弃等待。页面展现之后，用户期望有平滑的体验，过渡动画和快速响应。</p>
<p>为了保证首屏的加载，我们需要从设计上考虑，在内容请求完成之前，可以优先保证 App Shell 的渲染，做到和 Native App 一样的体验，App Shell 是 PWA 界面展现所需的最小资源。</p>
<p>更多的资料可以参考：<a href="https://developers.google.cn/web/fundamentals/architecture/app-shell" target="_blank" rel="external"> App Shell 设计规范</a></p>
<h3 id="粘性"><a href="#粘性" class="headerlink" title="粘性"></a>粘性</h3><p>PWA具有的粘性表现在如下几个方面：</p>
<ul>
<li>PWA 是可以安装的，用户点击安装到桌面后，会在桌面创建一个 PWA 应用，并且不需要从应用商店下载；</li>
<li>PWA 可以借助 Web App Manifest 提供给用户和 Native App 一样的沉浸式体验；</li>
<li>PWA 可以通过给用户发送离线通知，让用户回流。</li>
</ul>
<p>同时，Web App Manifest 允许开发者控制 PWA 添加到桌面，允许定制桌面图标、URL等等。</p>
<p>关于Web App Manifest更多的内容可以参考：<a href="https://developers.google.cn/web/fundamentals/web-app-manifest/?hl=zh-cn" target="_blank" rel="external">Web App Manifest</a>和<a href="https://developers.google.cn/web/fundamentals/push-notifications/?hl=zh-cn" target="_blank" rel="external">Push Notification</a>。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除此之外，讲到 PWA 兼具 Web App 和 Native App 的特征的，Web App 无版本问题、可索引也是很重要的特性。</p>
<p>总结一下，PWA 具有下面一些特性：</p>
<ul>
<li><strong>渐进式</strong> - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的。</li>
<li><strong>连接无关性</strong> - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问。</li>
<li><strong>类似应用</strong> - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App的体验。</li>
<li><strong>持续更新</strong> - 始终是最新的，无版本和更新问题。</li>
<li><strong>安全</strong> - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改。</li>
<li><strong>可索引</strong> - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』。</li>
<li><strong>粘性</strong> - 通过推送离线通知等，可以让用户回流。</li>
<li><strong>可安装</strong> - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦。</li>
<li><strong>可链接</strong> - 通过链接即可分享内容，无需下载安装。</li>
</ul>
<p>PWA 是对站点体验的一个飞跃式的提升，可以在移动设备上的 Chrome(version &gt; 52) 访问 <a href="https://weatherpwa.baidu.com/" target="_blank" rel="external">天气PWA</a> 体验一下。</p>
<h1 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h1><p>所谓渐进式，就是逐步的改善，不是一蹴而就的，采取这种方案，主要有两点原因：</p>
<ul>
<li>降低站点改造的代价，逐步支持各项新技术，不要一蹴而就；</li>
<li>新技术标准的支持度还不完全，新技术的标准还未完全确定。</li>
</ul>
<p>所以，从改造的成本考虑，我们也建议采取渐进式的方式，可以考虑按照下面的步骤来改造：</p>
<ul>
<li>第一步，应该是安全，将全站 HTTPS 化，因为这是 PWA 的基础，没有 HTTPS，就没有 Service Worker</li>
<li>第二步，应该是 Service Worker 来提升基础性能，离线提供静态文件，把用户首屏体验提升上来</li>
<li>第三步，App Manifest，这一步可以和第二步同时进行 后续，再考虑其他的特性，离线消息推送等</li>
</ul>
<p>同时，PWA作为最新的不太成熟的技术，当前浏览器还没有达到完全支持的程度，W3C 关于这些技术的标准也还在处于草稿状态，没有定稿。根据知名统计网站<a href="https://caniuse.com/" target="_blank" rel="external">Can I use </a>的统计，对PWA相关技术的支持程度如下：</p>
<ul>
<li>App Manifest 的支持度达到 57.43%；</li>
<li>Service Worker 的支持度达到 72.82%；</li>
<li>Notifications API 的支持度达到 43.3%；</li>
<li>Push API 的支持度达到 72.39%；</li>
<li>Background Sync 暂未统计到，Chrome 49 以上均支持。</li>
</ul>
<p>比较遗憾的是上面提到的所有技术，目前只有 Android 的部分浏览器支持，iOS 的Safari暂不支持，不过，Safari 浏览器已经在考虑了。</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p>W3C 组织早在 2014 年 5 月就提出过 Service Worker 这样的一个 HTML5 API ，主要用来做持久的离线缓存。对于API相关的内容，这里仔细整理了一下：<br>浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。</p>
<p>W3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫 Web Worker 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 postMessage 方法告诉主线程，而主线程通过 onMessage 方法得到 Web Worker 的结果反馈。</p>
<p>一切问题好像是解决了，但 Web Worker 是临时的，我们能不能有一个东东是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初版本的 Service Worker ，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。当然在 Service Worker 之前也有在 HTML5 上做离线缓存的 API 叫 AppCache, 但是 AppCache 存在很多 不能忍受的<a href="https://alistapart.com/article/application-cache-is-a-douchebag" target="_blank" rel="external">缺点</a>。</p>
<p>W3C 决定 AppCache 仍然保留在 HTML 5.0 Recommendation 中，在 HTML 后续版本中移除。</p>
<ul>
<li>Issue: <a href="https://github.com/w3c/html/issues/40" target="_blank" rel="external">https://github.com/w3c/html/issues/40</a></li>
<li>Mailing list:<br><a href="https://lists.w3.org/Archives/Public/public-html/2016May/0005.html" target="_blank" rel="external">https://lists.w3.org/Archives/Public/public-html/2016May/0005.html</a></li>
</ul>
<p>WHATWG HTML5 作为 Live Standard，也将 AppCache 标注为 Discouraged 并引导至 Service Worker。Ok ，那么 Service Worker 到底用来干啥的呢？</p>
<p>Service Worker 有以下功能和特性：</p>
<ul>
<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>
<li>一旦被 install，就永远存在，除非被 uninstall。</li>
<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）。</li>
<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）。</li>
<li>离线内容开发者可控。</li>
<li>能向客户端推送消息。</li>
<li>不能直接操作 DOM。</li>
<li>出于安全的考虑，必须在 HTTPS 环境下才能工作。</li>
<li>异步实现，内部大都是通过 Promise 实现。</li>
</ul>
<p>所以我们基本上知道了 Service Worker 的伟大使命，就是让缓存做到优雅和极致，让 Web App 相对于 Native App 的缺点更加弱化，也为开发者提供了对性能和体验的无限遐想。</p>
<h2 id="浏览器Service-Worker支持情况"><a href="#浏览器Service-Worker支持情况" class="headerlink" title="浏览器Service Worker支持情况"></a>浏览器Service Worker支持情况</h2><p>根据<a href="https://caniuse.com/#search=service%20worker" target="_blank" rel="external">Can I use </a>发现，目前市场上对Service Worker的支持情况如下：<br><img src="http://img.blog.csdn.net/20180126150401834" alt="这里写图片描述"><br>从这张图可以发现，Chrome 作为开路先锋早早的在 V40 版本就支持了，还提供了完善的 debug 方案（ Service Worker debug ）；Firefox，Opera 不甘示弱在后续版本也进行了支持；安卓手机 4.x 以上版本新系统形势一片大好（具体各手机的实现还得进一步探测）；安卓 Chrome 同样给力；但是目前IE和Safair是不支持的，不过已经被列入未来的支持计划中。</p>
<h2 id="Service-Worker使用"><a href="#Service-Worker使用" class="headerlink" title="Service Worker使用"></a>Service Worker使用</h2><p>Service Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。</p>
<ul>
<li>由于 Service Worker 要求 HTTPS 的环境，我们通常可以借助于 <a href="https://pages.github.com/" target="_blank" rel="external">github<br>page</a> 进行学习调试。当然一般浏览器允许调试 Service Worker<br>的时候 host 为 localhost 或者 127.0.0.1 也是 ok 的。</li>
<li>Service Worker 的缓存机制是依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="external">Cache API</a> 实现的。</li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="external">HTML5 fetch API</a>。</li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/javaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a> 实现。</li>
</ul>
<h3 id="Service-Worker注册"><a href="#Service-Worker注册" class="headerlink" title="Service Worker注册"></a>Service Worker注册</h3><p>要安装 Service Worker， 我们需要通过在 js 主线程（常规的页面里的 js ）注册 Service Worker 来启动安装，这个过程将会通知浏览器我们的 Service Worker 线程的 javaScript 文件在什么地方呆着。先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</div><div class="line">    window.addEventListener(&apos;load&apos;, function () &#123;</div><div class="line">        navigator.serviceWorker.register(&apos;/sw.js&apos;, &#123;scope: &apos;/&apos;&#125;)</div><div class="line">            .then(function (registration) &#123;</div><div class="line"></div><div class="line">                // 注册成功</div><div class="line">                console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</div><div class="line">            &#125;)</div><div class="line">            .catch(function (err) &#123;</div><div class="line"></div><div class="line">                // 注册失败:(</div><div class="line">                console.log(&apos;ServiceWorker registration failed: &apos;, err);</div><div class="line">            &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码首先判断 Service Worker API 的可用情况，支持的话咱们才继续谈实现。如果支持的话，在页面 onload 的时候注册位于 /sw.js 的 Service Worker。每次页面加载成功后，就会调用 register() 方法，浏览器将会判断 Service Worker 线程是否已注册并做出相应的处理。register 方法的 scope 参数是可选的，用于指定你想让 Service Worker 控制的内容的子目录。本 demo 中服务工作线程文件位于根网域， 这意味着服务工作线程的作用域将是整个来源。</p>
<p><strong>说明</strong>： Service Worker 线程将接收 scope 指定网域目录上所有事项的 fetch 事件，如果我们的 Service Worker 的 javaScript 文件在 /a/b/sw.js， 不传 scope 值的情况下, scope 的值就是 /a/b。<br>scope 的值的意义在于，如果 scope 的值为 /a/b， 那么 Service Worker 线程只能捕获到 path 为 /a/b 开头的( /a/b/page1, /a/b/page2，…)页面的 fetch 事件。通过 scope 的意义我们也能看出 Service Worker 不是服务单个页面的，所以在 Service Worker 的 js 逻辑中全局变量需要慎用。</p>
<p>then() 函数链式调用我们的 promise，当 promise resolve 的时候，里面的代码就会执行。代码执行完成之后，我们这就注册了一个 Service Worker，它工作在 worker context，所以没有访问 DOM 的权限。在正常的页面之外运行 Service Worker 的代码来控制它们的加载。</p>
<p>为了验证Service Worker 到底有没有注册成功，可以在 PC 上打开chrome 浏览器，并输入：chrome://inspect/#service-workers。<br><img src="http://img.blog.csdn.net/20180126151838107" alt="这里写图片描述"><br>我们还可以通过 chrome://serviceworker-internals 来查看服务工作线程详情。 如果只是想了解服务工作线程的生命周期，这仍很有用，但是日后其很有可能被 chrome://inspect/#service-workers 完全取代。</p>
<p>当然，它还可用于测试隐身窗口中的 Service Worker 线程，您可以关闭 Service Worker 线程并重新打开，因为之前的 Service Worker 线程不会影响新窗口。从隐身窗口创建的任何注册和缓存在该窗口关闭后均将被清除。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在你的 Service Worker 注册成功之后呢，我们的浏览器中已经有了一个属于你自己 web App 的 worker context 啦， 在此时，浏览器就会马不停蹄的尝试为你的站点里面的页面安装并激活它，并且在这里可以把静态资源的缓存给办了。</p>
<p>install 事件我们会绑定在 Service Worker 文件中，在 Service Worker 安装成功后，install 事件被触发。</p>
<p>install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 新的标志性的存储 cache API — 一个 Service Worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>
<p>localStorage 的用法和 Service Worker cache 的用法很相似，但是由于 localStorage 是同步的用法，所以不允许在 Service Worker 中使用。 IndexedDB 也可以在 Service Worker 内做数据存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">this.addEventListener(&apos;install&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(</div><div class="line">        caches.open(&apos;my-test-cache-v1&apos;).then(function (cache) &#123;</div><div class="line">            return cache.addAll([</div><div class="line">                &apos;/&apos;,</div><div class="line">                &apos;/index.html&apos;,</div><div class="line">                &apos;/main.css&apos;,</div><div class="line">                &apos;/main.js&apos;,</div><div class="line">                &apos;/image.jpg&apos;</div><div class="line">            ]);</div><div class="line">        &#125;)</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自动更新页面"><a href="#自动更新页面" class="headerlink" title="自动更新页面"></a>自动更新页面</h3><p>如果希望在有了新版本时，所有的页面都得到及时自动更新怎么办呢？可以在 install 事件中执行 self.skipWaiting() 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 self.clients.claim() 方法，更新所有客户端上的 Service Worker。例如下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 安装阶段跳过等待，直接进入 active</div><div class="line">self.addEventListener(&apos;install&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(self.skipWaiting());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(</div><div class="line">        Promise.all([</div><div class="line"></div><div class="line">            // 更新客户端</div><div class="line">            self.clients.claim(),</div><div class="line"></div><div class="line">            // 清理旧版本</div><div class="line">            caches.keys().then(function (cacheList) &#123;</div><div class="line">                return Promise.all(</div><div class="line">                    cacheList.map(function (cacheName) &#123;</div><div class="line">                        if (cacheName !== &apos;my-test-cache-v1&apos;) &#123;</div><div class="line">                            return caches.delete(cacheName);</div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                );</div><div class="line">            &#125;)</div><div class="line">        ])</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另外要注意一点，/sw.js 文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件。这会导致更新得不到响应。如遇到该问题，可尝试这么做：在 Web Server 上添加对该文件的过滤规则，不缓存或设置较短的有效期。</p>
<h3 id="手动更新-Service-Worker"><a href="#手动更新-Service-Worker" class="headerlink" title="手动更新 Service Worker"></a>手动更新 Service Worker</h3><p>其实在页面中，也可以手动借助 Registration.update() 更新。例如，下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var version = &apos;1.0.1&apos;;</div><div class="line"></div><div class="line">navigator.serviceWorker.register(&apos;/sw.js&apos;).then(function (reg) &#123;</div><div class="line">    if (localStorage.getItem(&apos;sw_version&apos;) !== version) &#123;</div><div class="line">        reg.update().then(function () &#123;</div><div class="line">            localStorage.setItem(&apos;sw_version&apos;, version)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时，<a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-debug" target="_blank" rel="external">Service Worker debug</a> 技巧 中也会提到, Service Worker 被载入后立即激活可以保证每次 /sw.js 为最新的。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(&apos;install&apos;, function () &#123;</div><div class="line">    self.skipWaiting();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Service-Worker-生命周期"><a href="#Service-Worker-生命周期" class="headerlink" title="Service Worker 生命周期"></a>Service Worker 生命周期</h2><p>Service Worker 的使用过程很简单，所处理的事情也相对单一，我们基本上需要做的就是利用这个 API 做好站点的缓存策略。在页面脚本中注册 Service Worker 文件所在的 URL。Worker 就可以开始激活了，激活后的 Service Worker 可以监听当前域下的功能性事件，比如资源请求（fetch）、推送通知（push）、后台同步（sync）。在这一系列的流程中，从 Service Worker 的注册到消失，经历了生命周期中不同的状态。</p>
<h3 id="Service-Worker-工作流程"><a href="#Service-Worker-工作流程" class="headerlink" title="Service Worker 工作流程"></a>Service Worker 工作流程</h3><p>Service Worker 基本就是以下几个步骤：</p>
<ol>
<li>首先，我们需要在页面的JavaScript 主线程中使用 serviceWorkerContainer.register() 来注册Service Worker ，在注册的过程中，浏览器会在后台启动尝试 Service Worker 的安装步骤。</li>
<li>如果注册成功，Service Worker 在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊的 worker context，与主脚本的运行线程相独立，同时也没有访问 DOM 的能力。</li>
<li>后台开始安装步骤， 通常在安装的过程中需要缓存一些静态资源。如果所有的资源成功缓存则安装成功，如果有任何静态资源缓存失败则安装失败，在这里失败的不要紧，会自动继续安装直到安装成功，如果安装不成功无法进行下一步 激活 Service Worker操作。</li>
<li>开始激活 Service Worker，必须要在 Service Worker 安装成功之后，才能开始激活步骤，当 Service Worker 安装完成后，会接收到一个激活事件（activate event）。激活事件的处理函数中，主要操作是清理旧版本的 Service Worker 脚本中使用资源。</li>
<li>激活成功后 Service Worker 可以控制页面了，但是只针对在成功注册了 Service Worker 后打开的页面。也就是说，页面打开时有没有 Service Worker，决定了接下来页面的生命周期内受不受 Service Worker 控制。所以，只有当页面刷新后，之前不受 Service Worker 控制的页面才有可能被控制起来。</li>
</ol>
<h3 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h3><p>下面是MDN 给出了详细的 Service Worker 生命周期图：<br><img src="http://img.blog.csdn.net/20180126162232416" alt="这里写图片描述"></p>
<p>由上图可知，Service Worker的生命周期主要分为以下几个阶段：安装中, 安装后, 激活中, 激活后, 废弃。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。<br>install 事件回调中有两个方法：</p>
<ul>
<li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li>self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>
</ul>
<h4 id="安装后-installed"><a href="#安装后-installed" class="headerlink" title="安装后( installed )"></a>安装后( installed )</h4><p>Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。</p>
<h4 id="激活-activating"><a href="#激活-activating" class="headerlink" title="激活( activating )"></a>激活( activating )</h4><p>在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。</p>
<p>激活的状态回调中有两个方法：</p>
<ul>
<li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li>self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。</li>
</ul>
<h4 id="激活后-activated"><a href="#激活后-activated" class="headerlink" title="激活后( activated )"></a>激活后( activated )</h4><p>在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。</p>
<h4 id="废弃状态-redundant"><a href="#废弃状态-redundant" class="headerlink" title="废弃状态 ( redundant )"></a>废弃状态 ( redundant )</h4><p>这个状态表示一个 Service Worker 的生命周期结束。废弃状态可能有以下几种：</p>
<ul>
<li>安装 (install) 失败；</li>
<li>激活 (activating) 失败；</li>
<li>新版本的 Service Worker 替换了它并成为激活状态。</li>
</ul>
<h3 id="Service-Worker支持的事件"><a href="#Service-Worker支持的事件" class="headerlink" title="Service Worker支持的事件"></a>Service Worker支持的事件</h3><p>同时，MDN 也列出了 Service Worker 所有支持的事件，如下图所示：<br><img src="http://img.blog.csdn.net/20180126163252777" alt="这里写图片描述"></p>
<ul>
<li><strong>install</strong>：Service Worker 安装成功后被触发的事件，在事件处理函数中可以添加需要缓存的文件。</li>
<li><strong>activate</strong>：当 Service Worker 安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对旧版本的更新、对无用缓存的清理等。</li>
<li><strong>message</strong>：Service Worker 运行于独立 context 中，无法直接访问当前页面主线程的 DOM 等信息，但是通过 postMessage API，可以实现他们之间的消息传递，这样主线程就可以接受 Service Worker 的指令操作 DOM。</li>
</ul>
<p>Service Worker 有几个重要的功能性的的事件，这些功能性的事件支撑和实现了 Service Worker 的特性。</p>
<ul>
<li>fetch (请求)：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response参数的回调函数，回调中就可以做各种代理缓存的事情了。</li>
<li>push (推送)：push 事件是为推送准备的。不过首先需要了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="external">Notification API</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="external">PUSH API</a>。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</li>
<li><strong>sync (后台同步)</strong>：sync 事件由 background sync (后台同步)发出。background sync 配合 Service Worker 推出的 API，用于为 Service Worker 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C Web API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。</li>
</ul>
<h2 id="Service-Worker-调试"><a href="#Service-Worker-调试" class="headerlink" title="Service Worker 调试"></a>Service Worker 调试</h2><p>Service Worker 作为独立于主线程的独立线程，在调试方面有其实和常规的 JavaScript 开发类似，我们关注的点大概有如下几点：</p>
<ul>
<li>代码是否有报错；</li>
<li>Service Worker 能否顺利更新；</li>
<li>在不同机型上的兼容性问题 debug；</li>
<li>不同类型资源和请求的缓存策略的验证。</li>
</ul>
<h3 id="debug-环境下等待状态"><a href="#debug-环境下等待状态" class="headerlink" title="debug 环境下等待状态"></a>debug 环境下等待状态</h3><p>根据 Service Worker 生命周期的特性，如果浏览器还在使用旧的 Service Worker 版本，即使有 Service Worker 新的版本也不会立即被浏览器激活，只能进行安装并进入等待状态，直到浏览器 Tab 标签被重新关闭打开。</p>
<p>在开发调试 Service Worker 时肯定希望重新加载后立即激活，我们不希望每次都重新打开当前页面调试，为此我们可以在 install 事件发生时通过 skipWaiting() 来设置 skip waiting 标记。 这样每次 Service Worker 安装后就会被立即激活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(&apos;install&apos;, function () &#123;</div><div class="line">    if (ENV === &apos;development&apos;) &#123;</div><div class="line">        self.skipWaiting();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是当浏览器未检测到 Service Worker 发生变化时（比如该文件设置了 HTTP 缓存）， 甚至连安装都不会被触发。现在可以借助于浏览器 DevTools 调试了： 比如在 Chrome DevTools 的 Application 标签页勾选 Update on reload，Chrome 会在每次刷新时去访问 Service Worker 文件并重新安装和激活。</p>
<h3 id="借助-Chrome-浏览器进行-debug"><a href="#借助-Chrome-浏览器进行-debug" class="headerlink" title="借助 Chrome 浏览器进行 debug"></a>借助 Chrome 浏览器进行 debug</h3><p>使用 Chrome 浏览器，可以通过进入控制台 Application -&gt; Service Workers 面板查看和调试。如下图所示：<br><img src="http://img.blog.csdn.net/20180126164758216" alt="这里写图片描述"><br>如果 Service Worker 线程已安装到当前打开的页面上，您会看到它将列示在此窗格中。 例如，在上方的屏幕截图中，<a href="https://lavas-project.github.io/lavas-demo/news-v2/#/" target="_blank" rel="external">https://lavas-project.github.io/lavas-demo/news-v2/#/</a> 的作用域内安装了一个 Service Worker 线程。</p>
<p>其中，Service Worker会有以下几个选项：</p>
<ul>
<li><strong>offline</strong>： 复选框可以将 DevTools 切换至离线模式。它等同于 Network 窗格中的离线模式。</li>
<li><strong>Update on reload</strong>：复选框可以强制 Service Worker 线程在每次页面加载时更新。</li>
<li><strong>Bypass for network</strong>：复选框可以绕过 Service Worker 线程并强制浏览器转至网络寻找请求的资源。</li>
<li><strong>Update</strong>：按钮可以对指定的 Service Worker 线程执行一次性更新。</li>
<li><strong>Push</strong>：按钮可以在没有负载的情况下模拟推送通知。</li>
<li><strong>Sync</strong>：按钮可以模拟后台同步事件。</li>
<li><strong>Unregister</strong>：按钮可以注销指定的 Service Worker 线程。</li>
<li><strong>Source</strong>：告诉您当前正在运行的 Service Worker 线程的安装时间。 链接是 Service Worker线程源文件的名称。点击链接会将您定向至 Service Worker 线程来源。</li>
<li><strong>Status</strong>：告诉您 Service Worker 线程的状态。此行上的数字（上方屏幕截图中的 #1）指示 Service Worker线程已被更新的次数。如果启用 update on reload 复选框，您会注意到每次页面加载时此数字都会增大。在状态旁边，您将看到 start 按钮（如果 Service Worker 线程已停止）或 stop 按钮（如果 Service Worker 线程正在运行）。  Service Worker 线程设计为可由浏览器随时停止和启动。 使用 stop 按钮明确停止 Service Worker 线程可以模拟这一点。停止 Service Worker 线程是测试 Service Worker线程再次重新启动时的代码行为方式的绝佳方法。它通常可以揭示由于对持续全局状态的不完善假设而引发的错误。</li>
<li><strong>Clients</strong>：告诉您 Service Worker 线程作用域的原点。 如果您已启用 show all 复选框，focus按钮将非常实用。 在此复选框启用时，系统会列出所有注册的 Service Worker 线程。 如果您点击正在不同标签中运行的Service Worker 线程旁的 focus 按钮，Chrome 会聚焦到该标签。</li>
</ul>
<p>如果 Service Worker 文件在运行过程中出现了任何的错误，将显示一个 Error 新标签。例如：<br><img src="http://img.blog.csdn.net/20180126165227926" alt="这里写图片描述"></p>
<p>当然我们也可以直接访问 Chrome://serviceworker-internals 来打开 serviceWorker 的配置面板，查看所有注册的 Service Worker 情况。注意一点，如无必要，不要选中顶部的 Open DevTools window and pause javaScript execution on Service Worker startup for debugging 复选框，否则每当刷新页面调试时都会弹出一个开发者窗口来。</p>
<p>在 Firefox 中，可以通过 Tools -&gt; Web Developer -&gt; Service Workers 打开调试面板。也可以访问 about:debugging#workers 直接进入该面板。</p>
<h3 id="Service-Worker-缓存内容"><a href="#Service-Worker-缓存内容" class="headerlink" title="Service Worker 缓存内容"></a>Service Worker 缓存内容</h3><p>我们知道，Service Worker 使用 Cache API 缓存只读资源，我们同样可以在 Chrome DevTools 上查看缓存的资源列表。Cache Storage 选项卡提供了一个已使用（Service Worker 线程）Cache API 缓存的只读资源列表。<br><img src="http://img.blog.csdn.net/20180126165829698" alt="这里写图片描述"></p>
<p>这里有个地方需要注意一下：第一次打开缓存并向其添加资源时，Chrome DevTools 可能检测不到更改。 重新加载页面后，您应当可以看到缓存。<br><img src="http://img.blog.csdn.net/20180126165943621" alt="这里写图片描述"><br>当然，Cache Storage 提供清除 Cache 列表的功能，在选择 Cache Storage 选项卡后在 Cache Storge 缓存的 key 的 item 上右键点击出现 delete ，点击 delete 就可以清除该缓存了。<br><img src="http://img.blog.csdn.net/20180126170032650" alt="这里写图片描述"></p>
<h3 id="网络跟踪调试"><a href="#网络跟踪调试" class="headerlink" title="网络跟踪调试"></a>网络跟踪调试</h3><p>此外经过 Service Worker 的 fetch 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中：</p>
<ul>
<li>来自 Service Worker 的内容会在 Size 字段中标注为 from ServiceWorker。</li>
<li>Service Worker 发出的请求会在 Name 字段中添加 ⚙ 图标。</li>
</ul>
<p>例如下图中，第一个名为 300 的请求是一张 jpeg 图片， 其 URL 为 <a href="https://unsplash.it/200/300，该请求是由" target="_blank" rel="external">https://unsplash.it/200/300，该请求是由</a> Service Worker 代理的， 因此被标注为 from ServiceWorker。</p>
<p>为了响应页面请求，Service Worker 也发出了名为 300 的请求（这是图中第二个请求）， 但 Service Worker 把 URL 改成了 <a href="https://unsplash.it/g/200/300，因此返回给页面的图片是灰色的。" target="_blank" rel="external">https://unsplash.it/g/200/300，因此返回给页面的图片是灰色的。</a></p>
<p><img src="http://img.blog.csdn.net/20180126170518763" alt="这里写图片描述"></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>所谓“工欲善其事，必先利其器”，在开始开发PWA程序之前，需要安装好相关的运行环境，PWA需要Node 和 Ngrok 支持。关于Node 的使用以及安装我就不说啦，而Ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。</p>
<h2 id="Ngrok安装使用"><a href="#Ngrok安装使用" class="headerlink" title="Ngrok安装使用"></a>Ngrok安装使用</h2><p>读者可以到<a href="https://ngrok.com/download" target="_blank" rel="external">Ngrok官网</a>下载它，解压后某个目录。</p>
<p>需要注意的是，有的人说需要注册ngrok得到your auth token，后面的自定义域名必须要有这个token，因为我暂时不需要自定义域名，所以就省略了这一步。<br>然后在解压后的Ngrok目录下使用命令：./ngrok help<br><img src="http://img.blog.csdn.net/20180126171921049" alt="这里写图片描述"></p>
<p>然后，使用如下命令来开启服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ngrok http localhost:9988</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180126172053515" alt="这里写图片描述"></p>
<p>其中，<a href="http://dae1a9d6.ngrok.io和https://dae1a9d6.ngrok.io就是本地localhost映射的外网地址，注意这个映射外网地址是变化的，也就是你每次启动ngrok，获取的外网地址是不一样的，貌似如果想使用固定外网地址，就需要收费。" target="_blank" rel="external">http://dae1a9d6.ngrok.io和https://dae1a9d6.ngrok.io就是本地localhost映射的外网地址，注意这个映射外网地址是变化的，也就是你每次启动ngrok，获取的外网地址是不一样的，貌似如果想使用固定外网地址，就需要收费。</a> </p>
<p>然后输入<a href="http://dae1a9d6.ngrok.io地址就可以访问了。" target="_blank" rel="external">http://dae1a9d6.ngrok.io地址就可以访问了。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在去年上海举办的2017谷歌开发者大会上，PWA作为会议的一个重要内容被推介，笔者作为参会嘉宾看了PWA的内容后，觉得这种技术会是未来移动发展的一个趋势。Google开发技术推广工程师Michael Yeung介绍称，新浪微博正在打造一款全新体验的Web Mobile PW
    
    </summary>
    
      <category term="PWA" scheme="http://www.xiangzhihong.com/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://www.xiangzhihong.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.2 新特性</title>
    <link href="http://www.xiangzhihong.com/2017/11/23/Kotlin%201.2%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://www.xiangzhihong.com/2017/11/23/Kotlin 1.2 新特性/</id>
    <published>2017-11-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:03:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>在Kotlin 1.1中，团队正式发布了JavaScript目标，允许开发者将Kotlin代码编译为JS并在浏览器中运行。在Kotlin 1.2中，团队增加了在JVM和JavaScript之间重用代码的可能性。现在，使用Kotlin编写的代码，可以在所有的应用程序中（包括后端，浏览器前端和Android移动应用程序）中重复使用。</p>
<p><img src="http://img.blog.csdn.net/20171230103641390" alt="这里写图片描述"></p>
<p>想要体验Kotlin1.2新功能的同学，可以下载官方提供的IntelliJ IDEA 2017.3开发工具，或者升级老的IDE，当然也可以通过在线网站来体验。</p>
<h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>跨平台项目是 Kotlin 1.2 中的一个新的实验性功能，它允许开发者从相同的代码库构建应用程序的多个层——后端、前端和Android应用程序，在这个跨平台方案中，主要包含三个模块。</p>
<ul>
<li>通用(common)模块：包含非特定于任何平台的代码，以及不附带依赖于平台的 API 实现的声明。</li>
<li>平台(platform)模块：包含用于特定平台的通用模块中与平台相关声明的实现，以及其他平台相关代码。</li>
<li>常规(regular)模块：针对特定平台，可以是平台模块的某些依赖，也可以是依赖的平台模块。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171230104621276" alt="这里写图片描述"><br>要从通用模块中调用特定于平台的代码，可以指定所需的声明：所有特定于平台的模块需要提供实际实现声明。而在为特定平台编译多平台项目时，会生成通用及特定平台相关部分的代码。可以通过 expected 以及 actual 声明来表达通用代码对平台特定部分的依赖关系。expected 声明指定了一个 API（类、接口、注释、顶层声明等）。actual 声明或是 API 的平台相关实现，或是在外部库中 API 现有实现的别名引用。下面是官方提供的相关例子：</p>
<p><strong>通用模块</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// expected platform-specific API:</div><div class="line">expect fun hello(world: String): String</div><div class="line"></div><div class="line">fun greet() &#123;</div><div class="line">    // usage of the expected API:</div><div class="line">    val greeting = hello(&quot;multi-platform world&quot;)</div><div class="line">    println(greeting)</div><div class="line">&#125;</div><div class="line"></div><div class="line">expect class URL(spec: String) &#123;</div><div class="line">    open fun getHost(): String</div><div class="line">    open fun getPath(): String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>JVM 平台代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actual fun hello(world: String): String =</div><div class="line">    &quot;Hello, $world, on the JVM platform!&quot;</div><div class="line"></div><div class="line">// using existing platform-specific implementation:</div><div class="line">actual typealias URL = java.net.URL</div></pre></td></tr></table></figure>
<p>想要获取更多跨平台相关的信息，可以查看<a href="http://kotlinlang.org/docs/reference/multiplatform.html" target="_blank" rel="external">官方资料</a>介绍。</p>
<p><strong>请注意，目前跨平台项目只是一个实验性功能，这意味着该功能已经可以使用，但可能需要在后续版本中更改设计</strong></p>
<h1 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h1><p>在1.2的开发过程中，团队花了很多精力来优化编译系统，据官方提供的资料显示，与Kotlin 1.1相比，Kotlin带来了大约25％的性能提升，并且看到了可以进一步改进的巨大潜力，这些改进将在1.2.x更新中发布。<br>下图显示了使用Kotlin构建两个大型JetBrains项目的编译时间差异。<br><img src="http://img.blog.csdn.net/20171230105535210" alt="这里写图片描述"></p>
<h1 id="语法与库优化"><a href="#语法与库优化" class="headerlink" title="语法与库优化"></a>语法与库优化</h1><p>除了上面介绍的改动之外，Kotlin还在语法层面进行了部分改进，优化的部分有。</p>
<h2 id="通过注解声明数组变量"><a href="#通过注解声明数组变量" class="headerlink" title="通过注解声明数组变量"></a>通过注解声明数组变量</h2><p>自Kotlin1.2开始，系统允许通过注解声明数组参数，从而取代arrayOf函数的数组声明方式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@CacheConfig(cacheNames = [&quot;books&quot;, &quot;default&quot;])</div><div class="line">public class BookRepositoryImpl &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，新的数组参数声明语法依赖于注解方式。</p>
<h2 id="关键字lateinit"><a href="#关键字lateinit" class="headerlink" title="关键字lateinit"></a>关键字lateinit</h2><p>lateinit 和lazy一样，是 Kotlin中的两种不同的延迟初始化技术。在Kotlin1.2版本中，使用lateinit修饰符能够用于全局变量和局部变量了，也就是说，二者都允许延迟初始化。例如，当lambda表达式在构造一个对象时，允许将延迟初始化属性作为构造参数传过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Node&lt;T&gt;(val value: T, val next: () -&gt; Node&lt;T&gt;)</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    // A cycle of three nodes:</div><div class="line">    lateinit var third: Node&lt;Int&gt;</div><div class="line"></div><div class="line">    val second = Node(2, next = &#123; third &#125;)</div><div class="line">    val first = Node(1, next = &#123; second &#125;)</div><div class="line"></div><div class="line">    third = Node(3, next = &#123; first &#125;)</div><div class="line"></div><div class="line">    </div><div class="line">    val nodes = generateSequence(first) &#123; it.next() &#125;</div><div class="line">    println(&quot;Values in the cycle: $&#123;nodes.take(7).joinToString &#123; it.value.toString() &#125;&#125;, ...&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Values in the cycle: 1, 2, 3, 1, 2, 3, 1, ...</div></pre></td></tr></table></figure>
<h2 id="延迟初始化属性检测"><a href="#延迟初始化属性检测" class="headerlink" title="延迟初始化属性检测"></a>延迟初始化属性检测</h2><p>通过访问属性的isInitialized字段，现在开发者可以检查一个延迟初始化属性是否已经初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    lateinit var lateinitVar: String</div><div class="line">    </div><div class="line">    fun initializationLogic() &#123;</div><div class="line">        println(&quot;isInitialized before assignment: &quot; + this::lateinitVar.isInitialized)</div><div class="line">        lateinitVar = &quot;value&quot;</div><div class="line">        println(&quot;isInitialized after assignment: &quot; + this::lateinitVar.isInitialized)    </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	Foo().initializationLogic()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">isInitialized before assignment: false</div><div class="line">isInitialized after assignment: true</div></pre></td></tr></table></figure>
<h2 id="内联函数默认参数"><a href="#内联函数默认参数" class="headerlink" title="内联函数默认参数"></a>内联函数默认参数</h2><p>自1.2版本开始，Kotlin允许允许给内联函数的函数参数填写默认参数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;E&gt; Iterable&lt;E&gt;.strings(transform: (E) -&gt; String = &#123; it.toString() &#125;) = </div><div class="line">map &#123; transform(it) &#125;</div><div class="line"></div><div class="line">val defaultStrings = listOf(1, 2, 3).strings()</div><div class="line">val customStrings = listOf(1, 2, 3).strings &#123; &quot;($it)&quot; &#125; </div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;defaultStrings = $defaultStrings&quot;)</div><div class="line">    println(&quot;customStrings = $customStrings&quot;)</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaultStrings = [1, 2, 3]</div><div class="line">customStrings = [(1), (2), (3)]</div></pre></td></tr></table></figure>
<h2 id="变量类型推断"><a href="#变量类型推断" class="headerlink" title="变量类型推断"></a>变量类型推断</h2><p>大家都知道，Kotlin的类型推断系统是非常强大的，现在Kotlin编译器也支持通过强制转换的信息，来推断出变量类型了。比如说，如果你在调用一个返回“T”的泛型方法时，并将它的返回值“T”转换为特定类型如“Foo”，编译器就会推断出这个方法调用中的“T”其实是“Foo”类型。</p>
<p>这个对安卓开发者而言尤其重要，因为自从API26（Android7.0）开始，findViewById变成了泛型方法，然后编译器也会正确分析该方法的调用返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val button = findViewById(R.id.button) as Button</div></pre></td></tr></table></figure></p>
<h2 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h2><p>当一个变量为某个安全表达式（如校验非空）所赋值时，智能转换也同样运用于这个安全调用的接收者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fun countFirst(s: Any): Int &#123;</div><div class="line">    val firstChar = (s as? CharSequence)?.firstOrNull()</div><div class="line">    if (firstChar != null)</div><div class="line">    return s.count &#123; it == firstChar &#125; // 输入参数s被智能转换为CharSequence类型</div><div class="line"></div><div class="line">    val firstItem = (s as? Iterable&lt;*&gt;)?.firstOrNull()</div><div class="line">    if (firstItem != null)</div><div class="line">    return s.count &#123; it == firstItem &#125; // 输入参数s被智能转换为Iterable&lt;*&gt;类型  </div><div class="line"></div><div class="line">    </div><div class="line">    return -1</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val string = &quot;abacaba&quot;</div><div class="line">    val countInString = countFirst(string)</div><div class="line">    println(&quot;called on \&quot;$string\&quot;: $countInString&quot;)</div><div class="line">    </div><div class="line">    val list = listOf(1, 2, 3, 1, 2)</div><div class="line">    val countInList = countFirst(list)</div><div class="line">    println(&quot;called on $list: $countInList&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">called on &quot;abacaba&quot;: 4</div><div class="line">called on [1, 2, 3, 1, 2]: 2</div></pre></td></tr></table></figure>
<p>另外，Lamba表达式同样支持对局部变量进行智能转换，前提是该局部变量只在Lamba表达式之前修改过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val flag = args.size == 0</div><div class="line">    </div><div class="line">    var x: String? = null</div><div class="line">    if (flag) x = &quot;Yahoo!&quot;</div><div class="line"></div><div class="line">    run &#123;</div><div class="line">        if (x != null) &#123;</div><div class="line">            println(x.length) // x is smart cast to String</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br>6</p>
<h2 id="foo的简写"><a href="#foo的简写" class="headerlink" title="foo的简写"></a>foo的简写</h2><p>为了简化调用成员的引用，现在可以不用this关键字，::foo而不用明确的接收者this::foo。这也使得可调用的引用在你引用外部接收者的成员的lambda中更方便。</p>
<h1 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h1><p>Kotlin1.2版本也弃用了很多不合理的东西。</p>
<h2 id="弃用：枚举条目中的嵌套类型"><a href="#弃用：枚举条目中的嵌套类型" class="headerlink" title="弃用：枚举条目中的嵌套类型"></a>弃用：枚举条目中的嵌套类型</h2><p>在枚举条目中，inner class由于初始化逻辑中的问题，定义一个非嵌套的类型已经被弃用了。这会在Kotlin 1.2中引起警告，并将在Kotlin 1.3中出错。</p>
<h2 id="弃用：vararg单个命名参数"><a href="#弃用：vararg单个命名参数" class="headerlink" title="弃用：vararg单个命名参数"></a>弃用：vararg单个命名参数</h2><p>为了与注释中的数组文字保持一致，在命名形式（foo(items = i)）中传递可变参数的单个项目已被弃用。请使用具有相应数组工厂功能的扩展运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(items = *intArrayOf(1))</div></pre></td></tr></table></figure>
<p>在这种情况下，有一种优化可以消除冗余阵列的创建，从而防止性能下降。单参数形式在Kotlin 1.2中产生警告，并将被放在Kotlin 1.3中。</p>
<h2 id="弃用：扩展Throwable的泛型内部类"><a href="#弃用：扩展Throwable的泛型内部类" class="headerlink" title="弃用：扩展Throwable的泛型内部类"></a>弃用：扩展Throwable的泛型内部类</h2><p>继承的泛型类型的内部类Throwable可能会违反类型安全性，因此已被弃用，Kotlin 1.2中有警告，Kotlin 1.3中有错误。</p>
<h2 id="弃用：只读属性的后台字段"><a href="#弃用：只读属性的后台字段" class="headerlink" title="弃用：只读属性的后台字段"></a>弃用：只读属性的后台字段</h2><p>field = …已经废弃了在自定义获取器中分配只读属性的后台字段，Kotlin 1.2中有警告，Kotlin 1.3中有错误。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Kotlin标准库与拆分包"><a href="#Kotlin标准库与拆分包" class="headerlink" title="Kotlin标准库与拆分包"></a>Kotlin标准库与拆分包</h2><p>Kotlin标准库现在完全兼容Java 9模块系统，该系统禁止拆分包（多个jar文件在同一个包中声明类）。为了支持这一点，新的文物kotlin-stdlib-jdk7 和kotlin-stdlib-jdk8介绍，取代旧的kotlin-stdlib-jre7和kotlin-stdlib-jre8。</p>
<p>为确保与新模块系统的兼容性，Kotlin做出的另一个更改是将kotlin.reflect从kotlin-reflect库中移除。如果您正在使用它们，则需要切换到使用kotlin.reflect.full软件包中的声明，这是自Kotlin 1.1以来支持的声明。</p>
<h2 id="窗口，分块，zipWithNext"><a href="#窗口，分块，zipWithNext" class="headerlink" title="窗口，分块，zipWithNext"></a>窗口，分块，zipWithNext</h2><p>为新的扩展Iterable<t>，Sequence<t>以及CharSequence覆盖这些用例如缓冲或批处理（chunked），滑动窗口和计算滑动平均（windowed），和随后的项目的处理对（zipWithNext）。</t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = (1..9).map &#123; it * it &#125;</div><div class="line"></div><div class="line">    val chunkedIntoLists = items.chunked(4)</div><div class="line">    val points3d = items.chunked(3) &#123; (x, y, z) -&gt; Triple(x, y, z) &#125;</div><div class="line">    val windowed = items.windowed(4)</div><div class="line">    val slidingAverage = items.windowed(4) &#123; it.average() &#125;</div><div class="line">    val pairwiseDifferences = items.zipWithNext &#123; a, b -&gt; b - a &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    println(&quot;items: $items\n&quot;)</div><div class="line">    </div><div class="line">    println(&quot;chunked into lists: $chunkedIntoLists&quot;)</div><div class="line">    println(&quot;3D points: $points3d&quot;)</div><div class="line">    println(&quot;windowed by 4: $windowed&quot;)</div><div class="line">    println(&quot;sliding average by 4: $slidingAverage&quot;)</div><div class="line">    println(&quot;pairwise differences: $pairwiseDifferences&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="fill-replaceAll-shuffle-shuffled"><a href="#fill-replaceAll-shuffle-shuffled" class="headerlink" title="fill, replaceAll, shuffle/shuffled"></a>fill, replaceAll, shuffle/shuffled</h2><p>为了操纵列表，Kotlin加入了一组扩展函数：fill，replaceAll和shuffle对MutableList，shuffled用于只读List。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = (1..5).toMutableList()</div><div class="line"></div><div class="line">    items.shuffle()</div><div class="line">    println(&quot;Shuffled items: $items&quot;)</div><div class="line"></div><div class="line">    items.replaceAll &#123; it * 2 &#125;</div><div class="line">    println(&quot;Items doubled: $items&quot;)</div><div class="line"></div><div class="line">    items.fill(5)</div><div class="line">    println(&quot;Items filled with 5: $items&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br>Shuffled items: [5, 3, 1, 2, 4]<br>Items doubled: [10, 6, 2, 4, 8]<br>Items filled with 5: [5, 5, 5, 5, 5]</p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>为了满足一些特殊的需求，Kotlin 1.2添加了一些常见的数学运算API。</p>
<ul>
<li>常量：PI和E;</li>
<li>三角函数：cos，sin，tan和它们的反：acos，asin，atan，atan2，</li>
<li>双曲：cosh，sinh，tanh和它们的反：acosh，asinh，atanh</li>
<li>求幂：pow（扩展函数），sqrt，，hypot ;expexpm1</li>
<li>对数：log，log2，log10，ln，ln1p，</li>
<li>四舍五入： ceil，floor，truncate，round（半连）的功能;<br>roundToInt，roundToLong（半整数）扩展函数;</li>
<li>符号和绝对值： abs和sign功能; absoluteValue和sign扩展属性; withSign 扩展功能;max和min两个价值观;</li>
<li>二进制表示： ulp 扩展属性; nextUp，nextDown，nextTowards扩展函数;toBits，toRawBits，Double.fromBits（这些是在kotlin包）。</li>
</ul>
<h2 id="正则表达式可序列化"><a href="#正则表达式可序列化" class="headerlink" title="正则表达式可序列化"></a>正则表达式可序列化</h2><p>现在，Kotlin可以使用Serializable来序列化正则表达式的层次结构。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="构造函数调用规范化"><a href="#构造函数调用规范化" class="headerlink" title="构造函数调用规范化"></a>构造函数调用规范化</h2><p>自1.0版以来，Kotlin支持复杂控制流的表达式，例如try-catch表达式和内联函数调用。但是，如果构造函数调用的参数中存在这样的表达式时，一些字节码处理工具不能很好地处理这些代码。为了缓解这种字节码处理工具的用户的这个问题，我们添加了一个命令行选项（-Xnormalize-constructor-calls=MODE），它告诉编译器为这样的结构生成更多的类Java字节码。</p>
<p>其中，这里的MODE有以下情况：</p>
<ul>
<li>disable （默认） - 以和Kotlin 1.0和1.1相同的方式生成字节码;</li>
<li>enable - 为构造函数调用生成类似Java的字节码。这可以改变类加载和初始化的顺序;</li>
<li>preserve-class-initialization -为构造函数调用生成类似Java的字节码，确保保持类的初始化顺序。这可能会影响应用程序的整体性能;只有在多个类之间共享一些复杂的状态并在类初始化时更新时才使用它。</li>
</ul>
<h2 id="Java默认方法调用"><a href="#Java默认方法调用" class="headerlink" title="Java默认方法调用"></a>Java默认方法调用</h2><p>在Kotlin 1.2之前，接口成员在针对JVM 1.6的情况下重写Java默认方法会在超级调用上产生一个警告：Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with ‘-jvm-target 1.8’。在Kotlin 1.2中，会出现一个错误，因此需要使用JVM target 1.8来编译这些代码。</p>
<h2 id="x-equals（null）"><a href="#x-equals（null）" class="headerlink" title="x.equals（null）"></a>x.equals（null）</h2><p>调用x.equals(null)上被映射到Java原始（平台类型Int!，Boolean!，Short！， ，Long!，Float!，Double!）Char!返回不正确true时x为空。从Kotlin 1.2开始，调用x.equals(…)一个平台类型的null值会抛出一个NPE （但是x == …不会）。</p>
<p>要返回到1.2之前的行为，请将该标志传递-Xno-exception-on-explicit-equals-for-boxed-null给编译器。</p>
<h2 id="内联扩展空修复"><a href="#内联扩展空修复" class="headerlink" title="内联扩展空修复"></a>内联扩展空修复</h2><p>在以前的版本中，在平台类型的空值上调用的内联扩展函数没有检查接收器是否为null，并因此允许null转义到其他代码中。Kotlin 1.2中强制执行此检查，如果接收方为空，则抛出异常。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="TypedArrays支持"><a href="#TypedArrays支持" class="headerlink" title="TypedArrays支持"></a>TypedArrays支持</h2><p>JS类型的数组支持将Kotlin原始数组（例如IntArray，DoubleArray）转换为JavaScript类型的数组，这以前是可选入功能，默认情况下已启用。</p>
<p>除此之外，Kotlin的编译器现在提供一个将所有警告视为错误的选项。使用-Werror命令行，或者修改如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compileKotlin &#123;</div><div class="line">    kotlinOptions.allWarningsAsErrors = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要了解更多的官方知识介绍，请查看：<a href="http://kotlinlang.org/docs/reference/whatsnew12.html" target="_blank" rel="external">Kotlin 1.2带来了什么新特性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Kotlin 1.1中，团队正式发布了JavaScript目标，允许开发者将Kotlin代码编译为JS并在浏览器中运行。在Kotlin 1.2中，团队增加了在JVM和JavaScript之间重用代码的可能性。现在，使用Kotlin编写的代码，可以在所有的应用程序中（包括后
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>React Native 0.50版本新功能简介</title>
    <link href="http://www.xiangzhihong.com/2017/10/27/React%20Native%200.50%E7%89%88%E6%9C%AC%E6%96%B0%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2017/10/27/React Native 0.50版本新功能简介/</id>
    <published>2017-10-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:18:43.835Z</updated>
    
    <content type="html"><![CDATA[<p>React Native在2017年经历了众多版本的迭代，从本人接触的0.29版本开始，到前不久发布的0.52版本，React Native作为目前最受欢迎的移动跨平台方案。虽然，目前存在着很多的功能和性能的缺失，但是不可否认的是React Native确实在进步。</p>
<p>本文主要从以下几个方面来对React Native0.50+进行讲解：</p>
<ul>
<li>在兼容性方面新增了对Android8.0、iPhone X的支持；</li>
<li>在API方面为TimePicker添加了打开方式的API，另外允许在构建Android项目的时候指定applicationId;</li>
<li>在组件方面，新添加了支持侧滑显示菜单的SwipeableFlatList，以及SafeAreaView。</li>
<li>修复了一些关键性的Bug；</li>
</ul>
<h2 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h2><p>React Native 0.50版本中 Image组件迎来了比较大的一个特性的改变，即在React Native 0.50及以上版本中Image不在支持包裹内容。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Image style=</div><div class="line">       resizeMode=&quot;center&quot;</div><div class="line">       source=&gt;</div><div class="line">    &lt;Text&gt;《React Native移动开发实战》&lt;/Text&gt;</div><div class="line">&lt;/Image&gt;</div></pre></td></tr></table></figure>
<p>以上代码在0.50之前是可以正常运行的，在0.50上运行会报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unhandled JS Exception: Error: The &lt;Image&gt; component cannot contain children. If you want to render content on top of the image, consider using aboslute positioning.</div></pre></td></tr></table></figure>
<p>如果要在0.50+版本中使用Image组件，可以按照下面的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Image style=</div><div class="line">       resizeMode=&quot;center&quot;</div><div class="line">       source=/&gt;</div><div class="line"> &lt;Text&gt;《React Native移动开发实战》&lt;/Text&gt;</div></pre></td></tr></table></figure>
<h2 id="其他重大变更"><a href="#其他重大变更" class="headerlink" title="其他重大变更"></a>其他重大变更</h2><ol>
<li>ReactShadowNode由类被抽象成了接口，代替他的是ReactShadowNodeImpl，这是来自底层的变更，对上层API无影响。</li>
<li><p>enableBabelRCLookup(启用BabelRCL查找)，由原来的默认开启改为了默认关闭，改过之后Metro只会关注项目的.babelrc文件。在之前Metro会关注node_modules下的.babelrc文件，这样将会导致一些问题，因为它没有Babel的版本，也没有node_modules/randompackage/.babelrc所需的plugins/presets。现在，从0.50版本之后getEnableBabelRCLookup默认返回false，从而避免了这一问题。如果你不想使用这一改变，那么可以这样配置：</p>
<p>创建一个rn-cli.config.js文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    getEnableBabelRCLookup() &#123;</div><div class="line">      return true;</div><div class="line">    &#125;,</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>   然后，在node_modules下修改.babelrc :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;plugins&quot;: [&quot;dummy&quot;]&#125;</div></pre></td></tr></table></figure>
<h1 id="修复的系统bug"><a href="#修复的系统bug" class="headerlink" title="修复的系统bug"></a>修复的系统bug</h1><p>在0.50版本中，修复的系统bug有：</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1，修复了在Android SDK 15及以下版本设置背景的Bug。在Android中设置View的背景在SDK15及以下和以上和的API是不一样的，在之前的RN版本中没有做差异判断，所以会导致在低版本设置背景的Bug，在0.50及以上版本底层实现上添加了ViewHelper工具类，当设置背景时会根据当前SDK版本是16及以上或以下进行做不同的处理；</p>
<p>处理的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ViewHelper &#123;</div><div class="line"> public static void setBackground(View view, Drawable drawable&#123; </div><div class="line"> if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; </div><div class="line"> view.setBackground(drawable); </div><div class="line"> &#125; else &#123; </div><div class="line"> view.setBackgroundDrawable(drawable);</div><div class="line">    &#125; </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2，修复了slider的minimumTrackTintColor 和 maximumTrackTintColor在Android和iOS上颜色颠倒的问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Slider</div><div class="line">    style=</div><div class="line">    minimumTrackTintColor=&quot;red&quot;</div><div class="line">    maximumTrackTintColor=&quot;blue&quot;</div><div class="line">  /&gt;</div></pre></td></tr></table></figure>
<p> 显示效果如下：</p>
<p>  <img src="http://img.blog.csdn.net/20180122140350603" alt="这里写图片描述"></p>
<p> 3，修复了Android 4.1-4.3 WebView的Bug。</p>
<p>在0.50之前的版本当使用WebView的baseUrl时在Android 4.1-4.3会显示出html源码，这是因为在Android 4.1-4.3中WebView不支持text/html的charset=utf-8的MIME type所导致的。</p>
<p>4，修复了View Style的overflow hidden问题。</p>
<p>很久以来overflow样式在Android默认为hidden而且无法更改。Android的overflow:hidden还有另外一个问题：如果父容器有borderRadius圆角边框样式，那么即便开启了overflow:hidden也仍然无法把子视图超出圆角边框的部分裁切掉。</p>
<p>5，修复了Java到C++到JS ViewManagers的交互问题；</p>
<p>6，修复了DeviceIdentity(设备标识)；</p>
<h2 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h2><p>修复了React/RCTJavascriptLoader.mm的Content-Type检查问题，在之前RCTJavascriptLoader对Content-Type的支持是有缺陷的，只能匹配application/javascript或text/javascript两种类型，现在的做法是Content-Type对以application/javascript或text/javascript开头的Content-Type都可以支持；</p>
<h1 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h1><p>0.50版本新增了很多的功能，本文只针对某些重点进行讲解，详细的还请阅读官方资料。通用的功能有：</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul>
<li>新增SwipeableFlatList组件，SwipeableFlatList是在FlatList的基础上添加了侧滑显示菜单的功能，类似于侧滑删除的效果。我们知道SwipeableListView，是React Native 0.27上添加的一个支持侧滑显示菜单的ListView，不过ListView已经不推荐使用了。</li>
<li>引入SafeAreaView，SafeAreaView用于包裹其他View，它会自动应用填充布局中不足的一部分，但不包括navigation bars, tab bars, toolbars等视图。</li>
</ul>
<h2 id="Android-1"><a href="#Android-1" class="headerlink" title="Android"></a>Android</h2><h3 id="TimePicker"><a href="#TimePicker" class="headerlink" title="TimePicker"></a>TimePicker</h3><p>TimePicker添加了mode (enum(‘clock’, ‘spinner’, ‘default’)) 来控制TimePicker的打开模式。</p>
<p>TimePicker是一个老的API了，通过TimePicker组件可以打开Android原生的时间选择对话框。Android 5以下的设备只支持spinner模式，Android 5及以上设备支持clock, spinner两种模式：<br><strong>Android &lt; 5的显示方式如下：</strong><br><img src="http://img.blog.csdn.net/20180122141758669" alt="这里写图片描述"></p>
<p><strong>Android &gt; 5的显示方式如下：</strong><br><img src="http://img.blog.csdn.net/20180122141904138" alt="这里写图片描述"></p>
<h3 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h3><p>运行在构建的时候指定Android App的applicationId(Android应用的身份ID，应用的唯一标识)；</p>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>Added Android support for loading multiple RAM bundles。</p>
<h2 id="iOS方面"><a href="#iOS方面" class="headerlink" title="iOS方面"></a>iOS方面</h2><h3 id="DeviceInfo"><a href="#DeviceInfo" class="headerlink" title="DeviceInfo"></a>DeviceInfo</h3><p>DeviceInfo 新增DeviceInfo.isIPhoneX_deprecatedAPI来供开发者判断当前设备是不是iPhone X，带有小刘海的iPhone X的屏幕比其他iPhone 手机的屏幕拥有更大高度，所以对于界面布局来说，在iPhone X上需要特别适配。<br>DeviceInfo是React Native 0.44新增一个类专门提供屏幕尺寸，字体缩放等信息。</p>
<h3 id="Modal组件"><a href="#Modal组件" class="headerlink" title="Modal组件"></a>Modal组件</h3><p>Modal组件新增支持onDismiss属性，这个onDismiss接受一个function，当Modal关闭的时候会回调onDismiss。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Modal</div><div class="line">   onDismiss=&#123;()=&gt;&#123;</div><div class="line">     console.log(&quot;Modal is dismiss&quot;);</div><div class="line">      &#125;</div><div class="line">      &#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<p>除了上面介绍的更新内容之外，还有很多的东西，这里就不再介绍，大家可以到<a href="http://reactnative.cn/" target="_blank" rel="external">RN中文网</a>查看相关最新知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React Native在2017年经历了众多版本的迭代，从本人接触的0.29版本开始，到前不久发布的0.52版本，React Native作为目前最受欢迎的移动跨平台方案。虽然，目前存在着很多的功能和性能的缺失，但是不可否认的是React Native确实在进步。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>RxJs简介</title>
    <link href="http://www.xiangzhihong.com/2017/10/23/RxJs%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2017/10/23/RxJs简介/</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:15:42.543Z</updated>
    
    <content type="html"><![CDATA[<p>这两年，各种异步编程框架，上面RxJava,RxAndroid,RxSwift等等，今天要聊的是RxJs，对于我等入门不久的前端工程师来说，这个框架还是比较有新颖的，中文官网地址：<a href="http://cn.rx.js.org/" target="_blank" rel="external">http://cn.rx.js.org/</a></p>
<h2 id="RxJs简介"><a href="#RxJs简介" class="headerlink" title="RxJs简介"></a>RxJs简介</h2><p>RxJS是一个异步编程的库，同时它通过observable序列来实现基于事件的编程。它提供了一个核心的类型：Observable，几个辅助类型（Observer，Schedulers，Subjects），受到Array的扩展操作（map，filter，reduce，every等等）启发，允许直接处理异步事件的集合。</p>
<p>ReactiveX结合了Observer模式、Iterator模式和函数式编程和集合来构建一个管理事件序列的理想方式。在RxJS中管理异步事件的基本概念中有以下几点需要注意：</p>
<ul>
<li><strong>Observable</strong>：代表了一个调用未来值或事件的集合的概念</li>
<li><strong>Observer</strong>：代表了一个知道如何监听Observable传递过来的值的回调集合</li>
<li><strong>Subscription</strong>：代表了一个可执行的Observable，主要是用于取消执行</li>
<li><strong>Operators</strong>：是一个纯函数，允许处理集合与函数式编程风格的操作，比如map、filter、concat、flatMap等</li>
<li><strong>Subject</strong>：相当于一个EventEmitter，它的唯一的方法是广播一个值或事件给多个Observer</li>
<li><strong>Schedulers</strong>：是一个集中式调度程序来控制并发性，允许我们在setTimeout或者requestAnimationFrame上进行协调计算</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>正常情况下，注册一个事件监听函数的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;Clicked!&apos;));</div></pre></td></tr></table></figure>
<p>使用RxJS，你可以创建一个observable来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .subscrible(() =&gt; console.log(&apos;Clicked!&apos;));</div></pre></td></tr></table></figure>
<h2 id="纯净性-Purity"><a href="#纯净性-Purity" class="headerlink" title="纯净性 (Purity)"></a>纯净性 (Purity)</h2><p>使得RxJS变得如此强大的原因是它使用了纯函数，这意味着你的代码很少会发生错误。正常情况下，你不会选择创建一个纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; console.log(`Clicked $(++count) times`));</div></pre></td></tr></table></figure>
<p>而在RxJs中却可以大量使用纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .scan(count =&gt; count + 1, 0)</div><div class="line">  .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; items`));</div></pre></td></tr></table></figure>
<p>其中，scan操作符类似于arrays的reduce操作符。它需要一个回调函数作为一个参数，函数返回的值将作为下次调用时的参数。</p>
<h2 id="流动性-Flow"><a href="#流动性-Flow" class="headerlink" title="流动性 (Flow)"></a>流动性 (Flow)</h2><p>RxJS 提供了一整套操作符来帮助你控制事件如何流经 observables 。<br>下面的代码展示的是如何控制一秒钟内最多点击一次，先来看使用普通的 JavaScript：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var rate = 1000;</div><div class="line">var lastClick = Date.now() - rate;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; &#123;</div><div class="line">  if (Date.now() - lastClick &gt;= rate) &#123;</div><div class="line">    console.log(`Clicked $&#123;++count&#125; times`);</div><div class="line">    lastClick = Date.now();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 RxJS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .throttleTime(1000)</div><div class="line">  .scan(count =&gt; count + 1, 0)</div><div class="line">  .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</div></pre></td></tr></table></figure>
<p>其他流程控制操作符有 filter、delay、debounceTime、take、takeUntil、distinct、distinctUntilChanged 等等。</p>
<h2 id="值-Values"><a href="#值-Values" class="headerlink" title="值 (Values)"></a>值 (Values)</h2><p>对于流经 observables 的值，你可以对其进行转换。<br>下面的代码展示的是如何累加每次点击的鼠标 x 坐标，先来看使用普通的 JavaScript：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var rate = 1000;</div><div class="line">var lastClick = Date.now() - rate;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, (event) =&gt; &#123;</div><div class="line">  if (Date.now() - lastClick &gt;= rate) &#123;</div><div class="line">    count += event.clientX;</div><div class="line">    console.log(count)</div><div class="line">    lastClick = Date.now();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 RxJS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .throttleTime(1000)</div><div class="line">  .map(event =&gt; event.clientX)</div><div class="line">  .scan((count, clientX) =&gt; count + clientX, 0)</div><div class="line">  .subscribe(count =&gt; console.log(count));</div></pre></td></tr></table></figure>
<p>其他产生值的操作符有 pluck、pairwise、 sample 等等。</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>Observables 是多个值的惰性推送集合。它填补了下面表格中的空白：</p>
<table><br>        <tr><br>            <th>行为</th><br>            <th>单个值</th><br>            <th>多个值</th><br>        </tr><br>         <tr><br>            <th>拉取</th><br>            <th>Function</th><br>            <th>Iterator</th><br>        </tr><br>         <tr><br>            <th>推送</th><br>            <th>Promise</th><br>            <th>Observable</th><br>        </tr><br></table>

<p>例如：当订阅下面代码中的 Observable 的时候会立即(同步地)推送值1、2、3，然后1秒后会推送值4，再然后是完成流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(4);</div><div class="line">    observer.complete();</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>要调用 Observable 并看到这些值，我们需要订阅 Observable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(4);</div><div class="line">    observer.complete();</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(&#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>控制台执行的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">just before subscribe</div><div class="line">got value 1</div><div class="line">got value 2</div><div class="line">got value 3</div><div class="line">just after subscribe</div><div class="line">got value 4</div><div class="line">done</div></pre></td></tr></table></figure>
<h2 id="拉取-Pull-vs-推送-Push"><a href="#拉取-Pull-vs-推送-Push" class="headerlink" title="拉取 (Pull) vs. 推送 (Push)"></a>拉取 (Pull) vs. 推送 (Push)</h2><p>拉取和推送是两种不同的协议，用来描述数据生产者 (Producer)如何与数据消费者 (Consumer)如何进行通信的。</p>
<p>什么是拉取？ - 在拉取体系中，由消费者来决定何时从生产者那接收数据。生产者本身不知道数据是何时交付到消费者手中的。</p>
<p>每个 JavaScript 函数都是拉取体系。函数是数据的生产者，调用该函数的代码通过从函数调用中“取出”一个单个返回值来对该函数进行消费。</p>
<p>ES2015 引入了 generator 函数和 iterators (function*)，这是另外一种类型的拉取体系。调用 iterator.next() 的代码是消费者，它会从 iterator(生产者) 那“取出”多个值。</p>
<table><br>        <tr><br>            <th>行为</th><br>            <th>生产者</th><br>            <th>消费者</th><br>        </tr><br>         <tr><br>            <th>拉取</th><br>            <th>被动的: 当被请求时产生数据。</th><br>            <th>主动的: 决定何时请求数据。</th><br>        </tr><br>         <tr><br>            <th>推送</th><br>            <th>主动的: 按自己的节奏产生数据。</th><br>            <th>被动的: 对收到的数据做出反应。</th><br>        </tr><br></table>

<p>什么是推送？ - 在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据。</p>
<p>在当今的 JavaScript 世界中，Promises 是最常见的推送体系类型。Promise(生产者) 将一个解析过的值传递给已注册的回调函数(消费者)，但不同于函数的是，由 Promise 来决定何时把值“推送”给回调函数。</p>
<p>RxJS 引入了 Observables，一个新的 JavaScript 推送体系。Observable 是多个值的生产者，并将值“推送”给观察者(消费者)。</p>
<ul>
<li><strong>Function</strong> 是惰性的评估运算，调用时会同步地返回一个单一值。</li>
<li><strong>Generator</strong> 是惰性的评估运算，调用时会同步地返回零到(有可能的)无限多个值。</li>
<li><strong>Promise</strong> 是最终可能(或可能不)返回单个值的运算。</li>
<li><strong>Observable</strong> 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到(有可能的)无限多个值。</li>
</ul>
<h2 id="Observables-作为函数的泛化"><a href="#Observables-作为函数的泛化" class="headerlink" title="Observables 作为函数的泛化"></a>Observables 作为函数的泛化</h2><p>与流行的说法正好相反，Observables 既不像 EventEmitters，也不像多个值的 Promises 。在某些情况下，即当使用 RxJS 的 Subjects 进行多播时， Observables 的行为可能会比较像 EventEmitters，但通常情况下 Observables 的行为并不像 EventEmitters 。</p>
<p>考虑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  return 42;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var x = foo.call(); // 等同于 foo()</div><div class="line">console.log(x);</div><div class="line">var y = foo.call(); // 等同于 foo()</div><div class="line">console.log(y);</div></pre></td></tr></table></figure>
<p>我们期待看到的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div></pre></td></tr></table></figure>
<p>可以使用 Observables 重写上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">foo.subscribe(function (y) &#123;</div><div class="line">  console.log(y);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div></pre></td></tr></table></figure>
<p>这是因为函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。<br>一些人声称 Observables 是异步的。那不是真的。如果你用日志包围一个函数调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;before&apos;);</div><div class="line">console.log(foo.call());</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;after&quot;</div></pre></td></tr></table></figure>
<p>使用 Observables 来做同样的事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>这证明了 foo 的订阅完全是同步的，就像函数一样。那么 Observable 和 函数的区别是什么呢？Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  return 42;</div><div class="line">  return 100; // 死代码，永远不会执行</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数只能返回一个值。但 Observables 可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">  observer.next(100); // “返回”另外一个值</div><div class="line">  observer.next(200); // 还可以再“返回”值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">100</div><div class="line">200</div><div class="line">&quot;after&quot;</div></pre></td></tr></table></figure>
<p>同时，你还可以异步地“返回”值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">  observer.next(100);</div><div class="line">  observer.next(200);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(300); // 异步执行</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">100</div><div class="line">200</div><div class="line">&quot;after&quot;</div><div class="line">300</div></pre></td></tr></table></figure>
<p>结论:</p>
<p>func.call() 意思是 “同步地给我一个值”</p>
<p>observable.subscribe() 意思是 “给我任意数量的值，无论是同步还是异步”。</p>
<h1 id="Observable-剖析"><a href="#Observable-剖析" class="headerlink" title="Observable 剖析"></a>Observable 剖析</h1><p>Observables 是使用 Rx.Observable.create 或创建操作符创建的，并使用观察者来订阅它，然后执行它并发送 next / error / complete 通知给观察者，而且执行可能会被清理。这四个方面全部编码在 Observables 实例中，但某些方面是与其他类型相关的，像 Observer (观察者) 和 Subscription (订阅)。</p>
<p>Observable 的核心有4点：</p>
<ul>
<li>创建 Observables</li>
<li>订阅 Observables</li>
<li>执行 Observables</li>
<li>清理 Observables</li>
</ul>
<h2 id="创建-Observables"><a href="#创建-Observables" class="headerlink" title="创建 Observables"></a>创建 Observables</h2><p>Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数。下面的示例创建了一个 Observable，它每隔一秒会向观察者发送字符串 ‘hi’ 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  var id = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;)</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Observables 可以使用 create 来创建, 但通常我们使用所谓的创建操作符, 像 of、from、interval、等等。在上面的示例中，subscribe 函数是用来描述 Observable 最重要的一块。我们来看下订阅是什么意思。</p>
<h2 id="订阅-Observables"><a href="#订阅-Observables" class="headerlink" title="订阅 Observables"></a>订阅 Observables</h2><p>示例中的 Observable 对象 observable 可以订阅，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>observable.subscribe 和 Observable.create(function subscribe(observer) {…}) 中的 subscribe 有着同样的名字，这并不是一个巧合。在库中，它们是不同的，但从实际出发，你可以认为在概念上它们是等同的。</p>
<p>这表明 subscribe 调用在同一 Observable 的多个观察者之间是不共享的。当使用一个观察者调用 observable.subscribe 时，Observable.create(function subscribe(observer) {…}) 中的 subscribe 函数只服务于给定的观察者。对 observable.subscribe 的每次调用都会触发针对给定观察者的独立设置。</p>
<p><strong>订阅 Observable 像是调用函数, 并提供接收数据的回调函数。</strong></p>
<p>这与像 addEventListener / removeEventListener 这样的事件处理方法 API 是完全不同的。使用 observable.subscribe，在 Observable 中不会将给定的观察者注册为监听器。Observable 甚至不会去维护一个附加的观察者列表。</p>
<p>subscribe 调用是启动 “Observable 执行”的一种简单方式， 并将值或事件传递给本次执行的观察者。</p>
<h2 id="执行-Observables"><a href="#执行-Observables" class="headerlink" title="执行 Observables"></a>执行 Observables</h2><p>Observable.create(function subscribe(observer) {…}) 中…的代码表示 “Observable 执行”，它是惰性运算，只有在每个观察者订阅后才会执行。随着时间的推移，执行会以同步或异步的方式产生多个值。</p>
<p>Observable 执行可以传递三种类型的值：</p>
<ul>
<li>“Next” 通知： 发送一个值，比如数字、字符串、对象，等等。</li>
<li>“Error” 通知： 发送一个 JavaScript 错误 或 异常。</li>
<li>“Complete” 通知： 不再发送任何值。</li>
</ul>
<p>“Next” 通知是最重要，也是最常见的类型：它们表示传递给观察者的实际数据。”Error” 和 “Complete” 通知可能只会在 Observable 执行期间发生一次，并且只会执行其中的一个。</p>
<p>这些约束用所谓的 Observable 语法或合约表达最好，写为正则表达式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next*(error|complete)?</div></pre></td></tr></table></figure>
<p><strong>在 Observable 执行中, 可能会发送零个到无穷多个 “Next” 通知。如果发送的是 “Error” 或 “Complete” 通知的话，那么之后不会再发送任何通知了。</strong></p>
<p>下面是 Observable 执行的示例，它发送了三个 “Next” 通知，然后是 “Complete” 通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Observable 严格遵守自身的规约，所以下面的代码不会发送 “Next” 通知 4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">  observer.next(4); // 因为违反规约，所以不会发送</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 subscribe 中用 try/catch 代码块来包裹任意代码是个不错的主意，如果捕获到异常的话，会发送 “Error” 通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  try &#123;</div><div class="line">    observer.next(1);</div><div class="line">    observer.next(2);</div><div class="line">    observer.next(3);</div><div class="line">    observer.complete();</div><div class="line">  &#125; catch (err) &#123;</div><div class="line">    observer.error(err); // 如果捕获到异常会发送一个错误</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="清理-Observable-执行"><a href="#清理-Observable-执行" class="headerlink" title="清理 Observable 执行"></a>清理 Observable 执行</h2><p>因为 Observable 执行可能会是无限的，并且观察者通常希望能在有限的时间内中止执行，所以我们需要一个 API 来取消执行。因为每个执行都是其对应观察者专属的，一旦观察者完成接收值，它必须要一种方法来停止执行，以避免浪费计算能力或内存资源。</p>
<p>当调用了 observable.subscribe ，观察者会被附加到新创建的 Observable 执行中。这个调用还返回一个对象，即 Subscription (订阅)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>Subscription 表示进行中的执行，它有最小化的 API 以允许你取消执行。想了解更多订阅相关的内容，请参见 Subscription 类型。使用 subscription.unsubscribe() 你可以取消进行中的执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.from([10, 20, 30]);</div><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div><div class="line">// 稍后：</div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
<p><strong>当你订阅了 Observable，你会得到一个 Subscription ，它表示进行中的执行。只要调用 unsubscribe() 方法就可以取消执行。</strong></p>
<p>当我们使用 create() 方法创建 Observable 时，Observable 必须定义如何清理执行的资源。你可以通过在 function subscribe() 中返回一个自定义的 unsubscribe 函数。</p>
<p>举例来说，这是我们如何清理使用了 setInterval 的 interval 执行集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  // 追踪 interval 资源</div><div class="line">  var intervalID = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;);</div><div class="line">  &#125;, 1000);</div><div class="line"></div><div class="line">  // 提供取消和清理 interval 资源的方法</div><div class="line">  return function unsubscribe() &#123;</div><div class="line">    clearInterval(intervalID);</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正如 observable.subscribe 类似于 Observable.create(function subscribe() {…})，从 subscribe 返回的 unsubscribe 在概念上也等同于 subscription.unsubscribe。事实上，如果我们抛开围绕这些概念的 ReactiveX 类型，保留下来的只是相当简单的 JavaScript 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function subscribe(observer) &#123;</div><div class="line">  var intervalID = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;);</div><div class="line">  &#125;, 1000);</div><div class="line"></div><div class="line">  return function unsubscribe() &#123;</div><div class="line">    clearInterval(intervalID);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var unsubscribe = subscribe(&#123;next: (x) =&gt; console.log(x)&#125;);</div><div class="line"></div><div class="line">// 稍后：</div><div class="line">unsubscribe(); // 清理资源</div></pre></td></tr></table></figure>
<p>为什么我们要使用像 Observable、Observer 和 Subscription 这样的 Rx 类型？原因是保证代码的安全性(比如 Observable 规约)和操作符的可组合性。</p>
<h1 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer (观察者)"></a>Observer (观察者)</h1><p>什么是观察者？ - 观察者是由 Observable 发送的值的消费者。观察者只是一组回调函数的集合，每个回调函数对应一种 Observable 发送的通知类型：next、error 和 complete 。下面的示例是一个典型的观察者对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var observer = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;Observer got a complete notification&apos;),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>要使用观察者，需要把它提供给 Observable 的 subscribe 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<p><strong>观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable 发送的通知类型。</strong></p>
<p>RxJS 中的观察者也可能是部分的。如果你没有提供某个回调函数，Observable 的执行也会正常运行，只是某些通知类型会被忽略，因为观察者中没有没有相对应的回调函数。</p>
<p>下面的示例是没有 complete 回调函数的观察者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observer = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当订阅 Observable 时，你可能只提供了一个回调函数作为参数，而并没有将其附加到观察者对象上，例如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(x =&gt; console.log(&apos;Observer got a next value: &apos; + x));</div></pre></td></tr></table></figure>
<p>在 observable.subscribe 内部，它会创建一个观察者对象并使用第一个回调函数参数作为 next 的处理方法。所有三种类型的回调函数都可以直接作为参数来提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(</div><div class="line">  x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">  () =&gt; console.log(&apos;Observer got a complete notification&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h1 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription (订阅)"></a>Subscription (订阅)</h1><p>什么是 Subscription ？ - Subscription 是表示可清理资源的对象，通常是 Observable 的执行。Subscription 有一个重要的方法，即 unsubscribe，它不需要任何参数，只是用来清理由 Subscription 占用的资源。在上一个版本的 RxJS 中，Subscription 叫做 “Disposable” (可清理对象)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.interval(1000);</div><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div><div class="line">// 稍后：</div><div class="line">// 这会取消正在进行中的 Observable 执行</div><div class="line">// Observable 执行是通过使用观察者调用 subscribe 方法启动的</div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
<p><strong>Subscription 基本上只有一个 unsubscribe() 函数，这个函数用来释放资源或去取消 Observable 执行。</strong><br>Subscription 还可以合在一起，这样一个 Subscription 调用 unsubscribe() 方法，可能会有多个 Subscription 取消订阅 。你可以通过把一个 Subscription 添加到另一个上面来做这件事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var observable1 = Rx.Observable.interval(400);</div><div class="line">var observable2 = Rx.Observable.interval(300);</div><div class="line"></div><div class="line">var subscription = observable1.subscribe(x =&gt; console.log(&apos;first: &apos; + x));</div><div class="line">var childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second: &apos; + x));</div><div class="line"></div><div class="line">subscription.add(childSubscription);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  // subscription 和 childSubscription 都会取消订阅</div><div class="line">  subscription.unsubscribe();</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>执行上面的代码，将看到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">second: 0</div><div class="line">first: 0</div><div class="line">second: 1</div><div class="line">first: 1</div><div class="line">second: 2</div></pre></td></tr></table></figure>
<p>Subscriptions 还有一个 remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription 。</p>
<h2 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject (主体)"></a>Subject (主体)</h2><p>什么是 Subject？ - RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，而普通的 Observables 是单播的(每个已订阅的观察者都拥有 Observable 的独立执行)。</p>
<p><strong>Subject 像是 Observalbe，但是可以多播给多个观察者。Subject 还像是 EventEmitters，维护着多个监听器的注册表。</strong></p>
<p><strong>每个 Subject 都是 Observable。</strong>  - 对于 Subject，你可以提供一个观察者并使用 subscribe 方法，就可以开始正常接收值。从观察者的角度而言，它无法判断 Observable 执行是来自普通的 Observable 还是 Subject 。<br>在 Subject 的内部，subscribe 不会调用发送值的新执行。它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener 的工作方式。</p>
<p><strong>每个 Subject 都是观察者。</strong> - Subject 是一个有如下方法的对象： next(v)、error(e) 和 complete() 。要给 Subjetc 提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该 Subject 的观察者们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div></pre></td></tr></table></figure>
<p>下面是控制台的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div></pre></td></tr></table></figure>
<p>因为 Subject 是观察者，这也就在意味着你可以把 Subject 作为参数传给任何 Observable 的 subscribe 方法，如下面的示例所展示的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var observable = Rx.Observable.from([1, 2, 3]);</div><div class="line"></div><div class="line">observable.subscribe(subject); // 你可以提供一个 Subject 进行订阅</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div><div class="line">observerA: 3</div><div class="line">observerB: 3</div></pre></td></tr></table></figure>
<h2 id="多播的-Observables"><a href="#多播的-Observables" class="headerlink" title="多播的 Observables"></a>多播的 Observables</h2><p>“多播 Observable” 通过 Subject 来发送通知，这个 Subject 可能有多个订阅者，然而普通的 “单播 Observable” 只发送通知给单个观察者。</p>
<p><strong>多播 Observable 在底层是通过使用 Subject 使得多个观察者可以看见同一个 Observable 执行。</strong></p>
<p>在底层，这就是 multicast 操作符的工作原理：观察者订阅一个基础的 Subject，然后 Subject 订阅源 Observable 。下面的示例与前面使用 observable.subscribe(subject) 的示例类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.from([1, 2, 3]);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var multicasted = source.multicast(subject);</div><div class="line"></div><div class="line">// 在底层使用了 `subject.subscribe(&#123;...&#125;)`:</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 在底层使用了 `source.subscribe(subject)`:</div><div class="line">multicasted.connect();</div></pre></td></tr></table></figure>
<p>multicast 操作符返回一个 Observable，它看起来和普通的 Observable 没什么区别，但当订阅时就像是 Subject 。multicast 返回的是 ConnectableObservable，它只是一个有 connect() 方法的 Observable 。</p>
<p>connect() 方法十分重要，它决定了何时启动共享的 Observable 执行。因为 connect() 方法在底层执行了 source.subscribe(subject)，所以它返回的是 Subscription，你可以取消订阅以取消共享的 Observable 执行。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>手动调用 connect() 并处理 Subscription 通常太笨重。通常，当第一个观察者到达时我们想要自动地连接，而当最后一个观察者取消订阅时我们想要自动地取消共享执行。</p>
<ol>
<li>第一个观察者订阅了多播 Observable</li>
<li>多播 Observable 已连接</li>
<li>next 值 0 发送给第一个观察者</li>
<li>第二个观察者订阅了多播 Observable</li>
<li>next 值 1 发送给第一个观察者</li>
<li>next 值 1 发送给第二个观察者</li>
<li>第一个观察者取消了多播 Observable 的订阅</li>
<li>next 值 2 发送给第二个观察者</li>
<li>第二个观察者取消了多播 Observable 的订阅</li>
<li>多播 Observable 的连接已中断(底层进行的操作是取消订阅)</li>
</ol>
<p>要实现这点，需要显式地调用 connect()，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(500);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var multicasted = source.multicast(subject);</div><div class="line">var subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">subscription1 = multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">// 这里我们应该调用 `connect()`，因为 `multicasted` 的第一个</div><div class="line">// 订阅者关心消费值</div><div class="line">subscriptionConnect = multicasted.connect();</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription2 = multicasted.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 600);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, 1200);</div><div class="line"></div><div class="line">// 这里我们应该取消共享的 Observable 执行的订阅，</div><div class="line">// 因为此后 `multicasted` 将不再有订阅者</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription2.unsubscribe();</div><div class="line">  subscriptionConnect.unsubscribe(); // 用于共享的 Observable 执行</div><div class="line">&#125;, 2000);</div></pre></td></tr></table></figure>
<p>如果不想显式调用 connect()，我们可以使用 ConnectableObservable 的 refCount() 方法(引用计数)，这个方法返回 Observable，这个 Observable 会追踪有多少个订阅者。当订阅者的数量从0变成1，它会调用 connect() 以开启共享的执行。当订阅者数量从1变成0时，它会完全取消订阅，停止进一步的执行。</p>
<p><strong>refCount 的作用是，当有第一个订阅者时，多播 Observable 会自动地启动执行，而当最后一个订阅者离开时，多播 Observable 会自动地停止执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(500);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var refCounted = source.multicast(subject).refCount();</div><div class="line">var subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">// 这里其实调用了 `connect()`，</div><div class="line">// 因为 `refCounted` 有了第一个订阅者</div><div class="line">console.log(&apos;observerA subscribed&apos;);</div><div class="line">subscription1 = refCounted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerB subscribed&apos;);</div><div class="line">  subscription2 = refCounted.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 600);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerA unsubscribed&apos;);</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, 1200);</div><div class="line"></div><div class="line">// 这里共享的 Observable 执行会停止，</div><div class="line">// 因为此后 `refCounted` 将不再有订阅者</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerB unsubscribed&apos;);</div><div class="line">  subscription2.unsubscribe();</div><div class="line">&#125;, 2000);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">observerA subscribed</div><div class="line">observerA: 0</div><div class="line">observerB subscribed</div><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA unsubscribed</div><div class="line">observerB: 2</div><div class="line">observerB unsubscribed</div></pre></td></tr></table></figure>
<p>refCount() 只存在于 ConnectableObservable，它返回的是 Observable，而不是另一个 ConnectableObservable 。</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Subject 的其中一个变体就是 BehaviorSubject，它有一个“当前值”的概念。它保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”。</p>
<p><strong>BehaviorSubjects 适合用来表示“随时间推移的值”。举例来说，生日的流是一个 Subject，但年龄的流应该是一个 BehaviorSubject 。</strong></p>
<p>在下面的示例中，BehaviorSubject 使用值0进行初始化，当第一个观察者订阅时会得到0。第二个观察者订阅时会得到值2，尽管它是在值2发送之后订阅的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.BehaviorSubject(0); // 0是初始值</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(3);</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">observerA: 0</div><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div><div class="line">observerA: 3</div><div class="line">observerB: 3</div></pre></td></tr></table></figure>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>ReplaySubject 类似于 BehaviorSubject，它可以发送旧值给新的订阅者，但它还可以记录 Observable 执行的一部分。</p>
<p><strong>ReplaySubject 记录 Observable 执行中的多个值并将其回放给新的订阅者。</strong></p>
<p>当创建 ReplaySubject 时，你可以指定回放多少个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.ReplaySubject(3); // 为新的订阅者缓冲3个值</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerA: 3</div><div class="line">observerA: 4</div><div class="line">observerB: 2</div><div class="line">observerB: 3</div><div class="line">observerB: 4</div><div class="line">observerA: 5</div><div class="line">observerB: 5</div></pre></td></tr></table></figure>
<p>除了缓冲数量，你还可以指定 window time (以毫秒为单位)来确定多久之前的值可以记录。在下面的示例中，我们使用了较大的缓存数量100，但 window time 参数只设置了500毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.ReplaySubject(100, 500 /* windowTime */);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var i = 1;</div><div class="line">setInterval(() =&gt; subject.next(i++), 200);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subject.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>从下面的输出可以看出，第二个观察者得到的值是3、4、5，这三个值是订阅发生前的500毫秒内发生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerA: 3</div><div class="line">observerA: 4</div><div class="line">observerA: 5</div><div class="line">observerB: 3</div><div class="line">observerB: 4</div><div class="line">observerB: 5</div><div class="line">observerA: 6</div><div class="line">observerB: 6</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>AsyncSubject 是另一个 Subject 变体，只有当 Observable 执行完成时(执行 complete())，它才会将执行的最后一个值发送给观察者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.AsyncSubject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div><div class="line">subject.complete();</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">observerA: 5</div><div class="line">observerB: 5</div></pre></td></tr></table></figure>
<p>AsyncSubject 和 last() 操作符类似，因为它也是等待 complete 通知，以发送一个单个值。</p>
<h2 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators (操作符)"></a>Operators (操作符)</h2><p>尽管 RxJS 的根基是 Observable，但最有用的还是它的操作符。操作符是允许复杂的异步代码以声明式的方式进行轻松组合的基础代码单元。</p>
<h3 id="操作符？"><a href="#操作符？" class="headerlink" title="操作符？"></a>操作符？</h3><p>操作符是 Observable 类型上的方法，比如 .map(…)、.filter(…)、.merge(…)，等等。当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable 。</p>
<p><strong>操作符是函数，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。</strong></p>
<p>操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。订阅输出 Observalbe 同样会订阅输入 Observable 。在下面的示例中，我们创建一个自定义操作符函数，它将从输入 Observable 接收的每个值都乘以10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function multiplyByTen(input) &#123;</div><div class="line">  var output = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">    input.subscribe(&#123;</div><div class="line">      next: (v) =&gt; observer.next(10 * v),</div><div class="line">      error: (err) =&gt; observer.error(err),</div><div class="line">      complete: () =&gt; observer.complete()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  return output;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var input = Rx.Observable.from([1, 2, 3, 4]);</div><div class="line">var output = multiplyByTen(input);</div><div class="line">output.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">20</div><div class="line">30</div><div class="line">40</div></pre></td></tr></table></figure>
<p>注意，订阅 output 会导致 input Observable 也被订阅。我们称之为“操作符订阅链”。</p>
<h2 id="实例操作符-vs-静态操作符"><a href="#实例操作符-vs-静态操作符" class="headerlink" title="实例操作符 vs. 静态操作符"></a>实例操作符 vs. 静态操作符</h2><p>什么是实例操作符？ - 通常提到操作符时，我们指的是实例操作符，它是 Observable 实例上的方法。举例来说，如果上面的 multiplyByTen 是官方提供的实例操作符，它看起来大致是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.prototype.multiplyByTen = function multiplyByTen() &#123;</div><div class="line">  var input = this;</div><div class="line">  return Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">    input.subscribe(&#123;</div><div class="line">      next: (v) =&gt; observer.next(10 * v),</div><div class="line">      error: (err) =&gt; observer.error(err),</div><div class="line">      complete: () =&gt; observer.complete()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实例运算符是使用 this 关键字来指代输入的 Observable 的函数。</strong></p>
<p>注意，这里的 input Observable 不再是一个函数参数，它现在是 this 对象。下面是我们如何使用这样的实例运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.from([1, 2, 3, 4]).multiplyByTen();</div><div class="line">observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>什么是静态操作符？ - 除了实例操作符，还有静态操作符，它们是直接附加到 Observable 类上的。静态操作符在内部不使用 this 关键字，而是完全依赖于它的参数。</p>
<p><strong>静态操作符是附加到 Observalbe 类上的纯函数，通常用来从头开始创建 Observalbe。</strong></p>
<p>最常用的静态操作符类型是所谓的创建操作符。它们只接收非 Observable 参数，比如数字，然后创建一个新的 Observable ，而不是将一个输入 Observable 转换为输出 Observable 。</p>
<p>一个典型的静态操作符例子就是 interval 函数。它接收一个数字(非 Observable)作为参数，并生产一个 Observable 作为输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.interval(1000 /* 毫秒数 */);</div></pre></td></tr></table></figure>
<p>创建操作符的另一个例子就是 create，已经在前面的示例中广泛使用。点击这里查看所有静态操作符列表。</p>
<p>然而，有些静态操作符可能不同于简单的创建。一些组合操作符可能是静态的，比如 merge、combineLatest、concat，等等。这些作为静态运算符是有道理的，因为它们将多个 Observables 作为输入，而不仅仅是一个，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observable1 = Rx.Observable.interval(1000);</div><div class="line">var observable2 = Rx.Observable.interval(400);</div><div class="line"></div><div class="line">var merged = Rx.Observable.merge(observable1, observable2);</div></pre></td></tr></table></figure>
<h2 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler (调度器)"></a>Scheduler (调度器)</h2><p>什么是调度器？ - 调度器控制着何时启动 subscription 和何时发送通知。它由三部分组成：</p>
<ul>
<li>调度器是一种数据结构。 它知道如何根据优先级或其他标准来存储任务和将任务进行排序。</li>
<li>调度器是执行上下文。 它表示在何时何地执行任务(举例来说，立即的，或另一种回调函数机制(比如 setTimeout 或 process.nextTick)，或动画帧)。</li>
<li>调度器有一个(虚拟的)时钟。 调度器功能通过它的 getter 方法 now()<br>提供了“时间”的概念。在具体调度器上安排的任务将严格遵循该时钟所表示的时间。</li>
</ul>
<p><strong>调度器可以让你规定 Observable 在什么样的执行上下文中发送通知给它的观察者。</strong></p>
<p>在下面的示例中，我们采用普通的 Observable ，它同步地发出值1、2、3，并使用操作符 observeOn 来指定 async 调度器发送这些值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">&#125;)</div><div class="line">.observeOn(Rx.Scheduler.async);</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(&#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">just before subscribe</div><div class="line">just after subscribe</div><div class="line">got value 1</div><div class="line">got value 2</div><div class="line">got value 3</div><div class="line">done</div></pre></td></tr></table></figure>
<p>注意通知 got value… 在 just after subscribe 之后才发送，这与我们到目前为止所见的默认行为是不一样的。这是因为 observeOn(Rx.Scheduler.async) 在 Observable.create 和最终的观察者之间引入了一个代理观察者。在下面的示例代码中，我们重命名了一些标识符，使得其中的区别变得更明显：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (proxyObserver) &#123;</div><div class="line">  proxyObserver.next(1);</div><div class="line">  proxyObserver.next(2);</div><div class="line">  proxyObserver.next(3);</div><div class="line">  proxyObserver.complete();</div><div class="line">&#125;)</div><div class="line">.observeOn(Rx.Scheduler.async);</div><div class="line"></div><div class="line">var finalObserver = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(finalObserver);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>proxyObserver 是在 observeOn(Rx.Scheduler.async) 中创建的，它的 next(val) 函数大概是下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var proxyObserver = &#123;</div><div class="line">  next: (val) =&gt; &#123;</div><div class="line">    Rx.Scheduler.async.schedule(</div><div class="line">      (x) =&gt; finalObserver.next(x),</div><div class="line">      0 /* 延迟时间 */,</div><div class="line">      val /* 会作为上面函数所使用的 x */</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>async 调度器操作符使用了 setTimeout 或 setInterval，即使给定的延迟时间为0。照例，在 JavaScript 中，我们已知的是 setTimeout(fn, 0) 会在下一次事件循环迭代的最开始运行 fn 。这也解释了为什么发送给 finalObserver 的 got value 1 发生在 just after subscribe 之后。</p>
<p>调度器的 schedule() 方法接收一个 delay 参数，它指的是相对于调度器内部时钟的一段时间。调度器的时钟不需要与实际的挂钟时间有任何关系。这也就是为什么像 delay 这样的时间操作符不是在实际时间上操作的，而是取决于调度器的时钟时间。这在测试中极其有用，可以使用虚拟时间调度器来伪造挂钟时间，同时实际上是在同步执行计划任务。</p>
<h3 id="调度器类型"><a href="#调度器类型" class="headerlink" title="调度器类型"></a>调度器类型</h3><p>async 调度器是 RxJS 提供的内置调度器中的一个。可以通过使用 Scheduler 对象的静态属性创建并返回其中的每种类型的调度器。</p>
<table><br>        <tr><br>            <th>调度器</th><br>            <th>目的</th><br>        </tr><br>         <tr><br>            <th>null</th><br>            <th>不传递任何调度器的话，会以同步递归的方式发送通知，用于定时操作或尾递归操作。</th><br>        </tr><br>         <tr><br>            <th>Rx.Scheduler.queue</th><br>            <th>当前事件帧中的队列调度(蹦床调度器)，用于迭代操作。</th><br>        </tr><br>        <tr><br>            <th>Rx.Scheduler.asap</th><br>            <th>    微任务的队列调度，它使用可用的最快速的传输机制，比如 Node.js 的 process.nextTick() 或 Web Worker 的 MessageChannel 或 setTimeout 或其他。用于异步转换。</th><br>        </tr><br>        <tr><br>            <th>Rx.Scheduler.async</th><br>            <th>使用 setInterval 的调度。用于基于时间的操作符。</th><br>        </tr><br></table>

<h3 id="使用调度器"><a href="#使用调度器" class="headerlink" title="使用调度器"></a>使用调度器</h3><p>你可能在你的 RxJS 代码中已经使用过调度器了，只是没有明确地指明要使用的调度器的类型。这是因为所有的 Observable 操作符处理并发性都有可选的调度器。如果没有提供调度器的话，RxJS 会通过使用最小并发原则选择一个默认调度器。这意味着引入满足操作符需要的最小并发量的调度器会被选择。例如，对于返回有限和少量消息的 observable 的操作符，RxJS 不使用调度器，即 null 或 undefined 。对于返回潜在大量的或无限数量的消息的操作符，使用 queue 调度器。对于使用定时器的操作符，使用 aysnc 调度器。</p>
<p>因为 RxJS 使用最少的并发调度器，如果出于性能考虑，你想要引入并发，那么可以选择不同的调度器。要指定具体的调度器，可以使用那些采用调度器的操作符方法，例如 from([10, 20, 30], Rx.Scheduler.async) 。</p>
<p>静态创建操作符通常可以接收调度器作为参数。 举例来说，from(array, scheduler) 可以让你指定调度器，当发送从 array 转换的每个通知的时候使用。调度器通常作为操作符的最后一个参数。下面的静态创建操作符接收调度器参数：</p>
<ul>
<li>bindCallback</li>
<li>bindNodeCallback</li>
<li>combineLatest</li>
<li>concat</li>
<li>empty</li>
<li>from</li>
<li>fromPromise</li>
<li>interval</li>
<li>merge</li>
<li>of</li>
<li>range</li>
<li>throw</li>
<li>timer</li>
</ul>
<p>使用 subscribeOn 来调度 subscribe() 调用在什么样的上下文中执行。 默认情况下，Observable 的 subscribe() 调用会立即同步地执行。然而，你可能会延迟或安排在给定的调度器上执行实际的 subscription ，使用实例操作符 subscribeOn(scheduler)，其中 scheduler 是你提供的参数。<br>使用 observeOn 来调度发送通知的的上下文。 正如我们在上面的示例中所看到的，实例操作符 observeOn(scheduler) 在源 Observable 和目标观察者之间引入了一个中介观察者，中介负责调度，它使用给定的 scheduler 来调用目标观察者。</p>
<p>实例操作符可能会接收调度器作为参数。</p>
<p>像 bufferTime、debounceTime、delay、auditTime、sampleTime、throttleTime、timeInterval、timeout、timeoutWith、windowTime 这样时间相关的操作符全部接收调度器作为最后的参数，并且默认的操作是在 Rx.Scheduler.async 调度器上。</p>
<p>其他接收调度器作为参数的实例操作符：cache、combineLatest、concat、expand、merge、publishReplay、startWith。</p>
<p><strong>注意：</strong>cache 和 publishReplay 都接收调度器是因为它们使用了 ReplaySubject 。ReplaySubjects 的构造函数接收一个可选的调度器作为最后的参数，因为 ReplaySubject 可能会处理时间，这只在调度器的上下文中才有意义。默认情况下，ReplaySubject 使用 queue 调度器来提供时钟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两年，各种异步编程框架，上面RxJava,RxAndroid,RxSwift等等，今天要聊的是RxJs，对于我等入门不久的前端工程师来说，这个框架还是比较有新颖的，中文官网地址：&lt;a href=&quot;http://cn.rx.js.org/&quot; target=&quot;_blank&quot; 
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之提供委托</title>
    <link href="http://www.xiangzhihong.com/2017/10/23/Kotlin%E4%B9%8B%E6%8F%90%E4%BE%9B%E5%A7%94%E6%89%98/"/>
    <id>http://www.xiangzhihong.com/2017/10/23/Kotlin之提供委托/</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:04:47.839Z</updated>
    
    <content type="html"><![CDATA[<p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p>
<p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。例如，如果要在绑定之前检查属性名称，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</div><div class="line">    operator fun provideDelegate(</div><div class="line">            thisRef: MyUI,</div><div class="line">            prop: KProperty&lt;*&gt;</div><div class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">        checkProperty(thisRef, prop.name)</div><div class="line">        // 创建委托</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</div><div class="line"></div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id)</div><div class="line">    val text by bindResource(ResourceID.text_id)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>provideDelegate 的参数与 getValue 相同：</p>
<ul>
<li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型。</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用provideDelegate 方法，并立即执行必要的验证。</li>
</ul>
<p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 检查属性名称而不使用“provideDelegate”功能</div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</div><div class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; MyUI.bindResource(</div><div class="line">        id: ResourceID&lt;T&gt;,</div><div class="line">        propertyName: String</div><div class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">   checkProperty(this, propertyName)</div><div class="line">   // 创建委托</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这段代码是当“provideDelegate”功能可用时，由编译器生成的代码：</div><div class="line">class C &#123;</div><div class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</div><div class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</div><div class="line">    val prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>
<p>上面例子的完整代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val myui: MyUI = MyUI()</div><div class="line">    println(myui.image)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class dge&lt;T&gt;(t: T) &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ResourceLoader&lt;T&gt;(id: Int) &#123;</div><div class="line">    operator fun provideDelegate(</div><div class="line">            thisRef: MyUI,</div><div class="line">            prop: KProperty&lt;*&gt;</div><div class="line">    ): dge&lt;T?&gt; &#123;</div><div class="line">        checkProperty(thisRef, prop.name)</div><div class="line">        // 创建委托</div><div class="line">        var t: T? = null</div><div class="line">        return dge(t)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123;</div><div class="line">        println(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; bindResource(id: Int): ResourceLoader&lt;T&gt; &#123;</div><div class="line">    return ResourceLoader&lt;T&gt;(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource&lt;String&gt;(1)</div><div class="line">    val text by bindResource&lt;String&gt;(2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。&lt;/p&gt;
&lt;p&gt;provideDelegate 的一个可能的
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>将Kotlin代码编译成Javascript 代码</title>
    <link href="http://www.xiangzhihong.com/2017/10/22/%E5%B0%86Kotlin%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%88%90Javascript%20%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.xiangzhihong.com/2017/10/22/将Kotlin代码编译成Javascript 代码/</id>
    <published>2017-10-21T16:00:00.000Z</published>
    <updated>2018-02-11T03:27:28.959Z</updated>
    
    <content type="html"><![CDATA[<p>在Kotlin和Javascript平台的互操作过程中，往往会涉及Kotlin代码和 Javascript 代码相互转换的过程，本文主要介绍如何将Kotlin代码编译成Javascript 代码。</p>
<h2 id="1，创建JavaScript的应用程序"><a href="#1，创建JavaScript的应用程序" class="headerlink" title="1，创建JavaScript的应用程序"></a>1，创建JavaScript的应用程序</h2><p>首先创建一个新的应用程序或目标JavaScript模块时，并需要选择Kotlin - JavaScript作为编译运行目标。<br><img src="http://img.blog.csdn.net/20180209150539778" alt="这里写图片描述"></p>
<p>默认情况下，插件选择与当前安装版本关联的插件。除非我们要创建一个不同的项目，否则我们可以在输入项目名称和位置后点击Finish。<br><img src="http://img.blog.csdn.net/20180209150607704" alt="这里写图片描述"></p>
<p>项目创建完成后，项目结构如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180209151011292" alt="这里写图片描述"></p>
<h2 id="2，新建项目"><a href="#2，新建项目" class="headerlink" title="2，新建项目"></a>2，新建项目</h2><p>接下来，可以开始编写Kotlin代码。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val message = &quot;Hello JavaScript!&quot;</div><div class="line">    println(message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在需要一个HTML页面来加载代码，所以我们创建一个名为index.html的文件。</p>
<h2 id="编译输出代码说明"><a href="#编译输出代码说明" class="headerlink" title="编译输出代码说明"></a>编译输出代码说明</h2><p>将 Kotlin 代码编译为 Javascript 代码后会得到两个主要的文件：</p>
<ul>
<li>Kotlin.js. ：运行时和标准库，这部分代码只与 Kotlin 的版本有关而不会因为不同的应用而有所不同。</li>
<li>{module}.js：真正的应用代码，所有的应用代码最终都会编译成一个 JavaScript 文件并与模块的名字同名。</li>
</ul>
<p>除此之外，每一个源码文件都会有一个关联的 {file}.meta.js 元文件，该文件可用来做反射或是其他的功能。Kotlin 编译器将会输出如下代码：<br><img src="http://img.blog.csdn.net/20180209162547125" alt="这里写图片描述"></p>
<p>而大家最关心的莫过于ConsoleOutput.js，该文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ConsoleOutput = function (Kotlin) &#123;</div><div class="line">  &apos;use strict&apos;;</div><div class="line">var _ = Kotlin.defineRootPackage(null, /** @lends _ */ &#123;</div><div class="line">    main_kand9s$: function (args) &#123;</div><div class="line">      Kotlin.println(&apos;Hello JavaScript!&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  Kotlin.defineModule(&apos;ConsoleOutput&apos;, _);</div><div class="line">  _.main_kand9s$([]);</div><div class="line">return _;</div><div class="line">&#125;(kotlin);</div></pre></td></tr></table></figure>
<p>如上代码就是 kotlin main 函数编译后得到的代码，我们可以看到编译后的代码定义了一个函数并赋值给了一个与模块名同名的变量，然后通过传入的 Kotlin 变量来调用 define  rootPackage 函数。通过 Kotlin 变量我们可以使用 kotlin.js 标准库中的方法。</p>
<p>编译前的代码只有一个 main 函数，编译之后该函数被添加了后缀，这么做的目的主要是为了防止重载 Kotlin 中的代码，Kotlin 中的这部分功能是为了将源码转换成对应的 javascript 代码。</p>
<p>最后定义为一个立即执行函数，当这部分代码加载之后就会立即执行，并将 Kotlin 做为参数传进去，这样就可以使用 Kotlin.js 中定义的方法了。</p>
<h2 id="运行编译后的代码"><a href="#运行编译后的代码" class="headerlink" title="运行编译后的代码"></a>运行编译后的代码</h2><p>这部分代码的目的是为了通过 console 输出文本，在这里我们需要通过 HTML 页面加载并在浏览器中运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">&lt;title&gt;Console Output&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;out/production/ConsoleOutput/lib/kotlin.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;out/production/ConsoleOutput/ConsoleOutput.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>注：我们需要先加载 kotlin.js 文件，再加载我们的应用文件。</strong></p>
<p><img src="http://img.blog.csdn.net/20180209162800453" alt="这里写图片描述"></p>
<h2 id="调试应用程序"><a href="#调试应用程序" class="headerlink" title="调试应用程序"></a>调试应用程序</h2><p>为了使用IntelliJ IDEA调试应用程序，我们需要执行两个步骤：</p>
<ul>
<li>安装JetBrains Chrome扩展，它允许通过Chrome在IntelliJ IDEA中进行调试。这对于用IntelliJ IDEA开发的任何类型的Web应用程序都很有用，而不仅仅是Kotlin；</li>
<li>配置Kotlin编译器生成源地图，可通过 Preferences|Kotlin Compiler。<br><img src="http://img.blog.csdn.net/20180209162941236" alt="这里写图片描述"><br>一旦完成，我们只需右键单击我们的index.html文件，然后选择调试选项。这将启动Chrome，然后在IntelliJ IDEA中的代码中定义的断点处停止，我们可以在其中评估表达式，逐步执行代码等。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20180209163123149" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180209163149634" alt="这里写图片描述"></p>
<p>也可以使用标准的Chrome调试器来调试Kotlin应用程序，只要确保你生成源地图。</p>
<h3 id="配置编译器选项"><a href="#配置编译器选项" class="headerlink" title="配置编译器选项"></a>配置编译器选项</h3><p>Kotlin提供了一系列可在IntelliJ IDEA中访问的编译器选项。常见的如下：</p>
<ul>
<li><strong>输出文件前缀</strong>。我们可以在编译器生成的输出前加上额外的JavaScript。为了做到这一点，我们在这个框中指出了包含我们想要的JavaScript的文件的名字。</li>
<li><strong>输出文件后缀</strong>。同上，但在这种情况下，编译器会将所选文件的内容追加到输出中。</li>
<li><strong>复制运行时库文件</strong>。指示我们希望将该kotlin.js库输出到哪个子文件夹中。默认情况下，lib这就是为什么在HTML中我们引用这个路径。</li>
<li><strong>模块种类</strong>。指示要遵循的模块标准。这在“ 使用模块”教程中有更深入的介绍。</li>
</ul>
<p>附：<a href="http://kotlinlang.org/docs/tutorials/javascript/getting-started-idea/getting-started-with-intellij-idea.html" target="_blank" rel="external">http://kotlinlang.org/docs/tutorials/javascript/getting-started-idea/getting-started-with-intellij-idea.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Kotlin和Javascript平台的互操作过程中，往往会涉及Kotlin代码和 Javascript 代码相互转换的过程，本文主要介绍如何将Kotlin代码编译成Javascript 代码。&lt;/p&gt;
&lt;h2 id=&quot;1，创建JavaScript的应用程序&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
</feed>
