<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向志洪</title>
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiangzhihong.com/"/>
  <updated>2018-02-11T03:32:44.722Z</updated>
  <id>http://www.xiangzhihong.com/</id>
  
  <author>
    <name>xiangzhihong</name>
    <email>1044817967@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android+TensorFlow+CNN+MNIST实现手写数字识别</title>
    <link href="http://www.xiangzhihong.com/2018/02/08/Android+TensorFlow+CNN+MNIST%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://www.xiangzhihong.com/2018/02/08/Android+TensorFlow+CNN+MNIST实现手写数字识别/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-02-11T03:32:44.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>TensorFlow： 1.2.0</li>
<li>Python： 3.6</li>
<li>Python IDE： PyCharm 2017.2</li>
<li>Android IDE： Android Studio 3.0</li>
</ul>
<h2 id="训练与评估"><a href="#训练与评估" class="headerlink" title="训练与评估"></a>训练与评估</h2><p>训练和评估部分主要目的是生成用于测试用的pb文件，其保存了利用TensorFlow python API构建训练后的网络拓扑结构和参数信息，实现方式有很多种，除了cnn外还可以使用rnn，fcnn等。<br>其中基于cnn的函数也有两套，分别为tf.layers.conv2d和tf.nn.conv2d， tf.layers.conv2d使用tf.nn.conv2d作为后端处理，参数上filters是整数，filter是4维张量。原型如下：</p>
<h3 id="convolutional-py文件"><a href="#convolutional-py文件" class="headerlink" title="convolutional.py文件"></a>convolutional.py文件</h3><p>def conv2d(inputs, filters, kernel_size, strides=(1, 1), padding=’valid’, data_format=’channels_last’,<br>dilation_rate=(1, 1), activation=None, use_bias=True, kernel_initializer=None,<br>bias_initializer=init_ops.zeros_initializer(), kernel_regularizer=None, bias_regularizer=None,<br>activity_regularizer=None, kernel_constraint=None, bias_constraint=None, trainable=True, name=None,<br>reuse=None)</p>
<h3 id="gen-nn-ops-py-文件"><a href="#gen-nn-ops-py-文件" class="headerlink" title="gen_nn_ops.py 文件"></a>gen_nn_ops.py 文件</h3><p>def conv2d(input, filter, strides, padding, use_cudnn_on_gpu=True, data_format=”NHWC”, name=None)<br>官方Demo实例中使用的是layers module，结构如下：</p>
<ul>
<li>Convolutional Layer #1：32个5×5的filter，使用ReLU激活函数</li>
<li>Pooling Layer #1：2×2的filter做max pooling，步长为2</li>
<li>Convolutional Layer #2：64个5×5的filter，使用ReLU激活函数</li>
<li>Pooling Layer #2：2×2的filter做max pooling，步长为2</li>
<li>Dense Layer #1：1024个神经元，使用ReLU激活函数，dropout率0.4<br>(为了避免过拟合，在训练的时候，40%的神经元会被随机去掉)</li>
<li>Dense Layer #2 (Logits Layer)：10个神经元，每个神经元对应一个类别（0-9）</li>
</ul>
<p>核心代码在cnn_model_fn(features, labels, mode)函数中，完成卷积结构的完整定义，核心代码如下：<br><img src="http://img.blog.csdn.net/2018021110052588" alt="这里写图片描述"></p>
<p>也可以采用传统的tf.nn.conv2d函数, 核心代码如下:<br><img src="http://img.blog.csdn.net/20180211100635272" alt="这里写图片描述"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>核心是使用API接口： TensorFlowInferenceInterface.java</li>
<li>配置gradle 或者 自编译TensorFlow源码导入jar和so compile<br>‘org.tensorflow:tensorflow-android:1.2.0’</li>
<li>导入pb文件.pb文件放assets目录，然后读取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String actualFilename = labelFilename.split(“file:///android_asset/“)[1];</div><div class="line">Log.i(TAG, “Reading labels from: “ + actualFilename);</div><div class="line">BufferedReader br = null;</div><div class="line">br = new BufferedReader(new InputStreamReader(assetManager.open(actualFilename)));</div><div class="line">String line;</div><div class="line">while ((line = br.readLine()) != null) &#123;</div><div class="line">c.labels.add(line);</div><div class="line">&#125;</div><div class="line">br.close();</div></pre></td></tr></table></figure>
<ul>
<li>TensorFlow接口使用如下：<br><img src="http://img.blog.csdn.net/20180211100843563" alt="这里写图片描述"></li>
</ul>
<p>最终的测试效果为：<br><img src="http://img.blog.csdn.net/20180211100929993" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180211100947212" alt="这里写图片描述"></p>
<h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h2><p>MNIST，最经典的机器学习模型之一，包含0~9的数字，28*28大小的单色灰度手写数字图片数据库，其中共60,000 training examples和10,000 test examples。<br>文件目录如下，主要包括4个二进制文件，分别为训练和测试图片及Label。<br><img src="http://img.blog.csdn.net/20180211101452932" alt="这里写图片描述"></p>
<p>如下为训练图片的二进制结构，在真实数据前（pixel），有部分描述字段（魔数，图片个数，图片行数和列数），真实数据的存储采用大端规则。<br>（大端规则，就是数据的高字节保存在低内存地址中，低字节保存在高内存地址中）</p>
<p><img src="http://img.blog.csdn.net/20180211101546490" alt="这里写图片描述"></p>
<p>在具体实验使用，需要提取真实数据，可采用专门用于处理字节的库struct中的unpack_from方法，核心方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct.unpack_from(self._fourBytes2, buf, index)</div></pre></td></tr></table></figure>
<p>MNIST作为AI的Hello World入门实例数据，TensorFlow封装对其封装好了函数，可直接使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mnist = input_data.read_data_sets(‘MNIST’, one_hot=True)</div></pre></td></tr></table></figure>
<h2 id="CNN（Convolutional-Neural-Network）"><a href="#CNN（Convolutional-Neural-Network）" class="headerlink" title="CNN（Convolutional Neural Network）"></a>CNN（Convolutional Neural Network）</h2><p>CNN，英文Convolutional Neural Network，中文全称卷积神经网络，即所谓的卷积网（ConvNets）。卷积（Convolution）可谓是现代深度学习中最最重要的概念了，它是一种数学运算，读者可以从下面链接<a href="http://www.qiujiawei.com/convolution/" target="_blank" rel="external">理解卷积Convolution</a>中卷积相关数学机理，包括分别从傅里叶变换和狄拉克δ函数中推到卷积定义，我们可以从字面上宏观粗鲁的理解成将因子翻转相乘卷起来。卷积动画模型如下图所示：<br><img src="http://img.blog.csdn.net/20180211102305841" alt="这里写图片描述"></p>
<p>神经网络：一个由大量神经元（neurons）组成的系统，如下图所示：<br><img src="http://img.blog.csdn.net/20180211102351322" alt="这里写图片描述"><br>其中，x表示输入向量，w为权重，b为偏值bias，f为激活函数。</p>
<p>Activation Function 激活函数： 常用的非线性激活函数有Sigmoid、tanh、ReLU等等，公式如下所示。</p>
<ul>
<li><strong>Sigmoid函数</strong>：函数饱和使梯度消失（神经元在值为 0 或 1 的时候接近饱和，这些区域，梯度几乎为 0）。同时，sigmoid 函数不是关于原点中心对称的（无0中心化）。</li>
<li><strong>tanh</strong>： 存在饱和问题，但它的输出是零中心的，因此实际中 tanh 比 sigmoid 更受欢迎。</li>
<li><strong>ReLU函数</strong>：ReLU 对于 SGD 的收敛有巨大的加速作用，只需要一个阈值就可以得到激活值，而不用去算一大堆复杂的（指数）运算。缺点是：需要合理设置学习率（learning rate），防止训练时dead，还可以使用Leaky ReLU/PReLU/Maxout等代替。<br><img src="http://img.blog.csdn.net/2018021110271226" alt="这里写图片描述"></li>
<li><p><strong>Pooling池化</strong>：一般分为平均池化mean pooling和最大池化max pooling，如下图所示[21]为max pooling，除此之外，还有重叠池化（OverlappingPooling）[24]，空金字塔池化（Spatial Pyramid<br>Pooling）</p>
<p> <strong>平均池化</strong>：计算图像区域的平均值作为该区域池化后的值。<br><strong>最大池化</strong>：选图像区域的最大值作为该区域池化后的值。</p>
</li>
</ul>
<p><img src="http://img.blog.csdn.net/20180211102916270" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180211102944106" alt="这里写图片描述"></p>
<h2 id="CNN-Architecture"><a href="#CNN-Architecture" class="headerlink" title="CNN Architecture"></a>CNN Architecture</h2><p><strong>三层神经网络</strong>：分别为输入层（Input layer）,输出层（Output layer）,隐藏层（Hidden layer），如下图所示。<br><img src="http://img.blog.csdn.net/20180211103302239" alt="这里写图片描述"></p>
<p><strong>CNN层级结构</strong>： 斯坦福cs231n中阐述了一种[INPUT-CONV-RELU-POOL-FC]，如上图右边图片所示，分别为输入层，卷积层，激励层，池化层，全连接层。</p>
<p>CNN通用架构分为如下三层结构：</p>
<ul>
<li>Convolutional layers 卷积层</li>
<li>Pooling layers 汇聚层</li>
<li>Dense (fully connected) layers 全连接层<br><img src="http://img.blog.csdn.net/20180211103441940" alt="这里写图片描述"></li>
</ul>
<p>用动画演示如下图：<br><img src="http://img.blog.csdn.net/20180211103625385" alt="这里写图片描述"></p>
<h2 id="Regression-Softmax"><a href="#Regression-Softmax" class="headerlink" title="Regression + Softmax"></a>Regression + Softmax</h2><p>机器学习有监督学习（supervised learning）中两大算法分别是分类算法和回归算法，分类算法用于离散型分布预测，回归算法用于连续型分布预测。<br>回归的目的就是建立一个回归方程用来预测目标值，回归的求解就是求这个回归方程的回归系数。<br>其中回归（Regression）算法包括Linear Regression，Logistic Regression等， Softmax Regression是其中一种用于解决多分类（multi-class classification）问题的Logistic回归算法的推广，经典实例就是在MNIST手写数字分类上的应用。</p>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><p>Linear Regression是机器学习中最基础的模型，其目标是用预测结果尽可能地拟合目标label。</p>
<h3 id="多元线性回归模型定义"><a href="#多元线性回归模型定义" class="headerlink" title="多元线性回归模型定义"></a>多元线性回归模型定义</h3><p><img src="http://img.blog.csdn.net/20180211103736126" alt="这里写图片描述"></p>
<h3 id="多元线性回归求解"><a href="#多元线性回归求解" class="headerlink" title="多元线性回归求解"></a>多元线性回归求解</h3><p><img src="http://img.blog.csdn.net/20180211103808629" alt="这里写图片描述"></p>
<h3 id="Mean-Square-Error-MSE"><a href="#Mean-Square-Error-MSE" class="headerlink" title="Mean Square Error (MSE)"></a>Mean Square Error (MSE)</h3><ul>
<li>Gradient Descent（梯度下降法）</li>
<li>Normal Equation（普通最小二乘法）</li>
<li>局部加权线性回归（LocallyWeightedLinearRegression, LWLR<br>)：针对线性回归中模型欠拟合现象，在估计中引入一些偏差以便降低预测的均方误差。</li>
<li><p>岭回归（ridge regression)和缩减方法。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>Normal Equation相比Gradient Descent，计算量大（需计算X的转置与逆矩阵），只适用于特征个数小于100000时使用；当特征数量大于100000时使用梯度法。当X不可逆时可替代方法为岭回归算法。LWLR方法增加了计算量，因为它对每个点做预测时都必须使用整个数据集，而不是计算出回归系数得到回归方程后代入计算即可，一般不选择。</p>
</li>
</ul>
<p>##调优<br> 平衡预测偏差和模型方差（高偏差就是欠拟合，高方差就是过拟合），通常有以下几种解决方案：</p>
<ul>
<li>获取更多的训练样本 - 解决高方差</li>
<li>尝试使用更少的特征的集合 - 解决高方差</li>
<li>尝试获得其他特征 - 解决高偏差</li>
<li>尝试添加多项组合特征 - 解决高偏差</li>
<li>尝试减小 λ - 解决高偏差</li>
<li>尝试增加 λ -解决高方差</li>
</ul>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><p>Softmax Regression估值函数（hypothesis）。<br><img src="http://img.blog.csdn.net/20180211104123217" alt="这里写图片描述"><br>Softmax Regression代价函数（cost function）。<br><img src="http://img.blog.csdn.net/20180211104212230" alt="这里写图片描述"></p>
<p>用实例来表示如下图所示：<br><img src="http://img.blog.csdn.net/20180211104252262" alt="这里写图片描述"></p>
<p>Softmax Regression &amp; Logistic Regression：</p>
<ul>
<li>多分类 &amp; 二分类。Logistic Regression为K=2时的Softmax Regression。</li>
<li>针对K类问题，当类别之间互斥时可采用Softmax Regression，当非斥时，可采用K个独立的Logistic Regression。</li>
</ul>
<p>总的来说， Softmax Regression适用于类别数量大于2的分类，本例中用于判断每张图属于每个数字的概率。</p>
<p>#附录<br><a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">[01]Mnist官网</a><br><a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/" target="_blank" rel="external">[02]Visualizing MNIST: An Exploration of Dimensionality Reduction</a><br><a href="https://www.tensorflow.org/tutorials/layers" target="_blank" rel="external">[03]TensorFlow Mnist官方实例</a><br><a href="https://github.com/martin-gorner/tensorflow-mnist-tutorial" target="_blank" rel="external">[04]Sample code for “Tensorflow and deep learning, without a PhD”</a><br><a href="https://www.youtube.com/watch?v=G4G7dWBi3II" target="_blank" rel="external">[05]Convex functions</a><br><a href="http://52opencourse.com/133/coursera%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E8%AF%BE-%E6%AD%A3%E5%88%99%E5%8C%96-regularization" target="_blank" rel="external">[06]斯坦福大学机器学习第七课-正则化-regularization</a><br><a href="https://github.com/lawlite19/MachineLearning_Python" target="_blank" rel="external">[07]MachineLearning_Python</a><br><a href="https://cs231n.github.io/convolutional-networks/" target="_blank" rel="external">[08]Stanford University’s Convolutional Neural Networks for Visual Recognition course materials 翻译</a><br><a href="http://blog.csdn.net/v_july_v/article/details/51812459" target="_blank" rel="external">[09]July CNN笔记：通俗理解卷积神经网络</a><br><a href="http://www.qiujiawei.com/convolution/" target="_blank" rel="external">[10]理解卷积Convolution</a><br><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="external">[11]Imagenet classification with deep convolutional neural networks</a><br><a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="external">[12]Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a><br><a href="https://mlnotebook.github.io/post/CNN1/" target="_blank" rel="external">[13]Convolutional Neural Networks-Basics</a><br><a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="external">[14]A technical report on convolution arithmetic in the context of deep learning</a><br><a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android" target="_blank" rel="external">[15]Google官方Demo</a><br><a href="https://codelabs.developers.google.com/?cat=TensorFlow" target="_blank" rel="external">[16]Google官方Codelab</a><br><a href="https://hackernoon.com/deep-learning-cnns-in-tensorflow-with-gpus-cba6efe0acc2" target="_blank" rel="external">[17]deep-learning-cnns-in-tensorflow Github</a><br><a href="https://github.com/Nilhcem/tensorflow-classifier-android" target="_blank" rel="external">[18]tensorflow-classifier-android</a><br><a href="https://blog.mindorks.com/creating-custom-model-for-android-using-tensorflow-3f963d270bfb" target="_blank" rel="external">[19]creating-custom-model-for-android-using-tensorflow</a><br><a href="https://github.com/mari-linhares/mnist-android-tensorflow" target="_blank" rel="external">[20]TF-NN Mnist实例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TensorFlow： 1.2.0&lt;/li&gt;
&lt;li&gt;Python： 3.6&lt;/li&gt;
&lt;li&gt;Python I
    
    </summary>
    
      <category term="python" scheme="http://www.xiangzhihong.com/categories/python/"/>
    
    
      <category term="Python" scheme="http://www.xiangzhihong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>iOS关键组件iBoot源代码泄露</title>
    <link href="http://www.xiangzhihong.com/2018/02/07/iOS%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6iBoot%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
    <id>http://www.xiangzhihong.com/2018/02/07/iOS关键组件iBoot源代码泄露/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-11T03:28:28.600Z</updated>
    
    <content type="html"><![CDATA[<p>昨天（2月7日），有匿名开发者在 GitHub 上传了 iOS 核心组件的源代码，这可能会促进黑客和安全研究人员找到 iOS 漏洞，并使 iPhone 陷入危险境地。git地址：<a href="https://github.com/h1x0rz3r0/iBoot。" target="_blank" rel="external">https://github.com/h1x0rz3r0/iBoot。</a><br><img src="http://img.blog.csdn.net/201802082212557" alt="这里写图片描述"><br>不过，8日早上已经看不到相关的源码信息了，该项目已经转为Private，相关信息可以查看下面的链接：<br><a href="https://github.com/github/dmca/blob/master/2018/2018-02-08-Apple.md" target="_blank" rel="external">https://github.com/github/dmca/blob/master/2018/2018-02-08-Apple.md</a></p>
<p>iBoot 是 iOS 关键的源代码之一，在 GitHub 上被标记为“iBoot”，它确保了操作系统的可信任启动，换句话说，它是加载 iOS 的程序，是开启 iPhone 运行的第一个进程，它加载并验证内核是否被苹果正确签名，然后执行，就像 windows系统的 BIOS 一样。</p>
<p><strong>该代码适用于 iOS 9，但是部分代码可能在 iOS 11 中仍有使用。</strong><br>尽管在近几年，iOS 和 macOS 的某些代码已经逐渐开源，但苹果本质上还是非常不乐意向公众开放源代码。而且苹果已经十分注意 iBoot 的安全性和其代码的私密性， 如果通过苹果的赏金计划向其报告启动过程中的 bug，可最高获得 20 万美元。iOS 和 Mac OSX 内部系列书籍的作者 Jonathan Levin 说：“这是 iOS 历史上最大的漏洞，也将是一件大事。”</p>
<p><img src="http://img.blog.csdn.net/20180208221630225" alt="这里写图片描述"></p>
<p>Levin 说代码似乎是真正的 iBoot 代码，因为它与他自己逆向工程的代码一致。熟悉 iOS 的另一位安全研究人员也表示，他们认为代码是真实的，但他们不知道谁在泄漏，苹果到目前为止也没有回应。</p>
<p>Levin 说，通过访问 iBoot 的源代码，iOS 安全研究人员可以更好地找到可能导致设备泄密或越狱的漏洞。这意味着黑客们可以更轻松地找到允许他们破解或解密 iPhone 的漏洞和 bug。也许，这种泄漏最终可能会让高级程序员在非苹果平台上模拟 iOS。</p>
<p>以前版本的 iBoot 中的漏洞使得破解者和黑客可以通过 iPhone 的锁屏解密用户的数据。但是新的 iPhone 有一个名为 Secure Enclave Processor 的芯片，它加强了设备的安全性。</p>
<p>Levin 补充说道，对于普通用户来说，这意味越狱会更加容易。这些越狱过去相对容易实现，并且很普遍，但是现在使用最新的 iOS 设备是非常困难的，这些设备具有先进的安全机制，即使是高技能的研究人员也很难找到 bug，因为他们需要在开始探测设备之前，得先让设备越狱。</p>
<p>这些安全改进已经有效地将曾经流行的越狱社区扼杀在摇篮中。现在，在 iOS 中查找 bug 和漏洞是需要大量时间和资源的，因此产生的漏洞非常有价值。这就是为什么越狱社区会为源代码的泄露或任何公开发布的漏洞而感到兴奋。</p>
<p>这个源代码在去年首次出现，由 Jailbreak subreddit 上的一个名为“ apple_internals ” 的 Reddit 用户发布。这个帖子没有得到太多的关注，因为用户是新的，而且没有足够的 Reddit karma； 这个帖子很快沉下去了。但它在 GitHub 上再次出现意味着它可能在地下越狱社区和 iOS 黑客圈中广泛流传。</p>
<p>Levin 说：“iBoot 是苹果一直坚持的一个组件，他们仍然在加密它的 64 位代码。而现在，它却以源代码形式开放了。”</p>
<p>该文章的英文链接为：<br><a href="https://motherboard.vice.com/en_us/article/a34g9j/iphone-source-code-iboot-ios-leak" target="_blank" rel="external">https://motherboard.vice.com/en_us/article/a34g9j/iphone-source-code-iboot-ios-leak</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天（2月7日），有匿名开发者在 GitHub 上传了 iOS 核心组件的源代码，这可能会促进黑客和安全研究人员找到 iOS 漏洞，并使 iPhone 陷入危险境地。git地址：&lt;a href=&quot;https://github.com/h1x0rz3r0/iBoot。&quot; ta
    
    </summary>
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>区块链游戏大全</title>
    <link href="http://www.xiangzhihong.com/2018/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B8%B8%E6%88%8F%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.xiangzhihong.com/2018/02/01/区块链游戏大全/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-11T03:31:20.671Z</updated>
    
    <content type="html"><![CDATA[<p>“数字货币”和”区块链技术”这两个关键词在互联网平台炒的火热，多数网友在完全不懂金融学和交易技术的情况下，竟全程无障碍地参与了这场”货币大战”，可以说，区块链游戏是继比特币和以太坊技术之后，区块链的有一大实战应用。2017年底到2018年初，数十家互联网公司和竞相推出各类区块链游戏，抢占市场先机，这些新型的区块链游戏有哪些？<br><img src="http://img.blog.csdn.net/20180208135118442" alt="这里写图片描述"></p>
<p>从目前区块链技术的发展形势来看，这类新型游戏非常具备颠覆传统交易方式和投资方式的潜力，但并不是每一个项目都能获得成功。区块链技术到底是什么？为什么具有如此大的魔力？简而言之，区块链技术其实是数字货币的底层技术，是实现”去中心化”的安全交易方式，所谓”去中心化”是指去掉第三方交易平台的权威性，采用全民记账、公开透明的方式形成交易区块，这样的概念传递到游戏行业，便形成了全新的”区块链游戏”形式。</p>
<h2 id="1，百度莱茨狗"><a href="#1，百度莱茨狗" class="headerlink" title="1，百度莱茨狗"></a>1，百度莱茨狗</h2><p><img src="http://img.blog.csdn.net/20180208140521750" alt="这里写图片描述"><br>百度区块链实验室，拥有的企业级区块链解决方案，以及面向用户的应用级区块链解决方案。该实验室深入底层技术、平台化、区块链应用以及前瞻性领域研究，目前的技术已应用于多条核心业务线，支撑了超500亿元资产的真实性问题。同时，该实验室也是Hyperledger的核心董事会成员，致力于提升区块链行业的技术发展，推动全球区块链技术规范和标准的建立。</p>
<h2 id="2，以太猫"><a href="#2，以太猫" class="headerlink" title="2，以太猫"></a>2，以太猫</h2><p><img src="http://img.blog.csdn.net/20180208140434404" alt="这里写图片描述"><br>《Crypto Kitties》是全球最火的区块链游戏之一，也是最早的区块链游戏，于去年11月上线。以网页为载体，游戏特色是利用区块链技术生成基因不同的猫咪，玩家购买猫咪后可交配养育新的小奶猫，每只猫对应着真实的市场价值，运气好的玩家得到稀有特征的小猫能够大赚一笔，目前第一代猫咪市场价格已高达7000多美元，最贵的电子猫市场标价340万美元。这款游戏将”收藏小猫”这种概念转换为新型投资方式，成千上万的用户加入这场货币大战后，电子猫对应的市场价值越来越高，本作的成功为区块链宠物养成类游戏奠定了基调。</p>
<h2 id="3，网易招财猫"><a href="#3，网易招财猫" class="headerlink" title="3，网易招财猫"></a>3，网易招财猫</h2><p><img src="http://img.blog.csdn.net/20180208141117448" alt="这里写图片描述"><br>受《Crypto Kitties》启发，网易开发了这款”云养猫”游戏，目前还处于十分神秘的内测阶段，游戏中预售的猫咪仅限网易娱乐的员工购买，首轮投放1500只，每只售价1000金币，按照10金币等于1元人民币的规则，玩家购买一只初始猫咪需要花费100元，可通过网易、支付宝、微信、QQ等方式支付。这款游戏能不能掀起国内云养猫的热潮，将”区块链游戏玩法”普及开来，还要看上线之后的表现，目前大多数玩家持观望态度，当然，也有不少”投资狂魔”跃跃欲试，毕竟，花100元买到初始猫，如果游戏火了，岂不是赚翻。</p>
<h2 id="4，宝利马"><a href="#4，宝利马" class="headerlink" title="4，宝利马"></a>4，宝利马</h2><p><img src="http://img.blog.csdn.net/20180208141202404" alt="这里写图片描述"></p>
<p>目前大多数区块链游戏都采用”云养宠物”的形式，壕鑫互联借这样的理念打造了一款宠物养成社区游戏，名叫《宝利马》，与”充值购买宠物”式玩法不同，《宝利马》玩家是通过共享资源获取宝利马积分，以此购买区块链技术生成的基因各异的宠物马。宝利马积分用处也不局限于此，用户积累积分后可用于免费体验各类游戏、游戏道具、加速服务、高清直播等服务。</p>
<p>##5，加密狗<br><img src="http://img.blog.csdn.net/20180208141258987" alt="这里写图片描述"><br>《加密狗》基于区块链平台Achain开发，模拟数字货币交易，用区块链生成的宠物狗吸引用户购买，通过收藏、交配和售出的游戏形式为普通群众”科普”典型的区块链玩法。虽然是模仿《加密猫》的游戏，因”新游更具市场潜力”这一特点，《加密狗》上线一周时间项目营收已突破500万美元。</p>
<h2 id="6，玩客猴"><a href="#6，玩客猴" class="headerlink" title="6，玩客猴"></a>6，玩客猴</h2><p><img src="http://img.blog.csdn.net/20180208141800880" alt="这里写图片描述"><br>基于区块链自动生成技术开发的”养猴游戏”于2017年12月27日上线，这是纯中国特色的区块链玩法游戏，因为流通货币是万客日记自家的链克币。玩家绑定链克钱包地址后可购买小猴子，养育需要支付一定费用，但成熟后的小猴市场价值更高，最终的交易价格会参考小猴品质、人工饲养费总额等。另外，小猴生育后玩家获取的小小猴可继续养育和出售喔~</p>
<p>##7，fair.game<br><img src="http://img.blog.csdn.net/20180208141936394" alt="这里写图片描述"><br>fair.game是基于以太坊智能合约的游戏平台，与”养猫养狗养马养鱼”的宠物养成类游戏不同，这款游戏平台上线的游戏类型多数偏”赌博化”，赌博形式和支付方式采用区块链技术理念，更加安全和公正，目前平台支持老虎机、德州扑克等游戏。</p>
<p>##8，宠物星球<br><img src="http://img.blog.csdn.net/20180208142146494" alt="这里写图片描述"><br>各大厂商都在做区块链宠物，但大多局限于”某一种”生物，GAME网团队另出新意，直接做了一家区块链宠物店，这里的宠物应有尽有，花样十足。《宠物星球》基于波场TRON区块链技术开发，用户购买的宠物和其他数字资产永久保存在个人名下，单个宠物基础售价：200波场比TRON。</p>
<p>##9，以太小怪兽<br><img src="http://img.blog.csdn.net/20180208142258287" alt="这里写图片描述"><br>以太坊全新的区块链游戏玩法，游戏模式类似《口袋妖怪》，玩家在Etheremon的世界中通过花费以太币一定概率抓取怪兽，各种形态的小怪兽们个性十足，外形呆萌可爱。除了养育玩法，玩家在游戏中可训练自家”宠物”与对手战斗。这款游戏一经推出风靡互联网平台，成千上万用户竞相涌入平台认购怪兽，直接导致以太坊网络拥堵，交易速度降低，该游戏主要集中在国外的一些玩家。</p>
<p>##10，区块企鹅<br><img src="http://img.blog.csdn.net/2018020814234944" alt="这里写图片描述"><br>基于《以太猫》的玩法，许多厂商开发出很多”云养宠物”的区块链游戏，日本某团队推出的《Cloudpenguins》也是同样的类型。《Cloudpenguins》游戏通用货币是CPC，采用传统的区块链宠物生成法则，每只企鹅都有独立的基因和个性，在此基础上，附加宠物蛋新玩法，玩家在进行企鹅繁殖时能够有一定几率得到宠物蛋，宠物蛋有可能孵化出更稀有的企鹅，这算是”意外淘金”的玩法。</p>
<p>区块链技术的透明、公正性颠覆了传统认知，革新了市场投资方向，电子宠物不再是一堆”Crtl C”+”Cryl V”的虚拟数据，通过区块链的操控方式，宠物们仿佛是真正”活了过来”，并在市场上拥有了真实价值。腾讯某高管曾经表示，游戏的最终目的是打破虚拟与现实之间的壁垒，如今这类游戏的繁盛，是否在一定程度上接近了”游戏真谛”呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“数字货币”和”区块链技术”这两个关键词在互联网平台炒的火热，多数网友在完全不懂金融学和交易技术的情况下，竟全程无障碍地参与了这场”货币大战”，可以说，区块链游戏是继比特币和以太坊技术之后，区块链的有一大实战应用。2017年底到2018年初，数十家互联网公司和竞相推出各类区
    
    </summary>
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://www.xiangzhihong.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Google发布Android KTX预览版</title>
    <link href="http://www.xiangzhihong.com/2018/01/29/Google%E5%8F%91%E5%B8%83Android%20KTX%E9%A2%84%E8%A7%88%E7%89%88/"/>
    <id>http://www.xiangzhihong.com/2018/01/29/Google发布Android KTX预览版/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-02-11T03:30:27.510Z</updated>
    
    <content type="html"><![CDATA[<p>前天，Google 发布了 <a href="https://github.com/android/android-ktx" target="_blank" rel="external">Android KTX</a> 预览版，Android KTX 是一组扩展程序，它能使 Android 上的 Kotlin 代码更简洁，从而提高开发者的编程体验。</p>
<p>大家知道，Google在2017年的Google I/O大会上将Kotlin列为第一开发语言之后，便不遗余力的支持Kotlin。Android KTX 中支持 Android 框架的部分现在可在 GitHub 库中找到，同时，Google 承诺在即将到来的支持库版本中提供涵盖 Android 支持库的 Android KTX 的其他部分。那么，相比于通用的Kotlin，Android KTX究竟做了哪些方面的优化呢，下面通过一些示例来简单对比下。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h3 id="字符串转换为-URI"><a href="#字符串转换为-URI" class="headerlink" title="字符串转换为 URI"></a>字符串转换为 URI</h3><p>通常情况下为 Uri.parse(uriString)，但是 Android KTX 会为字符串添加一个扩展函数，使字符串更加自然地转换为 URI。<br><img src="http://img.blog.csdn.net/20180207104354052" alt="这里写图片描述"></p>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>编辑 SharedPreferences 是非常常见的用例，使用 Android KTX 后，代码稍微短些，能更自然地读取和写入。<br><img src="http://img.blog.csdn.net/20180207104458907" alt="这里写图片描述"></p>
<h3 id="平移路径差异"><a href="#平移路径差异" class="headerlink" title="平移路径差异"></a>平移路径差异</h3><p>例如，下面是将两个路径之间的距离改变了 100px。<br><img src="http://img.blog.csdn.net/20180207104619428" alt="这里写图片描述"></p>
<h3 id="在视图onPreDraw-的动作"><a href="#在视图onPreDraw-的动作" class="headerlink" title="在视图onPreDraw 的动作"></a>在视图onPreDraw 的动作</h3><p>下面的示例触发了视图中 onPreDraw 的回调，如果没有 Android KTX，你需要编写相当多的代码。<br><img src="http://img.blog.csdn.net/20180207104930125" alt="这里写图片描述"></p>
<p>除了上面介绍的一些API之外，还有很多其他的特性，详细的介绍读者可以访问Android KTX开源地址：<a href="https://github.com/android/android-ktx。" target="_blank" rel="external">https://github.com/android/android-ktx。</a></p>
<h1 id="Android集成"><a href="#Android集成" class="headerlink" title="Android集成"></a>Android集成</h1><p>要在你的 Android Kotlin 项目中开始使用 Android KTX，需要在应用模块 build.gradle的脚本文件中添加以下配置脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">repositories &#123;</div><div class="line">    google()</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation &apos;androidx.core:core-ktx:0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在同步项目之后，这些扩展将自动出现在 IDE 的自动完成列表中，选择扩展程序会将必要的导入语句添加到你的文件中。</p>
<p><strong>注意</strong>：不过需要注意的是，Android KTX目前还是一个预览版本，预览期间 API 可能会发生变化，也就是说，在正式版到来之前，不要在重要的 Android 项目中使用它，因为正式版可能会发生一些变化。</p>
<h1 id="Android-KTX未来发展趋势"><a href="#Android-KTX未来发展趋势" class="headerlink" title="Android KTX未来发展趋势"></a>Android KTX未来发展趋势</h1><p>Google 表示，现在的预览版本是一个开始，在接下来的几个月里，他们会根据开发者的反馈和贡献加入 API 进行迭代，当 API 稳定后，Google 会承诺 API 的兼容性，并计划将 Android KTX 作为 Android 支持库的一部分。</p>
<p>1，可以通过如下地址来提交相关的建议和修改意见：<br><a href="https://github.com/android/android-ktx/issues/new" target="_blank" rel="external">https://github.com/android/android-ktx/issues/new</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天，Google 发布了 &lt;a href=&quot;https://github.com/android/android-ktx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android KTX&lt;/a&gt; 预览版，Android KTX 是一组扩展程序，它能使
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenCV的跳一跳外挂实现原理</title>
    <link href="http://www.xiangzhihong.com/2017/12/27/%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E8%B7%B3%E4%B8%80%E8%B7%B3%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://www.xiangzhihong.com/2017/12/27/基于OpenCV的跳一跳外挂实现原理/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:17:06.972Z</updated>
    
    <content type="html"><![CDATA[<p>最近，微信跳一跳小游戏迅速走红并且在朋友圈刷屏，游戏的规则很简单，就是控制一个小矮子再各个墩子上跳来跳去。由于游戏比较简单，一时间大家都玩起来了，这也带动了一些作弊的产生。Android和iOS的小程序都可以刷分，如果想要刷分，可以参考下面这个开源项目：<a href="https://zhuanlan.zhihu.com/p/32452473" target="_blank" rel="external">Python刷分</a>。<br><img src="http://img.blog.csdn.net/20180123152801301" alt="这里写图片描述"><br>今天要给大家讲的是如何使用OpenCV来给Android小程序刷分。<br>其实，刷分的思路都是一致的：通过Android手机的ADB来截取屏幕，然后通过对截图进行分析，算出来玩家与下一个落脚点的距离，然后通过距离算出来需要按压多长时间的屏幕，之后再通过发送ADB指令来模拟按下屏幕达到自动刷分的目的。也就是说，这个外挂的核心就是取得玩家与下一个落脚点的距离，有了距离之后，一切都好说了。</p>
<h2 id="OpenCV简介"><a href="#OpenCV简介" class="headerlink" title="OpenCV简介"></a>OpenCV简介</h2><p>OpenCV熟悉编程的人一定知道，是一个著名的开源计算机视觉库，实现了图像处理和计算机视觉方面的很多通用算法。要想在Python上运行OpenCV只需要使用pip安装就好，在Terminal中执行pip install opencv-python即可。OpenCV的官网地址为：<a href="https://opencv.org/。" target="_blank" rel="external">https://opencv.org/。</a></p>
<p>使用OpenCV时一般是用于分析图片灰度图，因为我这里需要画框划线进行标记，所以为了方便就直接读RGB彩图了，这样因为一个像素三个通道所以会慢一点，之后投入使用直接分析灰度图就好。</p>
<p>##实践</p>
<p>下面就来看看如何使用OpenCV来完成Android的跳一跳如何刷分吧。</p>
<h3 id="1，玩家位置识别"><a href="#1，玩家位置识别" class="headerlink" title="1，玩家位置识别"></a>1，玩家位置识别</h3><p>首先需要做的就是识别玩家的位置，玩家的形状不变，是一个紫色的棋子，那么可以使用OpenCV带有的图像模板匹配来找出玩家的位置。首先来一个图片，如下：<br><img src="http://img.blog.csdn.net/20180123154748138" alt="这里写图片描述"></p>
<p>然后就可以使用Python读取了，对于游戏场景，我们使用下图为例，名字为1.png。<br><img src="http://img.blog.csdn.net/20180123155005836" alt="这里写图片描述"></p>
<h4 id="1-1图像模板匹配"><a href="#1-1图像模板匹配" class="headerlink" title="1.1图像模板匹配"></a>1.1图像模板匹配</h4><p>在OpenCV中调用matchTemplate函数即可实现模板匹配。<br><img src="http://img.blog.csdn.net/20180123155356228" alt="这里写图片描述"></p>
<p>相关的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import cv2 as cv</div><div class="line"></div><div class="line">img = cv.imread(&quot;1.png&quot;)</div><div class="line">player_template = cv.imread(&apos;player.png&apos;)</div><div class="line">player = cv.matchTemplate(img, player_template, cv.TM_CCOEFF_NORMED)</div><div class="line"></div><div class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(player)</div></pre></td></tr></table></figure>
<p>通过调用上面的代码即可进行模板匹配，最后一行的max_loc则是匹配出来的位置，因为玩家是一个宽度50高度150像素的图形（在我的iPhone 6s上）。所以再添加以下代码来框出玩家位置。并且画出了玩家的点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">corner_loc = (max_loc[0] + 50, max_loc[1] + 150)</div><div class="line">player_spot = (max_loc[0] + 25, max_loc[1] + 150)</div><div class="line">cv.circle(img, player_spot, 10, (0, 255, 255), -1)</div><div class="line">cv.rectangle(img, max_loc, corner_loc, (0, 0, 255), 5)</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, img)</div><div class="line">cv.waitKey(0)</div></pre></td></tr></table></figure>
<p>之后再运行，这时会打开一张片，可以看见玩家的位置已经被识别出来了。<br><img src="http://img.blog.csdn.net/20180123162715531" alt="这里写图片描述"></p>
<h3 id="2，落脚点识别"><a href="#2，落脚点识别" class="headerlink" title="2，落脚点识别"></a>2，落脚点识别</h3><p>接下来就要识别落脚点了，但是蹲蹲千变万化，有方形的，有圆形的。所以刚才的模板识别就用不上了，即使使用的话成功率也很低，这个时候就需要用到边缘检测了。</p>
<p>####2.1 Canny边缘检测<br>OpenCV带有Canny算法的实现来帮助我们得到图形的边缘。在做边缘检测之前首先需要对图片进行高斯模糊处理，高斯模糊主要作用就是去除噪声。因为噪声也集中于高频信号，很容易被识别为边缘。高斯模糊可以降低伪边缘的识别。但是由于图像边缘信息也是高频信号，高斯模糊的半径选择很重要，过大的半径很容易让一些弱边缘检测不到。<br><img src="http://img.blog.csdn.net/20180123162913607" alt="这里写图片描述"></p>
<p>例如，下面是示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img_blur = cv.GaussianBlur(img, (5, 5), 0) #高斯模糊</div><div class="line">canny_img = cv.Canny(img_blur, 1, 10) #边缘检测</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, canny_img)</div></pre></td></tr></table></figure>
<p>然后图片就会被边缘识别，这个图是灰度图，每一个像素是 0-255之间任意一个值，黑色为0白色为255。<br><img src="http://img.blog.csdn.net/20180123163350644" alt="这里写图片描述"></p>
<h4 id="2-2图片切片"><a href="#2-2图片切片" class="headerlink" title="2.2图片切片"></a>2.2图片切片</h4><p>其实现在我们已经可以开始分析边缘来找到下一个落脚点了，但是图片中边缘实在是太多，可以通过裁切图片来，首先要知道，下一个落脚点肯定是在整个界面的上1/2。也就是说，图片的下半段可以不要，而且，上面的记分牌也没有任何用处。<br><img src="http://img.blog.csdn.net/20180123163717547" alt="这里写图片描述"></p>
<p>执行以下代码来切除上面的300像素的高度加下半部分图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">height, width = canny_img.shape</div><div class="line">crop_img = canny_img[300:int(height/2), 0:width]</div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, crop_img)</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180123163905648" alt="这里写图片描述"></p>
<h4 id="2-3消除玩家图片"><a href="#2-3消除玩家图片" class="headerlink" title="2.3消除玩家图片"></a>2.3消除玩家图片</h4><p>但是有一点还是很烦，上图的左下角还有一部分玩家的头部，有时候如果玩家需要向左上角跳，这个头的存在可能会造成一定的干扰，所以需要写代码消除它，因为我们已经知道了玩家的坐标了，所以把那个范围的像素全设成0就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for y in range(max_loc[1], max_loc[1]+150):</div><div class="line">    for x in range(max_loc[0], max_loc[0]+50):</div><div class="line">        canny_img[y][x] = 0</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180123164101930" alt="这里写图片描述"></p>
<h4 id="2-4落脚点判断"><a href="#2-4落脚点判断" class="headerlink" title="2.4落脚点判断"></a>2.4落脚点判断</h4><p>现在只剩下敦敦的边缘了，现在需要得到他的中心点，仔细观察这个图形，发现他是一个菱形，并且有两个点是很容易通过遍历像素点然后分析得到的。<br><img src="http://img.blog.csdn.net/20180123164220374" alt="这里写图片描述"></p>
<p>A点B点是很容易得到的，通过由上到下，由左到右遍历全部像素，A点应该是便利顺序的像素中第一个值为255的点，B点是便利顺序中第一次横坐标最大的点。得到了A,B点的坐标，整个形状的中点 （X3， Y3）其实就是 （X1，Y2）。</p>
<p>可以通过如下代码来判断中心点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">crop_h, crop_w = crop_img.shape</div><div class="line">center_x, center_y = 0, 0</div><div class="line"></div><div class="line">max_x = 0</div><div class="line"></div><div class="line">for y in range(crop_h):</div><div class="line">    for x in range(crop_w):</div><div class="line">        if crop_img[y, x] == 255:</div><div class="line">            if center_x == 0:</div><div class="line">                center_x = x</div><div class="line">            if x &gt; max_x:</div><div class="line">                center_y = y</div><div class="line">                max_x = x</div><div class="line">                </div><div class="line">cv.circle(crop_img, (center_x, center_y), 10, 255, -1)</div><div class="line"></div><div class="line">cv.namedWindow(&apos;img&apos;, cv.WINDOW_KEEPRATIO)</div><div class="line">cv.imshow(&quot;img&quot;, crop_img)</div><div class="line">cv.waitKey(0)</div></pre></td></tr></table></figure>
<p>执行上面的代码，发现程序已经标出了中心点：<br><img src="http://img.blog.csdn.net/20180123164609536" alt="这里写图片描述"></p>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>好了，看一下运行的效果吧。<br><img src="http://img.blog.csdn.net/20180123164746270" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180123164822533" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180123164909107" alt="这里写图片描述"><br>相关源码链接如下：<a href="http://download.csdn.net/download/xiangzhihong8/10220160" target="_blank" rel="external">http://download.csdn.net/download/xiangzhihong8/10220160</a></p>
<p>其实，细心的读者可以发现，图片的中心并非处于绝对的中心位置，大家可以在源码的基础上修改参数的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，微信跳一跳小游戏迅速走红并且在朋友圈刷屏，游戏的规则很简单，就是控制一个小矮子再各个墩子上跳来跳去。由于游戏比较简单，一时间大家都玩起来了，这也带动了一些作弊的产生。Android和iOS的小程序都可以刷分，如果想要刷分，可以参考下面这个开源项目：&lt;a href=&quot;h
    
    </summary>
    
      <category term="Python" scheme="http://www.xiangzhihong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xiangzhihong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2017移动开发年终盘点</title>
    <link href="http://www.xiangzhihong.com/2017/12/27/2017%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%B9%B4%E7%BB%88%E7%9B%98%E7%82%B9/"/>
    <id>http://www.xiangzhihong.com/2017/12/27/2017移动开发年终盘点/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:20:46.611Z</updated>
    
    <content type="html"><![CDATA[<p>2017年已经过了大半个月，2017年移动端经历了哪些大事件呢，现在总结如下。</p>
<h1 id="Android-技术动态"><a href="#Android-技术动态" class="headerlink" title="Android 技术动态"></a>Android 技术动态</h1><p>在今年 Google I/O 大会上，谷歌 CEO Sundar Pichai 宣布谷歌的正在从“移动为首位”转变为“AI 高于一切”，所以与往年的开发者大会相比，今年会议的大部分内容都围绕 AI 展开，如 Google 将开放 Tensor Flow、TPU 等软硬件工具给开发者，还发布了一系列人工智能产品如：Google Lens、Google Asistant、Google Home 等，并提出了 Google.ai 计划，相比之下，Android 的内容就少了很多，这也意味着谷歌正在 Android 的基础上逐渐构建自己的人工智能生态系统。在本次大会上，谷歌宣布 Android 的活跃设备数达到了 20 亿，这意味着 Android 系统已成移动行业的霸主。</p>
<h2 id="1-Android-8-0-发布"><a href="#1-Android-8-0-发布" class="headerlink" title="1. Android 8.0 发布"></a>1. Android 8.0 发布</h2><p>今年最受 Android 开发者期待的莫过于 Android 8.0 了，在经过 4 个开发者预览版的洗礼后，北京时间 8 月 22 日谷歌发布了 Android 8.0 的正式版，取名 Android Oreo（奥利奥），简称 Android O，“奥利奥”的名字沿袭了谷歌以甜品取名操作系统的传统。相对上一代版本，Android 8.0 的功能、流畅性和安全性都有了很大地提升，主要表现在以下几个方面：<br><img src="http://img.blog.csdn.net/20180117174856189" alt="这里写图片描述"></p>
<p>   <strong>功能：</strong></p>
<ul>
<li>画中画：支持将手机的电影屏幕缩小成悬浮窗口，在看电影的同时可进行其他应用程序的操作；</li>
<li>Notification Dots：App 在接收通知后，将在图标的右上角生成一个圆形的小点，长安圆点即可显示该 App最近通知，滑动即可清除，无需经过通知栏；</li>
<li>即时应用：这个与微信小程序类似，App 无需安装也可通过点击网址打开 App，不过前提是访问的这个 App 支持这个功能，由于Android Instant Apps 是基于 Google Play 服务构建的，所以国内的 Android 用户暂时无法享用此功能；</li>
<li><p>智能文字选取：能检测出选取的文字是地址还是电话号码，并会根据选取的文字类型打开对应的应用，如地图或拨号功能。</p>
<p><strong>流畅性</strong>：<br>据谷歌透露，Pixel 在 Android 8.0 下的开机速度比上一代系统快了 2 倍；而且针对各种流氓 App 采取严格的控制，不常用的 App 会被强制停止，节省手机耗电量和提高手机流畅性；</p>
<p><strong>安全性：</strong><br>谷歌在 Android 8.0 中内置了 Play Protect 服务，能够自动扫描手机中潜在的恶意 App。</p>
</li>
</ul>
<h2 id="2-Android-studio-3-0-发布"><a href="#2-Android-studio-3-0-发布" class="headerlink" title="2. Android studio 3.0 发布"></a>2. Android studio 3.0 发布</h2><p>10 月 25 日，Android Studio 3.0 正式版发布，此版本将支持 Kotlin 编程语言、支持 Java 8 语言功能、支持 XML 字体预览、支持 Instant App、支持配置和调试 APK 等。其中，开发人员不再需要通过 Android Studio 的插件就可直接在 Android Studio 3.0 中使用 Kotlin，包括重构、自动完成、lint、调试等操作。</p>
<p>##3. ARCore 发布<br>8 月 29 日，Google 了发布构建 AR 应用平台 ARCore，这个项目被看做是 Google 与苹果在 AR 领域上的较量，因为苹果 6 月也推出了 AR 框架 -ARKit，所以 ARKit 也被认定为 ARCore 的对标。而在此之前，谷歌也曾研发过一个 AR 平台 Tango，但由于 Tango 对硬件设备有限制，各方面的性能也比不上 ARCore。在今年 12 月 15 日，谷歌宣布将从 2018 年 3 月 1 日起停止对旗下 AR 平台 Tango 的支持，以后将专注于 ARCore 平台的研究，在 AR 上大展拳脚，不知道将来在 AR 领域的 ARCore 与 ARKit 会不会像现在的 Android 和 iOS 一样各占半壁江山，让我们拭目以待吧。</p>
<h2 id="4-Kotlin-成为-Android-开发一级编程语言"><a href="#4-Kotlin-成为-Android-开发一级编程语言" class="headerlink" title="4. Kotlin 成为 Android 开发一级编程语言"></a>4. Kotlin 成为 Android 开发一级编程语言</h2><p>由于 Kotlin 比 Java 更安全——能够静态检测常见的缺陷、更简洁，而且能兼容 Java 等优点，使它能够短短几年在众多竞争中脱颖而出，成为开发者们的香饽饽。尤其是在今年的 Google 在大会上，谷歌宣布 Kotlin 成为 Android 开发的一级编程语言后，江湖上就开始流传 Java 将被 Kotlin 取代的说法，各大论坛的 Java 与 Kotlin 大战由此展开，各类站队的文章也层出不穷，好不热闹。</p>
<p>11 月初，第一届 Kotlin 的专题会议 KotlinConf 在旧金山开幕，会议上 Kotlin 首席设计师 Andrey Breslav 宣布 Kotlin 将要支持 iOS 和 Web 开发，这也被称做 kotlin 与 Swift 在支持全栈开发上的较量，此消息一出，引发了不少开发者的热议，有开发者表示，kotlin 要想拿下 iOS 估计不是那么容易的事情，毕竟苹果对自己的生态有严格的把控，苹果是不会轻易地给 Swift 的竞争对手机会的，也有人认为 Kotlin 应该先把 Android 的坑填完再去扩张，跨步太大容易摔跤。</p>
<p>但是，不管将来 Kotlin 将来能否统一江湖，但是从目前来看，Kotlin 有了谷歌这座靠山，它的前景还是值得期待的！</p>
<h2 id="5-国内安卓统一推送联盟成立"><a href="#5-国内安卓统一推送联盟成立" class="headerlink" title="5. 国内安卓统一推送联盟成立"></a>5. 国内安卓统一推送联盟成立</h2><p>2017 年 10 月 16 日，安卓统一推送联盟大会在京举办，此次大会由中国工信部旗下的中国信息通信研究院泰尔终端实验室主办，多个互联网企业和手机制造企业出席，并宣布百度、阿里、腾讯、华为、小米、OPPO、vivo、个推为联盟的副理事长单位。</p>
<p>“安卓统一推送联盟”的正式成立标志着安卓手机 App 自启和应用间相互唤醒的毛病将得到改善，国内安卓生态的混乱状态将得到有效解决。未来，安卓手机推送消息时，不必唤醒手机应用，从而保证 App 在未被使用时处于休眠状态，节省手机的内存和电量，安卓用户的体验将更加贴近 iOS。</p>
<h1 id="iOS-技术动态"><a href="#iOS-技术动态" class="headerlink" title="iOS 技术动态"></a>iOS 技术动态</h1><p>苹果 WWDC2017 大会何于 6 月 6 日在圣何塞 McEnery 会议中心召开，苹果发布了四大系统 WatchOS 4、macOS High Sierra、tvOS、iOS 11 的更新，每个系统相较上一个版本都有很大的提升。</p>
<h2 id="1-iOS-11-发布"><a href="#1-iOS-11-发布" class="headerlink" title="1. iOS 11 发布"></a>1. iOS 11 发布</h2><p>iOS 11 于 9 月 13 日凌晨正式发布，9 月 20 日全球正式开放下载，iOS 11 相对上一个版本主要有以下更新：</p>
<ul>
<li>iMessage: 新的 iMessage 集成了 iCloud 功能，所有的信息都能通过 iCloud同步，可删除本地信息，仅存于云端，优化手机本地内存；</li>
<li>Apple Pay: 支持点对点支付，可直接给对方付款，就像微信支付一样方便；</li>
<li>Siri：Siri 的发音将更加自然，并加入了男声，Siri 在 iOS 11中已经内置翻译功能，可以将英语翻译成汉语、法语、德语、意大利语以及西班牙语。除了语音之外，在 iOS 11 系统中，用户还可以通过打字跟 Siri 进行沟通；</li>
<li>支持 AR：在 iOS 11 中，还有一个令人期待的功能 AR，iOS 11 带来了 ARKit，这是苹果全新的 AR应用平台，开发者可以使用内置的摄像机、传感器和处理器在 iOS 设备上开发 AR 体验的应用。</li>
</ul>
<p>此次除了功能上的更新外，根据苹果最新的规定，从 2018 年 1 月 1 日起，iOS 11 将全面停止 32 位应用程序，意味着从 2018 年开始，升级 iOS 11 正式版的系统后，目前 App Store 里的 18.7 万款 32 位的应用将无法搜到或无法打开，而对消费者而言，iPhone 5 和其他仅支持 32 位系统苹果手机将会面临淘汰。</p>
<p>其实早在今年 6 月份，苹果就开始透露了这个消息，而在更早的 2015 年，苹果就向开发者传递了 64 位应用的优势，也暗示着让开发者开发 64 位的应用程序来适配 iPhone 5s 之后的新系统，所以就目前来讲，很多应用基本上都已经有了 64 位的版本，很多仍停留在 32 位的大多都是比较冷门的应用，对用户来说也不是必备的，所以总的来说，影响不会太大。</p>
<h2 id="2-Swift-4-0-发布"><a href="#2-Swift-4-0-发布" class="headerlink" title="2. Swift 4.0 发布"></a>2. Swift 4.0 发布</h2><p>Swift 4.0 在 2017 年 9 月 19 日正式发布，最新的版本主要针对语言本身以及标准库的大量改动和更新，最重要的变化包括新增的 String 功能、扩展集合、归档和序列化等。关于Swift 4.0的相关知识，可以查看如下的链接：<a href="http://swift4.cc/" target="_blank" rel="external">Swift 4.0中文版</a></p>
<p>##3. 苹果“热修复”门事件<br>今年苹果在移动法规上最大的新闻估计就是“热修复”门事件了，今年三月，苹果向所有开发者推送警告邮件，宣布将禁用 App 内部的“动态分发”功能，并要求开发者在自家 App 中删除 JSPatch、Rollout 等相关框架，否则 App 将面临下架或禁止在 App Store 上架。</p>
<p>这一动作，意味着苹果对“热更新”判了死刑，对用户而言，未来更新应用都需重新下载完整的新版数据包。对国外的开发者影响不大，因为国外的开发流程很规范，再者，国外的 Google Play 也一直是禁止热修复的， 基本不会用热修复进行迭代，基本都是一次性交付。</p>
<p>但对国内的开发者而言，这却是致命的打击，由于之前的“热修复”可以直接通过服务器推送并进行下载迭代，可以避开苹果的“二次审核”，App 就能早日上线盈利，但从今以后，这样的“福利”再也没有了。</p>
<p>从根本上来说，还是因为“热更新”破坏了 iOS 生态的“安全性”与“可控性”，这对苹果来说，是无法容忍的。</p>
<h1 id="移动开发热门话题-TOP5"><a href="#移动开发热门话题-TOP5" class="headerlink" title="移动开发热门话题 TOP5"></a>移动开发热门话题 TOP5</h1><p>2017年移动最热门的话题莫过于：移动 AI、性能优化、移动架构、Kotlin、AR/VR。</p>
<p> <strong>移动 AI</strong><br>今年毫无疑问是 AI 年，各种其它领域都羡慕嫉妒恨的想跟 AI 扯上关系，移动也不例外。语音交互的成熟催生了 CUI，另外端上的 AI 也的确是一个趋势，因此有了很多与此相关的分享。</p>
<p>移动电商中的图像算法应用<br>用人工智能来高效测试 App<br>利用 CNN 实现无需联网的智能图像处理<br>对话式交互：从开端到成长<br>基于卷积神经网络在手机端实现文档检测<br>App 如何与 AI 共舞 —AI 为 App 开发赋能<br>深度学习在手机端的应用<br>移动端设备上的深度学习：Android 设备上 TensorFlow 应用与实现<br>安卓车载系统创新功能<br>轻量级 DNN 网络在 Android 上的视觉应用<br>人工智能技术及在移动端应用<br>足球游戏的 AI 实现<br>深度学习在移动端的应用<br>使用 TensorFlow 搭建智能开发系统，自动生成 App UI 代码<br>移动端全机型传感器的自适应计步算法设计</p>
<p> <strong>性能分析与优化：</strong><br>性能优化在移动开发中是一个长盛不衰的话题，移动架构一复杂起来，必然出现性能瓶颈，这时就要去做分析和优化。而在性能分析这一块，APM 越来越受到重视，不少公司都自建了 APM 系统。</p>
<p>iOS App 内存专项实践：封闭系统下的大自由<br>手淘 iOS 性能优化探索<br>Android 系统开机时间优化<br>优化 Android 应用程序的桌面体验<br>360 手机卫士性能提升攻略<br>移动端性能监控方案 Hertz<br>从无到有实现一个性能监控平台是怎样一种体验？<br>移动网络性能优化<br>Android 启动优化 - 异步 dex 加载<br>滴滴出行 iOS 端瘦身实践</p>
<p> <strong>移动架构</strong><br>17 年以来，移动架构很少有大的革新，连 Rx 和函数式的分享都少了不少，感觉架构更加像是一个拓荒的工作，一旦稳定，事情就比较少了。不过架构还是很重要的，选错型的话只能流泪跪着走完了。</p>
<p>共享代码衍生多款应用的定制框架之经验分享<br>58 同城 Android 客户端 Walle 框架演进与实践之路<br>豌豆荚的反作弊技术架构与设计<br>美团点评移动端底层架构实践<br>Android DataBinding:MVVM 架构基石，数据驱动 APP 运转<br>美团客户端架构演进之路<br>Atlas: 手机淘宝 Android 架构实践<br>AOP 技术在 APP 架构上的应用<br>一个 5800 行文件的重构历程</p>
<p> <strong>Kotlin</strong><br>今年也是 Kotlin 年，在 Google IO 之后 Kotlin 着实风光了一把，开发者对于效率的追求是 Kotlin 如此受欢迎的最大原因，而它的势头也很不错，跨平台的野心让更多人有了使用它的理由，如今看起来，它甚至比 Swift 更有前途。</p>
<p>Kotlin from zero to how can it help me?<br>Kotlin 在 Android 开发中最佳实践探讨<br>开发效率的抉择：将 Kotlin 投入 Android 生产环境中<br>Kotlin 跨平台，还有 Native<br>从 Java 到 Kotlin，当机器人不再喝咖啡后<br>用 Kotlin 定制自己的 DSL<br>Android 开发从 Java 到 100% Kotlin 项目实战总结</p>
<p> <strong>AR/VR</strong><br>随着 AI 的落地和苹果谷歌的力推，AR 逐渐来到了我们的身边，最常见的就是各种美颜、直播 App 里的贴纸、表情、试妆等，都是 AR 的应用。AR 作为垂直领域已经值得投入了。</p>
<p>AR/VR 的未来技术趋势<br>Introduction to Google ARCore<br>移动互联网时代的 VR 技术之路<br>从 2D 到 3D，AR 发展中的关键技术<br>如何利用 CPU 计算能力实现更沉浸的 VR 体验<br>虚拟现实产业中 Android 的现状、未来和挑战</p>
<p>2017 年移动开发的公开分享明显减少了，原因这里不多说，对于移动开发者来说，真是听一个少一个，向每一个分享者致敬！</p>
<p>在新的一年里，移动开发前线仍会持续关注移动技术动态，也欢迎开发者继续关注移动开发前线。想知道过去一年国内代表性公司在移动开发上都做了哪些工作，以及 2018 年值得你关注的移动技术有哪些？请见下回分解~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年已经过了大半个月，2017年移动端经历了哪些大事件呢，现在总结如下。&lt;/p&gt;
&lt;h1 id=&quot;Android-技术动态&quot;&gt;&lt;a href=&quot;#Android-技术动态&quot; class=&quot;headerlink&quot; title=&quot;Android 技术动态&quot;&gt;&lt;/a&gt;And
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>号外，号外，《React Native移动开发实战》出版啦</title>
    <link href="http://www.xiangzhihong.com/2017/12/25/%E5%8F%B7%E5%A4%96%EF%BC%8C%E5%8F%B7%E5%A4%96%EF%BC%8C%E3%80%8AReact%20Native%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E5%87%BA%E7%89%88%E5%95%A6/"/>
    <id>http://www.xiangzhihong.com/2017/12/25/号外，号外，《React Native移动开发实战》出版啦/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-02-11T03:21:05.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对不起，我来晚了"><a href="#对不起，我来晚了" class="headerlink" title="对不起，我来晚了"></a>对不起，我来晚了</h1><p>首先要感谢支持和关注我的朋友，感谢人邮的赵老师，还有公司的领导和同事，他们在我写作的过程中给了很多有用的信息，也给了很多有用的建议，为本书的写作提供了很大帮助。感谢，再次感谢！！！</p>
<p>工作6年多以来，一直想写一本自己的书，一方面是对自己工作经历的一个总结，也是对希望写一本书给曾经的自己一个交代，毕竟30岁的人了，搞不了几年的技术了。</p>
<p>我一直有写博客的习惯，喜欢将自己工作和生活的点滴写成博客，分享给大家。说说我写书的缘由吧，最近几年，特别是15年和16年，我朋友圈的好友陆续出了自己的书，出于“跟风”吧，我也打算写一本，不过当时只是规划，没有具体实施。正好17年的1月份，一个人邮出版社的杨老师在csdn上给我留言，问我有没有兴趣写一本书，我问他写什么呢，他说要不就写React Native吧。说实话，那时候我对React Native并不是很熟悉，只是平时工作之余会学习相关的技术，在那之前，我一直从事的是Android和ios开发工作（搞了差不多6年了），虽然之前对React Native也有一定的了解，但深入还是不够的。于是前两个月我都写的很慢，一方面是公司的原因，一方面是对于写作没有很多的心理准备，17年的头两个月我勉强把样张写出来了，然后给出版社了，真正步入写作正轨的是4月份。新年刚过完，我把手头的工作分给了我的同事，手头事情不多，于是我加快了写作的步伐，一个月差不多能完成4章。</p>
<p>历时近6个月的写作，三个月的校验，千呼万唤始出来，第一本书终于出版了，虽然写作中经历了种种曲折，最终还是赶在11月份的出版了。<br><img src="http://img.blog.csdn.net/20171204201408112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在这里要给出版社和自己道歉，本来之前是打算在9月上线的，为的是赶上React Native开发的热潮，结果由于很多未知的原因，一拖再拖，让很多朋友都久等了。</p>
<h1 id="写书之前"><a href="#写书之前" class="headerlink" title="写书之前"></a>写书之前</h1><p>其实，写作之前我一直是拒绝的，写书不仅耗时，而且得到的回报也是不成比例的，搞开发的很多人都知道，写书不如去讲课，那钱比出书来的容易多了。写作之前，我还特意咨询了搞Android的邓平凡老师和搞iOS的关东升老师，也问了下以前携程的同事（16年除出了一本《React Native入门到实战》），不过16年初，React Native并没有真正的普及，也还是处于验证阶段，不过到17年初，很多的创业公司为了节约人力成本，都开始有了相关的开发岗位，并且工资也还不错，也就是这个时候，很多同学，特别是想要从事移动开发的前端同学，有些坐不住了。<br><img src="http://img.blog.csdn.net/20171204204013503?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>确实，当我第一次使用React Native开发Android/ios应用的时候，<br>还真是有点小心动，没想到真的可以使用一套代码，解决多平台的需求。</p>
<p>在React Native诞生之前，人们一直在寻找一种可靠的跨平台技术开发方案，这里笔者将这些跨平台技术分为4类（本书的第一节有详细介绍）：</p>
<p>• Web流：也被称为Hybrid技术，它基于Web相关技术来实现界面及功能。<br>• 代码转换流：将某个语言转成Objective-C、Java或C#，然后使用不同平台下的官方<br>工具来开发。<br>• 编译流：将某个语言编译为二进制文件，生成动态库或打包成apk/ipa/xap文件。<br>• 虚拟机流：通过将某个语言的虚拟机移植到不同的平台上来运行。</p>
<h1 id="写作中"><a href="#写作中" class="headerlink" title="写作中"></a>写作中</h1><p>写书确实是一个漫长的过程，不仅漫长，而且枯燥。每天除了上班，就是在写书。第一次写书，好多东西往往是不可预知的，基本上是写到哪，发现有很多延伸的东西，然后又去查资料。</p>
<p>不过，经过一段时间的摸索，我大概确认了此书写作的大体思路，也就有了基本的目录结构，写作速度也逐渐加快。</p>
<p>结合自己的学习经历，再参考了现有书籍的基础之上，本书一共分为11章节，前面讲基础，后面讲项目，做到基础和实战项目相结合，并在适当的地方引入相关的理论，但是并不会深究，本书以入门到实战为主。</p>
<p><img src="http://img.blog.csdn.net/20171204203736315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171204203746999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171204203757243?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>样张可以到如下地址学习：<a href="http://www.epubit.com.cn/file/samplefile/203003060208078052250243067113220145121128058155" target="_blank" rel="external">http://www.epubit.com.cn/file/samplefile/203003060208078052250243067113220145121128058155</a></p>
<p>说说本书为什么叫《React Native移动开发实战》，和之前机械工业的袁林老师的书名字相同，主要是我5月底就已经确认了名字。<br><img src="http://img.blog.csdn.net/20171204204601513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>虽然书名一样，但是内容确大不相同，写作的思路也不一样。</p>
<p>#本书特色<br>本书全面详尽地介绍了 React Native 框架的方方面面，内容涵盖 React Native 基础知识、环境搭建与调试、开发基础、常用组件、常用 API、组件封装、网络与通信、混合开发、热更新与打包部署等章节知识。<br>本书语言简洁，内容丰富，写作思路简单，知识介绍上，逐层深入，并最终通过项目来总结学习成果 。学习时，需要读者具备有一定 Android、iOS 原生开发基础和 CSS 基础。</p>
<ol>
<li>本书各个章节之间逐层深入，如果你有一定的移动开发基础和css基础，可以选择性的阅读，否则，请从第一章开始阅读。</li>
<li>在知识的讲解上，本书尽量使用通俗易懂的讲解方式，不讲过多深入的理论和不常用的知识点，而是将这些深入的知识留给读者之后通过网络学习。</li>
<li>在基础组件和第三方库知识的讲解上，本书罗列了大量的示例，让读者可以轻松的看懂哪些基本的知识    这样就不会没有方向、摸不着头脑, 而是有目的性的去学习。</li>
<li>作为一线的移动开发者，笔者知道怎么学习对于初学者学习来说更好。</li>
</ol>
<p><img src="http://img.blog.csdn.net/20171204205715813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>现在本书只能在异步社区预售，之后会分发到个出版商，本书预售地址：<a href="http://www.epubit.com.cn/book/details/7662#book-resources" target="_blank" rel="external">http://www.epubit.com.cn/book/details/7662#book-resources</a></p>
<h1 id="搞活动，送书了"><a href="#搞活动，送书了" class="headerlink" title="搞活动，送书了"></a>搞活动，送书了</h1><p>为了真正的给广大的读者谋福利，邮电出版社将联合云栖社区和csdn给大家举行送书活动，活动链接之后会发出来（请大家注意）。<br><img src="http://img.blog.csdn.net/20171204210256374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>另外，最近参加云栖的社区评选活动，还请各位帮忙投下票，投票有奖，投票链接：<br><a href="https://yq.aliyun.com/promotion/430?spm=5176.100238.spm-bestcontent.6.TXjRpR&amp;id=people8" target="_blank" rel="external">https://yq.aliyun.com/promotion/430?spm=5176.100238.spm-bestcontent.6.TXjRpR&amp;id=people8</a></p>
<p>重要！重要！重要！，请投17号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对不起，我来晚了&quot;&gt;&lt;a href=&quot;#对不起，我来晚了&quot; class=&quot;headerlink&quot; title=&quot;对不起，我来晚了&quot;&gt;&lt;/a&gt;对不起，我来晚了&lt;/h1&gt;&lt;p&gt;首先要感谢支持和关注我的朋友，感谢人邮的赵老师，还有公司的领导和同事，他们在我写作的过程中给
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiangzhihong.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.xiangzhihong.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 1.2 新特性</title>
    <link href="http://www.xiangzhihong.com/2017/11/23/Kotlin%201.2%20%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://www.xiangzhihong.com/2017/11/23/Kotlin 1.2 新特性/</id>
    <published>2017-11-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:03:45.923Z</updated>
    
    <content type="html"><![CDATA[<p>在Kotlin 1.1中，团队正式发布了JavaScript目标，允许开发者将Kotlin代码编译为JS并在浏览器中运行。在Kotlin 1.2中，团队增加了在JVM和JavaScript之间重用代码的可能性。现在，使用Kotlin编写的代码，可以在所有的应用程序中（包括后端，浏览器前端和Android移动应用程序）中重复使用。</p>
<p><img src="http://img.blog.csdn.net/20171230103641390" alt="这里写图片描述"></p>
<p>想要体验Kotlin1.2新功能的同学，可以下载官方提供的IntelliJ IDEA 2017.3开发工具，或者升级老的IDE，当然也可以通过在线网站来体验。</p>
<h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>跨平台项目是 Kotlin 1.2 中的一个新的实验性功能，它允许开发者从相同的代码库构建应用程序的多个层——后端、前端和Android应用程序，在这个跨平台方案中，主要包含三个模块。</p>
<ul>
<li>通用(common)模块：包含非特定于任何平台的代码，以及不附带依赖于平台的 API 实现的声明。</li>
<li>平台(platform)模块：包含用于特定平台的通用模块中与平台相关声明的实现，以及其他平台相关代码。</li>
<li>常规(regular)模块：针对特定平台，可以是平台模块的某些依赖，也可以是依赖的平台模块。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20171230104621276" alt="这里写图片描述"><br>要从通用模块中调用特定于平台的代码，可以指定所需的声明：所有特定于平台的模块需要提供实际实现声明。而在为特定平台编译多平台项目时，会生成通用及特定平台相关部分的代码。可以通过 expected 以及 actual 声明来表达通用代码对平台特定部分的依赖关系。expected 声明指定了一个 API（类、接口、注释、顶层声明等）。actual 声明或是 API 的平台相关实现，或是在外部库中 API 现有实现的别名引用。下面是官方提供的相关例子：</p>
<p><strong>通用模块</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// expected platform-specific API:</div><div class="line">expect fun hello(world: String): String</div><div class="line"></div><div class="line">fun greet() &#123;</div><div class="line">    // usage of the expected API:</div><div class="line">    val greeting = hello(&quot;multi-platform world&quot;)</div><div class="line">    println(greeting)</div><div class="line">&#125;</div><div class="line"></div><div class="line">expect class URL(spec: String) &#123;</div><div class="line">    open fun getHost(): String</div><div class="line">    open fun getPath(): String</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>JVM 平台代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">actual fun hello(world: String): String =</div><div class="line">    &quot;Hello, $world, on the JVM platform!&quot;</div><div class="line"></div><div class="line">// using existing platform-specific implementation:</div><div class="line">actual typealias URL = java.net.URL</div></pre></td></tr></table></figure>
<p>想要获取更多跨平台相关的信息，可以查看<a href="http://kotlinlang.org/docs/reference/multiplatform.html" target="_blank" rel="external">官方资料</a>介绍。</p>
<p><strong>请注意，目前跨平台项目只是一个实验性功能，这意味着该功能已经可以使用，但可能需要在后续版本中更改设计</strong></p>
<h1 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h1><p>在1.2的开发过程中，团队花了很多精力来优化编译系统，据官方提供的资料显示，与Kotlin 1.1相比，Kotlin带来了大约25％的性能提升，并且看到了可以进一步改进的巨大潜力，这些改进将在1.2.x更新中发布。<br>下图显示了使用Kotlin构建两个大型JetBrains项目的编译时间差异。<br><img src="http://img.blog.csdn.net/20171230105535210" alt="这里写图片描述"></p>
<h1 id="语法与库优化"><a href="#语法与库优化" class="headerlink" title="语法与库优化"></a>语法与库优化</h1><p>除了上面介绍的改动之外，Kotlin还在语法层面进行了部分改进，优化的部分有。</p>
<h2 id="通过注解声明数组变量"><a href="#通过注解声明数组变量" class="headerlink" title="通过注解声明数组变量"></a>通过注解声明数组变量</h2><p>自Kotlin1.2开始，系统允许通过注解声明数组参数，从而取代arrayOf函数的数组声明方式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@CacheConfig(cacheNames = [&quot;books&quot;, &quot;default&quot;])</div><div class="line">public class BookRepositoryImpl &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，新的数组参数声明语法依赖于注解方式。</p>
<h2 id="关键字lateinit"><a href="#关键字lateinit" class="headerlink" title="关键字lateinit"></a>关键字lateinit</h2><p>lateinit 和lazy一样，是 Kotlin中的两种不同的延迟初始化技术。在Kotlin1.2版本中，使用lateinit修饰符能够用于全局变量和局部变量了，也就是说，二者都允许延迟初始化。例如，当lambda表达式在构造一个对象时，允许将延迟初始化属性作为构造参数传过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Node&lt;T&gt;(val value: T, val next: () -&gt; Node&lt;T&gt;)</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    // A cycle of three nodes:</div><div class="line">    lateinit var third: Node&lt;Int&gt;</div><div class="line"></div><div class="line">    val second = Node(2, next = &#123; third &#125;)</div><div class="line">    val first = Node(1, next = &#123; second &#125;)</div><div class="line"></div><div class="line">    third = Node(3, next = &#123; first &#125;)</div><div class="line"></div><div class="line">    </div><div class="line">    val nodes = generateSequence(first) &#123; it.next() &#125;</div><div class="line">    println(&quot;Values in the cycle: $&#123;nodes.take(7).joinToString &#123; it.value.toString() &#125;&#125;, ...&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Values in the cycle: 1, 2, 3, 1, 2, 3, 1, ...</div></pre></td></tr></table></figure>
<h2 id="延迟初始化属性检测"><a href="#延迟初始化属性检测" class="headerlink" title="延迟初始化属性检测"></a>延迟初始化属性检测</h2><p>通过访问属性的isInitialized字段，现在开发者可以检查一个延迟初始化属性是否已经初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">    lateinit var lateinitVar: String</div><div class="line">    </div><div class="line">    fun initializationLogic() &#123;</div><div class="line">        println(&quot;isInitialized before assignment: &quot; + this::lateinitVar.isInitialized)</div><div class="line">        lateinitVar = &quot;value&quot;</div><div class="line">        println(&quot;isInitialized after assignment: &quot; + this::lateinitVar.isInitialized)    </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">	Foo().initializationLogic()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">isInitialized before assignment: false</div><div class="line">isInitialized after assignment: true</div></pre></td></tr></table></figure>
<h2 id="内联函数默认参数"><a href="#内联函数默认参数" class="headerlink" title="内联函数默认参数"></a>内联函数默认参数</h2><p>自1.2版本开始，Kotlin允许允许给内联函数的函数参数填写默认参数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;E&gt; Iterable&lt;E&gt;.strings(transform: (E) -&gt; String = &#123; it.toString() &#125;) = </div><div class="line">map &#123; transform(it) &#125;</div><div class="line"></div><div class="line">val defaultStrings = listOf(1, 2, 3).strings()</div><div class="line">val customStrings = listOf(1, 2, 3).strings &#123; &quot;($it)&quot; &#125; </div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    println(&quot;defaultStrings = $defaultStrings&quot;)</div><div class="line">    println(&quot;customStrings = $customStrings&quot;)</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaultStrings = [1, 2, 3]</div><div class="line">customStrings = [(1), (2), (3)]</div></pre></td></tr></table></figure>
<h2 id="变量类型推断"><a href="#变量类型推断" class="headerlink" title="变量类型推断"></a>变量类型推断</h2><p>大家都知道，Kotlin的类型推断系统是非常强大的，现在Kotlin编译器也支持通过强制转换的信息，来推断出变量类型了。比如说，如果你在调用一个返回“T”的泛型方法时，并将它的返回值“T”转换为特定类型如“Foo”，编译器就会推断出这个方法调用中的“T”其实是“Foo”类型。</p>
<p>这个对安卓开发者而言尤其重要，因为自从API26（Android7.0）开始，findViewById变成了泛型方法，然后编译器也会正确分析该方法的调用返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val button = findViewById(R.id.button) as Button</div></pre></td></tr></table></figure></p>
<h2 id="智能转换"><a href="#智能转换" class="headerlink" title="智能转换"></a>智能转换</h2><p>当一个变量为某个安全表达式（如校验非空）所赋值时，智能转换也同样运用于这个安全调用的接收者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fun countFirst(s: Any): Int &#123;</div><div class="line">    val firstChar = (s as? CharSequence)?.firstOrNull()</div><div class="line">    if (firstChar != null)</div><div class="line">    return s.count &#123; it == firstChar &#125; // 输入参数s被智能转换为CharSequence类型</div><div class="line"></div><div class="line">    val firstItem = (s as? Iterable&lt;*&gt;)?.firstOrNull()</div><div class="line">    if (firstItem != null)</div><div class="line">    return s.count &#123; it == firstItem &#125; // 输入参数s被智能转换为Iterable&lt;*&gt;类型  </div><div class="line"></div><div class="line">    </div><div class="line">    return -1</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val string = &quot;abacaba&quot;</div><div class="line">    val countInString = countFirst(string)</div><div class="line">    println(&quot;called on \&quot;$string\&quot;: $countInString&quot;)</div><div class="line">    </div><div class="line">    val list = listOf(1, 2, 3, 1, 2)</div><div class="line">    val countInList = countFirst(list)</div><div class="line">    println(&quot;called on $list: $countInList&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">called on &quot;abacaba&quot;: 4</div><div class="line">called on [1, 2, 3, 1, 2]: 2</div></pre></td></tr></table></figure>
<p>另外，Lamba表达式同样支持对局部变量进行智能转换，前提是该局部变量只在Lamba表达式之前修改过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val flag = args.size == 0</div><div class="line">    </div><div class="line">    var x: String? = null</div><div class="line">    if (flag) x = &quot;Yahoo!&quot;</div><div class="line"></div><div class="line">    run &#123;</div><div class="line">        if (x != null) &#123;</div><div class="line">            println(x.length) // x is smart cast to String</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br>6</p>
<h2 id="foo的简写"><a href="#foo的简写" class="headerlink" title="foo的简写"></a>foo的简写</h2><p>为了简化调用成员的引用，现在可以不用this关键字，::foo而不用明确的接收者this::foo。这也使得可调用的引用在你引用外部接收者的成员的lambda中更方便。</p>
<h1 id="弃用"><a href="#弃用" class="headerlink" title="弃用"></a>弃用</h1><p>Kotlin1.2版本也弃用了很多不合理的东西。</p>
<h2 id="弃用：枚举条目中的嵌套类型"><a href="#弃用：枚举条目中的嵌套类型" class="headerlink" title="弃用：枚举条目中的嵌套类型"></a>弃用：枚举条目中的嵌套类型</h2><p>在枚举条目中，inner class由于初始化逻辑中的问题，定义一个非嵌套的类型已经被弃用了。这会在Kotlin 1.2中引起警告，并将在Kotlin 1.3中出错。</p>
<h2 id="弃用：vararg单个命名参数"><a href="#弃用：vararg单个命名参数" class="headerlink" title="弃用：vararg单个命名参数"></a>弃用：vararg单个命名参数</h2><p>为了与注释中的数组文字保持一致，在命名形式（foo(items = i)）中传递可变参数的单个项目已被弃用。请使用具有相应数组工厂功能的扩展运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(items = *intArrayOf(1))</div></pre></td></tr></table></figure>
<p>在这种情况下，有一种优化可以消除冗余阵列的创建，从而防止性能下降。单参数形式在Kotlin 1.2中产生警告，并将被放在Kotlin 1.3中。</p>
<h2 id="弃用：扩展Throwable的泛型内部类"><a href="#弃用：扩展Throwable的泛型内部类" class="headerlink" title="弃用：扩展Throwable的泛型内部类"></a>弃用：扩展Throwable的泛型内部类</h2><p>继承的泛型类型的内部类Throwable可能会违反类型安全性，因此已被弃用，Kotlin 1.2中有警告，Kotlin 1.3中有错误。</p>
<h2 id="弃用：只读属性的后台字段"><a href="#弃用：只读属性的后台字段" class="headerlink" title="弃用：只读属性的后台字段"></a>弃用：只读属性的后台字段</h2><p>field = …已经废弃了在自定义获取器中分配只读属性的后台字段，Kotlin 1.2中有警告，Kotlin 1.3中有错误。</p>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Kotlin标准库与拆分包"><a href="#Kotlin标准库与拆分包" class="headerlink" title="Kotlin标准库与拆分包"></a>Kotlin标准库与拆分包</h2><p>Kotlin标准库现在完全兼容Java 9模块系统，该系统禁止拆分包（多个jar文件在同一个包中声明类）。为了支持这一点，新的文物kotlin-stdlib-jdk7 和kotlin-stdlib-jdk8介绍，取代旧的kotlin-stdlib-jre7和kotlin-stdlib-jre8。</p>
<p>为确保与新模块系统的兼容性，Kotlin做出的另一个更改是将kotlin.reflect从kotlin-reflect库中移除。如果您正在使用它们，则需要切换到使用kotlin.reflect.full软件包中的声明，这是自Kotlin 1.1以来支持的声明。</p>
<h2 id="窗口，分块，zipWithNext"><a href="#窗口，分块，zipWithNext" class="headerlink" title="窗口，分块，zipWithNext"></a>窗口，分块，zipWithNext</h2><p>为新的扩展Iterable<t>，Sequence<t>以及CharSequence覆盖这些用例如缓冲或批处理（chunked），滑动窗口和计算滑动平均（windowed），和随后的项目的处理对（zipWithNext）。</t></t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = (1..9).map &#123; it * it &#125;</div><div class="line"></div><div class="line">    val chunkedIntoLists = items.chunked(4)</div><div class="line">    val points3d = items.chunked(3) &#123; (x, y, z) -&gt; Triple(x, y, z) &#125;</div><div class="line">    val windowed = items.windowed(4)</div><div class="line">    val slidingAverage = items.windowed(4) &#123; it.average() &#125;</div><div class="line">    val pairwiseDifferences = items.zipWithNext &#123; a, b -&gt; b - a &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    println(&quot;items: $items\n&quot;)</div><div class="line">    </div><div class="line">    println(&quot;chunked into lists: $chunkedIntoLists&quot;)</div><div class="line">    println(&quot;3D points: $points3d&quot;)</div><div class="line">    println(&quot;windowed by 4: $windowed&quot;)</div><div class="line">    println(&quot;sliding average by 4: $slidingAverage&quot;)</div><div class="line">    println(&quot;pairwise differences: $pairwiseDifferences&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="fill-replaceAll-shuffle-shuffled"><a href="#fill-replaceAll-shuffle-shuffled" class="headerlink" title="fill, replaceAll, shuffle/shuffled"></a>fill, replaceAll, shuffle/shuffled</h2><p>为了操纵列表，Kotlin加入了一组扩展函数：fill，replaceAll和shuffle对MutableList，shuffled用于只读List。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val items = (1..5).toMutableList()</div><div class="line"></div><div class="line">    items.shuffle()</div><div class="line">    println(&quot;Shuffled items: $items&quot;)</div><div class="line"></div><div class="line">    items.replaceAll &#123; it * 2 &#125;</div><div class="line">    println(&quot;Items doubled: $items&quot;)</div><div class="line"></div><div class="line">    items.fill(5)</div><div class="line">    println(&quot;Items filled with 5: $items&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br>Shuffled items: [5, 3, 1, 2, 4]<br>Items doubled: [10, 6, 2, 4, 8]<br>Items filled with 5: [5, 5, 5, 5, 5]</p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>为了满足一些特殊的需求，Kotlin 1.2添加了一些常见的数学运算API。</p>
<ul>
<li>常量：PI和E;</li>
<li>三角函数：cos，sin，tan和它们的反：acos，asin，atan，atan2，</li>
<li>双曲：cosh，sinh，tanh和它们的反：acosh，asinh，atanh</li>
<li>求幂：pow（扩展函数），sqrt，，hypot ;expexpm1</li>
<li>对数：log，log2，log10，ln，ln1p，</li>
<li>四舍五入： ceil，floor，truncate，round（半连）的功能;<br>roundToInt，roundToLong（半整数）扩展函数;</li>
<li>符号和绝对值： abs和sign功能; absoluteValue和sign扩展属性; withSign 扩展功能;max和min两个价值观;</li>
<li>二进制表示： ulp 扩展属性; nextUp，nextDown，nextTowards扩展函数;toBits，toRawBits，Double.fromBits（这些是在kotlin包）。</li>
</ul>
<h2 id="正则表达式可序列化"><a href="#正则表达式可序列化" class="headerlink" title="正则表达式可序列化"></a>正则表达式可序列化</h2><p>现在，Kotlin可以使用Serializable来序列化正则表达式的层次结构。</p>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="构造函数调用规范化"><a href="#构造函数调用规范化" class="headerlink" title="构造函数调用规范化"></a>构造函数调用规范化</h2><p>自1.0版以来，Kotlin支持复杂控制流的表达式，例如try-catch表达式和内联函数调用。但是，如果构造函数调用的参数中存在这样的表达式时，一些字节码处理工具不能很好地处理这些代码。为了缓解这种字节码处理工具的用户的这个问题，我们添加了一个命令行选项（-Xnormalize-constructor-calls=MODE），它告诉编译器为这样的结构生成更多的类Java字节码。</p>
<p>其中，这里的MODE有以下情况：</p>
<ul>
<li>disable （默认） - 以和Kotlin 1.0和1.1相同的方式生成字节码;</li>
<li>enable - 为构造函数调用生成类似Java的字节码。这可以改变类加载和初始化的顺序;</li>
<li>preserve-class-initialization -为构造函数调用生成类似Java的字节码，确保保持类的初始化顺序。这可能会影响应用程序的整体性能;只有在多个类之间共享一些复杂的状态并在类初始化时更新时才使用它。</li>
</ul>
<h2 id="Java默认方法调用"><a href="#Java默认方法调用" class="headerlink" title="Java默认方法调用"></a>Java默认方法调用</h2><p>在Kotlin 1.2之前，接口成员在针对JVM 1.6的情况下重写Java默认方法会在超级调用上产生一个警告：Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with ‘-jvm-target 1.8’。在Kotlin 1.2中，会出现一个错误，因此需要使用JVM target 1.8来编译这些代码。</p>
<h2 id="x-equals（null）"><a href="#x-equals（null）" class="headerlink" title="x.equals（null）"></a>x.equals（null）</h2><p>调用x.equals(null)上被映射到Java原始（平台类型Int!，Boolean!，Short！， ，Long!，Float!，Double!）Char!返回不正确true时x为空。从Kotlin 1.2开始，调用x.equals(…)一个平台类型的null值会抛出一个NPE （但是x == …不会）。</p>
<p>要返回到1.2之前的行为，请将该标志传递-Xno-exception-on-explicit-equals-for-boxed-null给编译器。</p>
<h2 id="内联扩展空修复"><a href="#内联扩展空修复" class="headerlink" title="内联扩展空修复"></a>内联扩展空修复</h2><p>在以前的版本中，在平台类型的空值上调用的内联扩展函数没有检查接收器是否为null，并因此允许null转义到其他代码中。Kotlin 1.2中强制执行此检查，如果接收方为空，则抛出异常。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="TypedArrays支持"><a href="#TypedArrays支持" class="headerlink" title="TypedArrays支持"></a>TypedArrays支持</h2><p>JS类型的数组支持将Kotlin原始数组（例如IntArray，DoubleArray）转换为JavaScript类型的数组，这以前是可选入功能，默认情况下已启用。</p>
<p>除此之外，Kotlin的编译器现在提供一个将所有警告视为错误的选项。使用-Werror命令行，或者修改如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compileKotlin &#123;</div><div class="line">    kotlinOptions.allWarningsAsErrors = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想要了解更多的官方知识介绍，请查看：<a href="http://kotlinlang.org/docs/reference/whatsnew12.html" target="_blank" rel="external">Kotlin 1.2带来了什么新特性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Kotlin 1.1中，团队正式发布了JavaScript目标，允许开发者将Kotlin代码编译为JS并在浏览器中运行。在Kotlin 1.2中，团队增加了在JVM和JavaScript之间重用代码的可能性。现在，使用Kotlin编写的代码，可以在所有的应用程序中（包括后
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>移动PWA初探</title>
    <link href="http://www.xiangzhihong.com/2017/11/23/%E7%A7%BB%E5%8A%A8PWA%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.xiangzhihong.com/2017/11/23/移动PWA初探/</id>
    <published>2017-11-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:14:11.871Z</updated>
    
    <content type="html"><![CDATA[<p>在去年上海举办的2017谷歌开发者大会上，PWA作为会议的一个重要内容被推介，笔者作为参会嘉宾看了PWA的内容后，觉得这种技术会是未来移动发展的一个趋势。Google开发技术推广工程师Michael Yeung介绍称，新浪微博正在打造一款全新体验的Web Mobile PWA应用，读者可以通过微博提供的PWA版访问网址：<a href="m.weibo.cn/beta">m.weibo.cn/beta</a>。<br><img src="http://img.blog.csdn.net/20180126140527984" alt="这里写图片描述"></p>
<p>在当前的移动跨平台开发方案中，主要的技术有PWA和Weex、RN（这个笔者在16年专门进行了研究，并出版了相关的书籍）。不过纵观这些移动技术可以发现，PWA是优化web app，RN是用web调用native思路，weex还是使用web栈调用native的思路。</p>
<p>在移动碎片化严重的当前，如何制定一个统一的标准，才是为了移动技术发展的方向，也就是说：“Web不会趋向于Native，而是Native趋向于Web。”。</p>
<h1 id="PWA简介"><a href="#PWA简介" class="headerlink" title="PWA简介"></a>PWA简介</h1><p>PWA全称Progressive Web Apps（渐进式网络应用），该项目由谷歌在2015年主导推出，主要的特性是让Web App的体验能更接近原生应用，显著提高应用加载速度，甚至可以在离线状态下运行，多种手机/PC浏览器已支持加载PWA网页。<br><img src="http://img.blog.csdn.net/20180126141045046" alt="这里写图片描述"><br>所谓的P（Progressive）这里有两层含义，一方面是渐进增强，让WEB APP的体验和功能能够用渐进增强的方式来更接近原生APP的体验及功能；另一方面是指下一代WEB技术，PWA并不是描述一个技术，而是一些技术的合集。PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>
<p>PWA 的主要特点包括下面三点：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>
</ul>
<p>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。</p>
<h2 id="PWA特性"><a href="#PWA特性" class="headerlink" title="PWA特性"></a>PWA特性</h2><p>下面就从安全、性能和体验三个方面来介绍PWA所具有的特性。</p>
<h3 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h3><p>当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。</p>
<p>Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。</p>
<p>更详细的内容可以访问：<a href="https://developers.google.cn/web/fundamentals/primers/service-workers/" target="_blank" rel="external"> Service Worker</a></p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>如果站点加载时间超过 3s，53% 的用户会放弃等待。页面展现之后，用户期望有平滑的体验，过渡动画和快速响应。</p>
<p>为了保证首屏的加载，我们需要从设计上考虑，在内容请求完成之前，可以优先保证 App Shell 的渲染，做到和 Native App 一样的体验，App Shell 是 PWA 界面展现所需的最小资源。</p>
<p>更多的资料可以参考：<a href="https://developers.google.cn/web/fundamentals/architecture/app-shell" target="_blank" rel="external"> App Shell 设计规范</a></p>
<h3 id="粘性"><a href="#粘性" class="headerlink" title="粘性"></a>粘性</h3><p>PWA具有的粘性表现在如下几个方面：</p>
<ul>
<li>PWA 是可以安装的，用户点击安装到桌面后，会在桌面创建一个 PWA 应用，并且不需要从应用商店下载；</li>
<li>PWA 可以借助 Web App Manifest 提供给用户和 Native App 一样的沉浸式体验；</li>
<li>PWA 可以通过给用户发送离线通知，让用户回流。</li>
</ul>
<p>同时，Web App Manifest 允许开发者控制 PWA 添加到桌面，允许定制桌面图标、URL等等。</p>
<p>关于Web App Manifest更多的内容可以参考：<a href="https://developers.google.cn/web/fundamentals/web-app-manifest/?hl=zh-cn" target="_blank" rel="external">Web App Manifest</a>和<a href="https://developers.google.cn/web/fundamentals/push-notifications/?hl=zh-cn" target="_blank" rel="external">Push Notification</a>。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除此之外，讲到 PWA 兼具 Web App 和 Native App 的特征的，Web App 无版本问题、可索引也是很重要的特性。</p>
<p>总结一下，PWA 具有下面一些特性：</p>
<ul>
<li><strong>渐进式</strong> - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的。</li>
<li><strong>连接无关性</strong> - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问。</li>
<li><strong>类似应用</strong> - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App的体验。</li>
<li><strong>持续更新</strong> - 始终是最新的，无版本和更新问题。</li>
<li><strong>安全</strong> - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改。</li>
<li><strong>可索引</strong> - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』。</li>
<li><strong>粘性</strong> - 通过推送离线通知等，可以让用户回流。</li>
<li><strong>可安装</strong> - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦。</li>
<li><strong>可链接</strong> - 通过链接即可分享内容，无需下载安装。</li>
</ul>
<p>PWA 是对站点体验的一个飞跃式的提升，可以在移动设备上的 Chrome(version &gt; 52) 访问 <a href="https://weatherpwa.baidu.com/" target="_blank" rel="external">天气PWA</a> 体验一下。</p>
<h1 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h1><p>所谓渐进式，就是逐步的改善，不是一蹴而就的，采取这种方案，主要有两点原因：</p>
<ul>
<li>降低站点改造的代价，逐步支持各项新技术，不要一蹴而就；</li>
<li>新技术标准的支持度还不完全，新技术的标准还未完全确定。</li>
</ul>
<p>所以，从改造的成本考虑，我们也建议采取渐进式的方式，可以考虑按照下面的步骤来改造：</p>
<ul>
<li>第一步，应该是安全，将全站 HTTPS 化，因为这是 PWA 的基础，没有 HTTPS，就没有 Service Worker</li>
<li>第二步，应该是 Service Worker 来提升基础性能，离线提供静态文件，把用户首屏体验提升上来</li>
<li>第三步，App Manifest，这一步可以和第二步同时进行 后续，再考虑其他的特性，离线消息推送等</li>
</ul>
<p>同时，PWA作为最新的不太成熟的技术，当前浏览器还没有达到完全支持的程度，W3C 关于这些技术的标准也还在处于草稿状态，没有定稿。根据知名统计网站<a href="https://caniuse.com/" target="_blank" rel="external">Can I use </a>的统计，对PWA相关技术的支持程度如下：</p>
<ul>
<li>App Manifest 的支持度达到 57.43%；</li>
<li>Service Worker 的支持度达到 72.82%；</li>
<li>Notifications API 的支持度达到 43.3%；</li>
<li>Push API 的支持度达到 72.39%；</li>
<li>Background Sync 暂未统计到，Chrome 49 以上均支持。</li>
</ul>
<p>比较遗憾的是上面提到的所有技术，目前只有 Android 的部分浏览器支持，iOS 的Safari暂不支持，不过，Safari 浏览器已经在考虑了。</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p>W3C 组织早在 2014 年 5 月就提出过 Service Worker 这样的一个 HTML5 API ，主要用来做持久的离线缓存。对于API相关的内容，这里仔细整理了一下：<br>浏览器中的 javaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，我们逐渐在 js 中加了很多耗资源、耗时间的复杂运算过程，这些过程导致的性能问题在 WebApp 的复杂化过程中更加凸显出来。</p>
<p>W3C 组织早早的洞察到了这些问题可能会造成的影响，这个时候有个叫 Web Worker 的 API 被造出来了，这个 API 的唯一目的就是解放主线程，Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干，完成后通过 postMessage 方法告诉主线程，而主线程通过 onMessage 方法得到 Web Worker 的结果反馈。</p>
<p>一切问题好像是解决了，但 Web Worker 是临时的，我们能不能有一个东东是一直持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求推出了最初版本的 Service Worker ，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力。当然在 Service Worker 之前也有在 HTML5 上做离线缓存的 API 叫 AppCache, 但是 AppCache 存在很多 不能忍受的<a href="https://alistapart.com/article/application-cache-is-a-douchebag" target="_blank" rel="external">缺点</a>。</p>
<p>W3C 决定 AppCache 仍然保留在 HTML 5.0 Recommendation 中，在 HTML 后续版本中移除。</p>
<ul>
<li>Issue: <a href="https://github.com/w3c/html/issues/40" target="_blank" rel="external">https://github.com/w3c/html/issues/40</a></li>
<li>Mailing list:<br><a href="https://lists.w3.org/Archives/Public/public-html/2016May/0005.html" target="_blank" rel="external">https://lists.w3.org/Archives/Public/public-html/2016May/0005.html</a></li>
</ul>
<p>WHATWG HTML5 作为 Live Standard，也将 AppCache 标注为 Discouraged 并引导至 Service Worker。Ok ，那么 Service Worker 到底用来干啥的呢？</p>
<p>Service Worker 有以下功能和特性：</p>
<ul>
<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>
<li>一旦被 install，就永远存在，除非被 uninstall。</li>
<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）。</li>
<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）。</li>
<li>离线内容开发者可控。</li>
<li>能向客户端推送消息。</li>
<li>不能直接操作 DOM。</li>
<li>出于安全的考虑，必须在 HTTPS 环境下才能工作。</li>
<li>异步实现，内部大都是通过 Promise 实现。</li>
</ul>
<p>所以我们基本上知道了 Service Worker 的伟大使命，就是让缓存做到优雅和极致，让 Web App 相对于 Native App 的缺点更加弱化，也为开发者提供了对性能和体验的无限遐想。</p>
<h2 id="浏览器Service-Worker支持情况"><a href="#浏览器Service-Worker支持情况" class="headerlink" title="浏览器Service Worker支持情况"></a>浏览器Service Worker支持情况</h2><p>根据<a href="https://caniuse.com/#search=service%20worker" target="_blank" rel="external">Can I use </a>发现，目前市场上对Service Worker的支持情况如下：<br><img src="http://img.blog.csdn.net/20180126150401834" alt="这里写图片描述"><br>从这张图可以发现，Chrome 作为开路先锋早早的在 V40 版本就支持了，还提供了完善的 debug 方案（ Service Worker debug ）；Firefox，Opera 不甘示弱在后续版本也进行了支持；安卓手机 4.x 以上版本新系统形势一片大好（具体各手机的实现还得进一步探测）；安卓 Chrome 同样给力；但是目前IE和Safair是不支持的，不过已经被列入未来的支持计划中。</p>
<h2 id="Service-Worker使用"><a href="#Service-Worker使用" class="headerlink" title="Service Worker使用"></a>Service Worker使用</h2><p>Service Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。</p>
<ul>
<li>由于 Service Worker 要求 HTTPS 的环境，我们通常可以借助于 <a href="https://pages.github.com/" target="_blank" rel="external">github<br>page</a> 进行学习调试。当然一般浏览器允许调试 Service Worker<br>的时候 host 为 localhost 或者 127.0.0.1 也是 ok 的。</li>
<li>Service Worker 的缓存机制是依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="external">Cache API</a> 实现的。</li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="external">HTML5 fetch API</a>。</li>
<li>依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/javaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a> 实现。</li>
</ul>
<h3 id="Service-Worker注册"><a href="#Service-Worker注册" class="headerlink" title="Service Worker注册"></a>Service Worker注册</h3><p>要安装 Service Worker， 我们需要通过在 js 主线程（常规的页面里的 js ）注册 Service Worker 来启动安装，这个过程将会通知浏览器我们的 Service Worker 线程的 javaScript 文件在什么地方呆着。先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</div><div class="line">    window.addEventListener(&apos;load&apos;, function () &#123;</div><div class="line">        navigator.serviceWorker.register(&apos;/sw.js&apos;, &#123;scope: &apos;/&apos;&#125;)</div><div class="line">            .then(function (registration) &#123;</div><div class="line"></div><div class="line">                // 注册成功</div><div class="line">                console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</div><div class="line">            &#125;)</div><div class="line">            .catch(function (err) &#123;</div><div class="line"></div><div class="line">                // 注册失败:(</div><div class="line">                console.log(&apos;ServiceWorker registration failed: &apos;, err);</div><div class="line">            &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码首先判断 Service Worker API 的可用情况，支持的话咱们才继续谈实现。如果支持的话，在页面 onload 的时候注册位于 /sw.js 的 Service Worker。每次页面加载成功后，就会调用 register() 方法，浏览器将会判断 Service Worker 线程是否已注册并做出相应的处理。register 方法的 scope 参数是可选的，用于指定你想让 Service Worker 控制的内容的子目录。本 demo 中服务工作线程文件位于根网域， 这意味着服务工作线程的作用域将是整个来源。</p>
<p><strong>说明</strong>： Service Worker 线程将接收 scope 指定网域目录上所有事项的 fetch 事件，如果我们的 Service Worker 的 javaScript 文件在 /a/b/sw.js， 不传 scope 值的情况下, scope 的值就是 /a/b。<br>scope 的值的意义在于，如果 scope 的值为 /a/b， 那么 Service Worker 线程只能捕获到 path 为 /a/b 开头的( /a/b/page1, /a/b/page2，…)页面的 fetch 事件。通过 scope 的意义我们也能看出 Service Worker 不是服务单个页面的，所以在 Service Worker 的 js 逻辑中全局变量需要慎用。</p>
<p>then() 函数链式调用我们的 promise，当 promise resolve 的时候，里面的代码就会执行。代码执行完成之后，我们这就注册了一个 Service Worker，它工作在 worker context，所以没有访问 DOM 的权限。在正常的页面之外运行 Service Worker 的代码来控制它们的加载。</p>
<p>为了验证Service Worker 到底有没有注册成功，可以在 PC 上打开chrome 浏览器，并输入：chrome://inspect/#service-workers。<br><img src="http://img.blog.csdn.net/20180126151838107" alt="这里写图片描述"><br>我们还可以通过 chrome://serviceworker-internals 来查看服务工作线程详情。 如果只是想了解服务工作线程的生命周期，这仍很有用，但是日后其很有可能被 chrome://inspect/#service-workers 完全取代。</p>
<p>当然，它还可用于测试隐身窗口中的 Service Worker 线程，您可以关闭 Service Worker 线程并重新打开，因为之前的 Service Worker 线程不会影响新窗口。从隐身窗口创建的任何注册和缓存在该窗口关闭后均将被清除。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在你的 Service Worker 注册成功之后呢，我们的浏览器中已经有了一个属于你自己 web App 的 worker context 啦， 在此时，浏览器就会马不停蹄的尝试为你的站点里面的页面安装并激活它，并且在这里可以把静态资源的缓存给办了。</p>
<p>install 事件我们会绑定在 Service Worker 文件中，在 Service Worker 安装成功后，install 事件被触发。</p>
<p>install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 新的标志性的存储 cache API — 一个 Service Worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>
<p>localStorage 的用法和 Service Worker cache 的用法很相似，但是由于 localStorage 是同步的用法，所以不允许在 Service Worker 中使用。 IndexedDB 也可以在 Service Worker 内做数据存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">this.addEventListener(&apos;install&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(</div><div class="line">        caches.open(&apos;my-test-cache-v1&apos;).then(function (cache) &#123;</div><div class="line">            return cache.addAll([</div><div class="line">                &apos;/&apos;,</div><div class="line">                &apos;/index.html&apos;,</div><div class="line">                &apos;/main.css&apos;,</div><div class="line">                &apos;/main.js&apos;,</div><div class="line">                &apos;/image.jpg&apos;</div><div class="line">            ]);</div><div class="line">        &#125;)</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自动更新页面"><a href="#自动更新页面" class="headerlink" title="自动更新页面"></a>自动更新页面</h3><p>如果希望在有了新版本时，所有的页面都得到及时自动更新怎么办呢？可以在 install 事件中执行 self.skipWaiting() 方法跳过 waiting 状态，然后会直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 self.clients.claim() 方法，更新所有客户端上的 Service Worker。例如下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 安装阶段跳过等待，直接进入 active</div><div class="line">self.addEventListener(&apos;install&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(self.skipWaiting());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">self.addEventListener(&apos;activate&apos;, function (event) &#123;</div><div class="line">    event.waitUntil(</div><div class="line">        Promise.all([</div><div class="line"></div><div class="line">            // 更新客户端</div><div class="line">            self.clients.claim(),</div><div class="line"></div><div class="line">            // 清理旧版本</div><div class="line">            caches.keys().then(function (cacheList) &#123;</div><div class="line">                return Promise.all(</div><div class="line">                    cacheList.map(function (cacheName) &#123;</div><div class="line">                        if (cacheName !== &apos;my-test-cache-v1&apos;) &#123;</div><div class="line">                            return caches.delete(cacheName);</div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                );</div><div class="line">            &#125;)</div><div class="line">        ])</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另外要注意一点，/sw.js 文件可能会因为浏览器缓存问题，当文件有了变化时，浏览器里还是旧的文件。这会导致更新得不到响应。如遇到该问题，可尝试这么做：在 Web Server 上添加对该文件的过滤规则，不缓存或设置较短的有效期。</p>
<h3 id="手动更新-Service-Worker"><a href="#手动更新-Service-Worker" class="headerlink" title="手动更新 Service Worker"></a>手动更新 Service Worker</h3><p>其实在页面中，也可以手动借助 Registration.update() 更新。例如，下面的示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var version = &apos;1.0.1&apos;;</div><div class="line"></div><div class="line">navigator.serviceWorker.register(&apos;/sw.js&apos;).then(function (reg) &#123;</div><div class="line">    if (localStorage.getItem(&apos;sw_version&apos;) !== version) &#123;</div><div class="line">        reg.update().then(function () &#123;</div><div class="line">            localStorage.setItem(&apos;sw_version&apos;, version)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同时，<a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/service-worker-debug" target="_blank" rel="external">Service Worker debug</a> 技巧 中也会提到, Service Worker 被载入后立即激活可以保证每次 /sw.js 为最新的。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(&apos;install&apos;, function () &#123;</div><div class="line">    self.skipWaiting();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Service-Worker-生命周期"><a href="#Service-Worker-生命周期" class="headerlink" title="Service Worker 生命周期"></a>Service Worker 生命周期</h2><p>Service Worker 的使用过程很简单，所处理的事情也相对单一，我们基本上需要做的就是利用这个 API 做好站点的缓存策略。在页面脚本中注册 Service Worker 文件所在的 URL。Worker 就可以开始激活了，激活后的 Service Worker 可以监听当前域下的功能性事件，比如资源请求（fetch）、推送通知（push）、后台同步（sync）。在这一系列的流程中，从 Service Worker 的注册到消失，经历了生命周期中不同的状态。</p>
<h3 id="Service-Worker-工作流程"><a href="#Service-Worker-工作流程" class="headerlink" title="Service Worker 工作流程"></a>Service Worker 工作流程</h3><p>Service Worker 基本就是以下几个步骤：</p>
<ol>
<li>首先，我们需要在页面的JavaScript 主线程中使用 serviceWorkerContainer.register() 来注册Service Worker ，在注册的过程中，浏览器会在后台启动尝试 Service Worker 的安装步骤。</li>
<li>如果注册成功，Service Worker 在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊的 worker context，与主脚本的运行线程相独立，同时也没有访问 DOM 的能力。</li>
<li>后台开始安装步骤， 通常在安装的过程中需要缓存一些静态资源。如果所有的资源成功缓存则安装成功，如果有任何静态资源缓存失败则安装失败，在这里失败的不要紧，会自动继续安装直到安装成功，如果安装不成功无法进行下一步 激活 Service Worker操作。</li>
<li>开始激活 Service Worker，必须要在 Service Worker 安装成功之后，才能开始激活步骤，当 Service Worker 安装完成后，会接收到一个激活事件（activate event）。激活事件的处理函数中，主要操作是清理旧版本的 Service Worker 脚本中使用资源。</li>
<li>激活成功后 Service Worker 可以控制页面了，但是只针对在成功注册了 Service Worker 后打开的页面。也就是说，页面打开时有没有 Service Worker，决定了接下来页面的生命周期内受不受 Service Worker 控制。所以，只有当页面刷新后，之前不受 Service Worker 控制的页面才有可能被控制起来。</li>
</ol>
<h3 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h3><p>下面是MDN 给出了详细的 Service Worker 生命周期图：<br><img src="http://img.blog.csdn.net/20180126162232416" alt="这里写图片描述"></p>
<p>由上图可知，Service Worker的生命周期主要分为以下几个阶段：安装中, 安装后, 激活中, 激活后, 废弃。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。<br>install 事件回调中有两个方法：</p>
<ul>
<li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li>self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li>
</ul>
<h4 id="安装后-installed"><a href="#安装后-installed" class="headerlink" title="安装后( installed )"></a>安装后( installed )</h4><p>Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。</p>
<h4 id="激活-activating"><a href="#激活-activating" class="headerlink" title="激活( activating )"></a>激活( activating )</h4><p>在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。</p>
<p>激活的状态回调中有两个方法：</p>
<ul>
<li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li>
<li>self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。</li>
</ul>
<h4 id="激活后-activated"><a href="#激活后-activated" class="headerlink" title="激活后( activated )"></a>激活后( activated )</h4><p>在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。</p>
<h4 id="废弃状态-redundant"><a href="#废弃状态-redundant" class="headerlink" title="废弃状态 ( redundant )"></a>废弃状态 ( redundant )</h4><p>这个状态表示一个 Service Worker 的生命周期结束。废弃状态可能有以下几种：</p>
<ul>
<li>安装 (install) 失败；</li>
<li>激活 (activating) 失败；</li>
<li>新版本的 Service Worker 替换了它并成为激活状态。</li>
</ul>
<h3 id="Service-Worker支持的事件"><a href="#Service-Worker支持的事件" class="headerlink" title="Service Worker支持的事件"></a>Service Worker支持的事件</h3><p>同时，MDN 也列出了 Service Worker 所有支持的事件，如下图所示：<br><img src="http://img.blog.csdn.net/20180126163252777" alt="这里写图片描述"></p>
<ul>
<li><strong>install</strong>：Service Worker 安装成功后被触发的事件，在事件处理函数中可以添加需要缓存的文件。</li>
<li><strong>activate</strong>：当 Service Worker 安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对旧版本的更新、对无用缓存的清理等。</li>
<li><strong>message</strong>：Service Worker 运行于独立 context 中，无法直接访问当前页面主线程的 DOM 等信息，但是通过 postMessage API，可以实现他们之间的消息传递，这样主线程就可以接受 Service Worker 的指令操作 DOM。</li>
</ul>
<p>Service Worker 有几个重要的功能性的的事件，这些功能性的事件支撑和实现了 Service Worker 的特性。</p>
<ul>
<li>fetch (请求)：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response参数的回调函数，回调中就可以做各种代理缓存的事情了。</li>
<li>push (推送)：push 事件是为推送准备的。不过首先需要了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="external">Notification API</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="external">PUSH API</a>。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</li>
<li><strong>sync (后台同步)</strong>：sync 事件由 background sync (后台同步)发出。background sync 配合 Service Worker 推出的 API，用于为 Service Worker 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C Web API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。</li>
</ul>
<h2 id="Service-Worker-调试"><a href="#Service-Worker-调试" class="headerlink" title="Service Worker 调试"></a>Service Worker 调试</h2><p>Service Worker 作为独立于主线程的独立线程，在调试方面有其实和常规的 JavaScript 开发类似，我们关注的点大概有如下几点：</p>
<ul>
<li>代码是否有报错；</li>
<li>Service Worker 能否顺利更新；</li>
<li>在不同机型上的兼容性问题 debug；</li>
<li>不同类型资源和请求的缓存策略的验证。</li>
</ul>
<h3 id="debug-环境下等待状态"><a href="#debug-环境下等待状态" class="headerlink" title="debug 环境下等待状态"></a>debug 环境下等待状态</h3><p>根据 Service Worker 生命周期的特性，如果浏览器还在使用旧的 Service Worker 版本，即使有 Service Worker 新的版本也不会立即被浏览器激活，只能进行安装并进入等待状态，直到浏览器 Tab 标签被重新关闭打开。</p>
<p>在开发调试 Service Worker 时肯定希望重新加载后立即激活，我们不希望每次都重新打开当前页面调试，为此我们可以在 install 事件发生时通过 skipWaiting() 来设置 skip waiting 标记。 这样每次 Service Worker 安装后就会被立即激活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(&apos;install&apos;, function () &#123;</div><div class="line">    if (ENV === &apos;development&apos;) &#123;</div><div class="line">        self.skipWaiting();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是当浏览器未检测到 Service Worker 发生变化时（比如该文件设置了 HTTP 缓存）， 甚至连安装都不会被触发。现在可以借助于浏览器 DevTools 调试了： 比如在 Chrome DevTools 的 Application 标签页勾选 Update on reload，Chrome 会在每次刷新时去访问 Service Worker 文件并重新安装和激活。</p>
<h3 id="借助-Chrome-浏览器进行-debug"><a href="#借助-Chrome-浏览器进行-debug" class="headerlink" title="借助 Chrome 浏览器进行 debug"></a>借助 Chrome 浏览器进行 debug</h3><p>使用 Chrome 浏览器，可以通过进入控制台 Application -&gt; Service Workers 面板查看和调试。如下图所示：<br><img src="http://img.blog.csdn.net/20180126164758216" alt="这里写图片描述"><br>如果 Service Worker 线程已安装到当前打开的页面上，您会看到它将列示在此窗格中。 例如，在上方的屏幕截图中，<a href="https://lavas-project.github.io/lavas-demo/news-v2/#/" target="_blank" rel="external">https://lavas-project.github.io/lavas-demo/news-v2/#/</a> 的作用域内安装了一个 Service Worker 线程。</p>
<p>其中，Service Worker会有以下几个选项：</p>
<ul>
<li><strong>offline</strong>： 复选框可以将 DevTools 切换至离线模式。它等同于 Network 窗格中的离线模式。</li>
<li><strong>Update on reload</strong>：复选框可以强制 Service Worker 线程在每次页面加载时更新。</li>
<li><strong>Bypass for network</strong>：复选框可以绕过 Service Worker 线程并强制浏览器转至网络寻找请求的资源。</li>
<li><strong>Update</strong>：按钮可以对指定的 Service Worker 线程执行一次性更新。</li>
<li><strong>Push</strong>：按钮可以在没有负载的情况下模拟推送通知。</li>
<li><strong>Sync</strong>：按钮可以模拟后台同步事件。</li>
<li><strong>Unregister</strong>：按钮可以注销指定的 Service Worker 线程。</li>
<li><strong>Source</strong>：告诉您当前正在运行的 Service Worker 线程的安装时间。 链接是 Service Worker线程源文件的名称。点击链接会将您定向至 Service Worker 线程来源。</li>
<li><strong>Status</strong>：告诉您 Service Worker 线程的状态。此行上的数字（上方屏幕截图中的 #1）指示 Service Worker线程已被更新的次数。如果启用 update on reload 复选框，您会注意到每次页面加载时此数字都会增大。在状态旁边，您将看到 start 按钮（如果 Service Worker 线程已停止）或 stop 按钮（如果 Service Worker 线程正在运行）。  Service Worker 线程设计为可由浏览器随时停止和启动。 使用 stop 按钮明确停止 Service Worker 线程可以模拟这一点。停止 Service Worker 线程是测试 Service Worker线程再次重新启动时的代码行为方式的绝佳方法。它通常可以揭示由于对持续全局状态的不完善假设而引发的错误。</li>
<li><strong>Clients</strong>：告诉您 Service Worker 线程作用域的原点。 如果您已启用 show all 复选框，focus按钮将非常实用。 在此复选框启用时，系统会列出所有注册的 Service Worker 线程。 如果您点击正在不同标签中运行的Service Worker 线程旁的 focus 按钮，Chrome 会聚焦到该标签。</li>
</ul>
<p>如果 Service Worker 文件在运行过程中出现了任何的错误，将显示一个 Error 新标签。例如：<br><img src="http://img.blog.csdn.net/20180126165227926" alt="这里写图片描述"></p>
<p>当然我们也可以直接访问 Chrome://serviceworker-internals 来打开 serviceWorker 的配置面板，查看所有注册的 Service Worker 情况。注意一点，如无必要，不要选中顶部的 Open DevTools window and pause javaScript execution on Service Worker startup for debugging 复选框，否则每当刷新页面调试时都会弹出一个开发者窗口来。</p>
<p>在 Firefox 中，可以通过 Tools -&gt; Web Developer -&gt; Service Workers 打开调试面板。也可以访问 about:debugging#workers 直接进入该面板。</p>
<h3 id="Service-Worker-缓存内容"><a href="#Service-Worker-缓存内容" class="headerlink" title="Service Worker 缓存内容"></a>Service Worker 缓存内容</h3><p>我们知道，Service Worker 使用 Cache API 缓存只读资源，我们同样可以在 Chrome DevTools 上查看缓存的资源列表。Cache Storage 选项卡提供了一个已使用（Service Worker 线程）Cache API 缓存的只读资源列表。<br><img src="http://img.blog.csdn.net/20180126165829698" alt="这里写图片描述"></p>
<p>这里有个地方需要注意一下：第一次打开缓存并向其添加资源时，Chrome DevTools 可能检测不到更改。 重新加载页面后，您应当可以看到缓存。<br><img src="http://img.blog.csdn.net/20180126165943621" alt="这里写图片描述"><br>当然，Cache Storage 提供清除 Cache 列表的功能，在选择 Cache Storage 选项卡后在 Cache Storge 缓存的 key 的 item 上右键点击出现 delete ，点击 delete 就可以清除该缓存了。<br><img src="http://img.blog.csdn.net/20180126170032650" alt="这里写图片描述"></p>
<h3 id="网络跟踪调试"><a href="#网络跟踪调试" class="headerlink" title="网络跟踪调试"></a>网络跟踪调试</h3><p>此外经过 Service Worker 的 fetch 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中：</p>
<ul>
<li>来自 Service Worker 的内容会在 Size 字段中标注为 from ServiceWorker。</li>
<li>Service Worker 发出的请求会在 Name 字段中添加 ⚙ 图标。</li>
</ul>
<p>例如下图中，第一个名为 300 的请求是一张 jpeg 图片， 其 URL 为 <a href="https://unsplash.it/200/300，该请求是由" target="_blank" rel="external">https://unsplash.it/200/300，该请求是由</a> Service Worker 代理的， 因此被标注为 from ServiceWorker。</p>
<p>为了响应页面请求，Service Worker 也发出了名为 300 的请求（这是图中第二个请求）， 但 Service Worker 把 URL 改成了 <a href="https://unsplash.it/g/200/300，因此返回给页面的图片是灰色的。" target="_blank" rel="external">https://unsplash.it/g/200/300，因此返回给页面的图片是灰色的。</a></p>
<p><img src="http://img.blog.csdn.net/20180126170518763" alt="这里写图片描述"></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>所谓“工欲善其事，必先利其器”，在开始开发PWA程序之前，需要安装好相关的运行环境，PWA需要Node 和 Ngrok 支持。关于Node 的使用以及安装我就不说啦，而Ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。</p>
<h2 id="Ngrok安装使用"><a href="#Ngrok安装使用" class="headerlink" title="Ngrok安装使用"></a>Ngrok安装使用</h2><p>读者可以到<a href="https://ngrok.com/download" target="_blank" rel="external">Ngrok官网</a>下载它，解压后某个目录。</p>
<p>需要注意的是，有的人说需要注册ngrok得到your auth token，后面的自定义域名必须要有这个token，因为我暂时不需要自定义域名，所以就省略了这一步。<br>然后在解压后的Ngrok目录下使用命令：./ngrok help<br><img src="http://img.blog.csdn.net/20180126171921049" alt="这里写图片描述"></p>
<p>然后，使用如下命令来开启服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ngrok http localhost:9988</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20180126172053515" alt="这里写图片描述"></p>
<p>其中，<a href="http://dae1a9d6.ngrok.io和https://dae1a9d6.ngrok.io就是本地localhost映射的外网地址，注意这个映射外网地址是变化的，也就是你每次启动ngrok，获取的外网地址是不一样的，貌似如果想使用固定外网地址，就需要收费。" target="_blank" rel="external">http://dae1a9d6.ngrok.io和https://dae1a9d6.ngrok.io就是本地localhost映射的外网地址，注意这个映射外网地址是变化的，也就是你每次启动ngrok，获取的外网地址是不一样的，貌似如果想使用固定外网地址，就需要收费。</a> </p>
<p>然后输入<a href="http://dae1a9d6.ngrok.io地址就可以访问了。" target="_blank" rel="external">http://dae1a9d6.ngrok.io地址就可以访问了。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在去年上海举办的2017谷歌开发者大会上，PWA作为会议的一个重要内容被推介，笔者作为参会嘉宾看了PWA的内容后，觉得这种技术会是未来移动发展的一个趋势。Google开发技术推广工程师Michael Yeung介绍称，新浪微博正在打造一款全新体验的Web Mobile PW
    
    </summary>
    
      <category term="PWA" scheme="http://www.xiangzhihong.com/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://www.xiangzhihong.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>React Native 0.50版本新功能简介</title>
    <link href="http://www.xiangzhihong.com/2017/10/27/React%20Native%200.50%E7%89%88%E6%9C%AC%E6%96%B0%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2017/10/27/React Native 0.50版本新功能简介/</id>
    <published>2017-10-26T16:00:00.000Z</published>
    <updated>2018-02-11T03:18:43.835Z</updated>
    
    <content type="html"><![CDATA[<p>React Native在2017年经历了众多版本的迭代，从本人接触的0.29版本开始，到前不久发布的0.52版本，React Native作为目前最受欢迎的移动跨平台方案。虽然，目前存在着很多的功能和性能的缺失，但是不可否认的是React Native确实在进步。</p>
<p>本文主要从以下几个方面来对React Native0.50+进行讲解：</p>
<ul>
<li>在兼容性方面新增了对Android8.0、iPhone X的支持；</li>
<li>在API方面为TimePicker添加了打开方式的API，另外允许在构建Android项目的时候指定applicationId;</li>
<li>在组件方面，新添加了支持侧滑显示菜单的SwipeableFlatList，以及SafeAreaView。</li>
<li>修复了一些关键性的Bug；</li>
</ul>
<h2 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h2><p>React Native 0.50版本中 Image组件迎来了比较大的一个特性的改变，即在React Native 0.50及以上版本中Image不在支持包裹内容。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Image style=</div><div class="line">       resizeMode=&quot;center&quot;</div><div class="line">       source=&gt;</div><div class="line">    &lt;Text&gt;《React Native移动开发实战》&lt;/Text&gt;</div><div class="line">&lt;/Image&gt;</div></pre></td></tr></table></figure>
<p>以上代码在0.50之前是可以正常运行的，在0.50上运行会报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unhandled JS Exception: Error: The &lt;Image&gt; component cannot contain children. If you want to render content on top of the image, consider using aboslute positioning.</div></pre></td></tr></table></figure>
<p>如果要在0.50+版本中使用Image组件，可以按照下面的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Image style=</div><div class="line">       resizeMode=&quot;center&quot;</div><div class="line">       source=/&gt;</div><div class="line"> &lt;Text&gt;《React Native移动开发实战》&lt;/Text&gt;</div></pre></td></tr></table></figure>
<h2 id="其他重大变更"><a href="#其他重大变更" class="headerlink" title="其他重大变更"></a>其他重大变更</h2><ol>
<li>ReactShadowNode由类被抽象成了接口，代替他的是ReactShadowNodeImpl，这是来自底层的变更，对上层API无影响。</li>
<li><p>enableBabelRCLookup(启用BabelRCL查找)，由原来的默认开启改为了默认关闭，改过之后Metro只会关注项目的.babelrc文件。在之前Metro会关注node_modules下的.babelrc文件，这样将会导致一些问题，因为它没有Babel的版本，也没有node_modules/randompackage/.babelrc所需的plugins/presets。现在，从0.50版本之后getEnableBabelRCLookup默认返回false，从而避免了这一问题。如果你不想使用这一改变，那么可以这样配置：</p>
<p>创建一个rn-cli.config.js文件，并添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    getEnableBabelRCLookup() &#123;</div><div class="line">      return true;</div><div class="line">    &#125;,</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>   然后，在node_modules下修改.babelrc :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;plugins&quot;: [&quot;dummy&quot;]&#125;</div></pre></td></tr></table></figure>
<h1 id="修复的系统bug"><a href="#修复的系统bug" class="headerlink" title="修复的系统bug"></a>修复的系统bug</h1><p>在0.50版本中，修复的系统bug有：</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>1，修复了在Android SDK 15及以下版本设置背景的Bug。在Android中设置View的背景在SDK15及以下和以上和的API是不一样的，在之前的RN版本中没有做差异判断，所以会导致在低版本设置背景的Bug，在0.50及以上版本底层实现上添加了ViewHelper工具类，当设置背景时会根据当前SDK版本是16及以上或以下进行做不同的处理；</p>
<p>处理的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ViewHelper &#123;</div><div class="line"> public static void setBackground(View view, Drawable drawable&#123; </div><div class="line"> if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; </div><div class="line"> view.setBackground(drawable); </div><div class="line"> &#125; else &#123; </div><div class="line"> view.setBackgroundDrawable(drawable);</div><div class="line">    &#125; </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>2，修复了slider的minimumTrackTintColor 和 maximumTrackTintColor在Android和iOS上颜色颠倒的问题。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Slider</div><div class="line">    style=</div><div class="line">    minimumTrackTintColor=&quot;red&quot;</div><div class="line">    maximumTrackTintColor=&quot;blue&quot;</div><div class="line">  /&gt;</div></pre></td></tr></table></figure>
<p> 显示效果如下：</p>
<p>  <img src="http://img.blog.csdn.net/20180122140350603" alt="这里写图片描述"></p>
<p> 3，修复了Android 4.1-4.3 WebView的Bug。</p>
<p>在0.50之前的版本当使用WebView的baseUrl时在Android 4.1-4.3会显示出html源码，这是因为在Android 4.1-4.3中WebView不支持text/html的charset=utf-8的MIME type所导致的。</p>
<p>4，修复了View Style的overflow hidden问题。</p>
<p>很久以来overflow样式在Android默认为hidden而且无法更改。Android的overflow:hidden还有另外一个问题：如果父容器有borderRadius圆角边框样式，那么即便开启了overflow:hidden也仍然无法把子视图超出圆角边框的部分裁切掉。</p>
<p>5，修复了Java到C++到JS ViewManagers的交互问题；</p>
<p>6，修复了DeviceIdentity(设备标识)；</p>
<h2 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h2><p>修复了React/RCTJavascriptLoader.mm的Content-Type检查问题，在之前RCTJavascriptLoader对Content-Type的支持是有缺陷的，只能匹配application/javascript或text/javascript两种类型，现在的做法是Content-Type对以application/javascript或text/javascript开头的Content-Type都可以支持；</p>
<h1 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h1><p>0.50版本新增了很多的功能，本文只针对某些重点进行讲解，详细的还请阅读官方资料。通用的功能有：</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul>
<li>新增SwipeableFlatList组件，SwipeableFlatList是在FlatList的基础上添加了侧滑显示菜单的功能，类似于侧滑删除的效果。我们知道SwipeableListView，是React Native 0.27上添加的一个支持侧滑显示菜单的ListView，不过ListView已经不推荐使用了。</li>
<li>引入SafeAreaView，SafeAreaView用于包裹其他View，它会自动应用填充布局中不足的一部分，但不包括navigation bars, tab bars, toolbars等视图。</li>
</ul>
<h2 id="Android-1"><a href="#Android-1" class="headerlink" title="Android"></a>Android</h2><h3 id="TimePicker"><a href="#TimePicker" class="headerlink" title="TimePicker"></a>TimePicker</h3><p>TimePicker添加了mode (enum(‘clock’, ‘spinner’, ‘default’)) 来控制TimePicker的打开模式。</p>
<p>TimePicker是一个老的API了，通过TimePicker组件可以打开Android原生的时间选择对话框。Android 5以下的设备只支持spinner模式，Android 5及以上设备支持clock, spinner两种模式：<br><strong>Android &lt; 5的显示方式如下：</strong><br><img src="http://img.blog.csdn.net/20180122141758669" alt="这里写图片描述"></p>
<p><strong>Android &gt; 5的显示方式如下：</strong><br><img src="http://img.blog.csdn.net/20180122141904138" alt="这里写图片描述"></p>
<h3 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h3><p>运行在构建的时候指定Android App的applicationId(Android应用的身份ID，应用的唯一标识)；</p>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>Added Android support for loading multiple RAM bundles。</p>
<h2 id="iOS方面"><a href="#iOS方面" class="headerlink" title="iOS方面"></a>iOS方面</h2><h3 id="DeviceInfo"><a href="#DeviceInfo" class="headerlink" title="DeviceInfo"></a>DeviceInfo</h3><p>DeviceInfo 新增DeviceInfo.isIPhoneX_deprecatedAPI来供开发者判断当前设备是不是iPhone X，带有小刘海的iPhone X的屏幕比其他iPhone 手机的屏幕拥有更大高度，所以对于界面布局来说，在iPhone X上需要特别适配。<br>DeviceInfo是React Native 0.44新增一个类专门提供屏幕尺寸，字体缩放等信息。</p>
<h3 id="Modal组件"><a href="#Modal组件" class="headerlink" title="Modal组件"></a>Modal组件</h3><p>Modal组件新增支持onDismiss属性，这个onDismiss接受一个function，当Modal关闭的时候会回调onDismiss。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Modal</div><div class="line">   onDismiss=&#123;()=&gt;&#123;</div><div class="line">     console.log(&quot;Modal is dismiss&quot;);</div><div class="line">      &#125;</div><div class="line">      &#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<p>除了上面介绍的更新内容之外，还有很多的东西，这里就不再介绍，大家可以到<a href="http://reactnative.cn/" target="_blank" rel="external">RN中文网</a>查看相关最新知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React Native在2017年经历了众多版本的迭代，从本人接触的0.29版本开始，到前不久发布的0.52版本，React Native作为目前最受欢迎的移动跨平台方案。虽然，目前存在着很多的功能和性能的缺失，但是不可否认的是React Native确实在进步。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="http://www.xiangzhihong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之提供委托</title>
    <link href="http://www.xiangzhihong.com/2017/10/23/Kotlin%E4%B9%8B%E6%8F%90%E4%BE%9B%E5%A7%94%E6%89%98/"/>
    <id>http://www.xiangzhihong.com/2017/10/23/Kotlin之提供委托/</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:04:47.839Z</updated>
    
    <content type="html"><![CDATA[<p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p>
<p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。例如，如果要在绑定之前检查属性名称，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</div><div class="line">    operator fun provideDelegate(</div><div class="line">            thisRef: MyUI,</div><div class="line">            prop: KProperty&lt;*&gt;</div><div class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">        checkProperty(thisRef, prop.name)</div><div class="line">        // 创建委托</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</div><div class="line"></div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id)</div><div class="line">    val text by bindResource(ResourceID.text_id)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>provideDelegate 的参数与 getValue 相同：</p>
<ul>
<li>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型。</li>
<li>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用provideDelegate 方法，并立即执行必要的验证。</li>
</ul>
<p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 检查属性名称而不使用“provideDelegate”功能</div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</div><div class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; MyUI.bindResource(</div><div class="line">        id: ResourceID&lt;T&gt;,</div><div class="line">        propertyName: String</div><div class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</div><div class="line">   checkProperty(this, propertyName)</div><div class="line">   // 创建委托</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这段代码是当“provideDelegate”功能可用时，由编译器生成的代码：</div><div class="line">class C &#123;</div><div class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</div><div class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</div><div class="line">    val prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>
<p>上面例子的完整代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val myui: MyUI = MyUI()</div><div class="line">    println(myui.image)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class dge&lt;T&gt;(t: T) &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ResourceLoader&lt;T&gt;(id: Int) &#123;</div><div class="line">    operator fun provideDelegate(</div><div class="line">            thisRef: MyUI,</div><div class="line">            prop: KProperty&lt;*&gt;</div><div class="line">    ): dge&lt;T?&gt; &#123;</div><div class="line">        checkProperty(thisRef, prop.name)</div><div class="line">        // 创建委托</div><div class="line">        var t: T? = null</div><div class="line">        return dge(t)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123;</div><div class="line">        println(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T&gt; bindResource(id: Int): ResourceLoader&lt;T&gt; &#123;</div><div class="line">    return ResourceLoader&lt;T&gt;(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyUI &#123;</div><div class="line">    val image by bindResource&lt;String&gt;(1)</div><div class="line">    val text by bindResource&lt;String&gt;(2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。&lt;/p&gt;
&lt;p&gt;provideDelegate 的一个可能的
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>RxJs简介</title>
    <link href="http://www.xiangzhihong.com/2017/10/23/RxJs%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xiangzhihong.com/2017/10/23/RxJs简介/</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:15:42.543Z</updated>
    
    <content type="html"><![CDATA[<p>这两年，各种异步编程框架，上面RxJava,RxAndroid,RxSwift等等，今天要聊的是RxJs，对于我等入门不久的前端工程师来说，这个框架还是比较有新颖的，中文官网地址：<a href="http://cn.rx.js.org/" target="_blank" rel="external">http://cn.rx.js.org/</a></p>
<h2 id="RxJs简介"><a href="#RxJs简介" class="headerlink" title="RxJs简介"></a>RxJs简介</h2><p>RxJS是一个异步编程的库，同时它通过observable序列来实现基于事件的编程。它提供了一个核心的类型：Observable，几个辅助类型（Observer，Schedulers，Subjects），受到Array的扩展操作（map，filter，reduce，every等等）启发，允许直接处理异步事件的集合。</p>
<p>ReactiveX结合了Observer模式、Iterator模式和函数式编程和集合来构建一个管理事件序列的理想方式。在RxJS中管理异步事件的基本概念中有以下几点需要注意：</p>
<ul>
<li><strong>Observable</strong>：代表了一个调用未来值或事件的集合的概念</li>
<li><strong>Observer</strong>：代表了一个知道如何监听Observable传递过来的值的回调集合</li>
<li><strong>Subscription</strong>：代表了一个可执行的Observable，主要是用于取消执行</li>
<li><strong>Operators</strong>：是一个纯函数，允许处理集合与函数式编程风格的操作，比如map、filter、concat、flatMap等</li>
<li><strong>Subject</strong>：相当于一个EventEmitter，它的唯一的方法是广播一个值或事件给多个Observer</li>
<li><strong>Schedulers</strong>：是一个集中式调度程序来控制并发性，允许我们在setTimeout或者requestAnimationFrame上进行协调计算</li>
</ul>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>正常情况下，注册一个事件监听函数的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; console.log(&apos;Clicked!&apos;));</div></pre></td></tr></table></figure>
<p>使用RxJS，你可以创建一个observable来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .subscrible(() =&gt; console.log(&apos;Clicked!&apos;));</div></pre></td></tr></table></figure>
<h2 id="纯净性-Purity"><a href="#纯净性-Purity" class="headerlink" title="纯净性 (Purity)"></a>纯净性 (Purity)</h2><p>使得RxJS变得如此强大的原因是它使用了纯函数，这意味着你的代码很少会发生错误。正常情况下，你不会选择创建一个纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; console.log(`Clicked $(++count) times`));</div></pre></td></tr></table></figure>
<p>而在RxJs中却可以大量使用纯函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .scan(count =&gt; count + 1, 0)</div><div class="line">  .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; items`));</div></pre></td></tr></table></figure>
<p>其中，scan操作符类似于arrays的reduce操作符。它需要一个回调函数作为一个参数，函数返回的值将作为下次调用时的参数。</p>
<h2 id="流动性-Flow"><a href="#流动性-Flow" class="headerlink" title="流动性 (Flow)"></a>流动性 (Flow)</h2><p>RxJS 提供了一整套操作符来帮助你控制事件如何流经 observables 。<br>下面的代码展示的是如何控制一秒钟内最多点击一次，先来看使用普通的 JavaScript：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var rate = 1000;</div><div class="line">var lastClick = Date.now() - rate;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, () =&gt; &#123;</div><div class="line">  if (Date.now() - lastClick &gt;= rate) &#123;</div><div class="line">    console.log(`Clicked $&#123;++count&#125; times`);</div><div class="line">    lastClick = Date.now();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 RxJS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .throttleTime(1000)</div><div class="line">  .scan(count =&gt; count + 1, 0)</div><div class="line">  .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`));</div></pre></td></tr></table></figure>
<p>其他流程控制操作符有 filter、delay、debounceTime、take、takeUntil、distinct、distinctUntilChanged 等等。</p>
<h2 id="值-Values"><a href="#值-Values" class="headerlink" title="值 (Values)"></a>值 (Values)</h2><p>对于流经 observables 的值，你可以对其进行转换。<br>下面的代码展示的是如何累加每次点击的鼠标 x 坐标，先来看使用普通的 JavaScript：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var count = 0;</div><div class="line">var rate = 1000;</div><div class="line">var lastClick = Date.now() - rate;</div><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">button.addEventListener(&apos;click&apos;, (event) =&gt; &#123;</div><div class="line">  if (Date.now() - lastClick &gt;= rate) &#123;</div><div class="line">    count += event.clientX;</div><div class="line">    console.log(count)</div><div class="line">    lastClick = Date.now();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用 RxJS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var button = document.querySelector(&apos;button&apos;);</div><div class="line">Rx.Observable.fromEvent(button, &apos;click&apos;)</div><div class="line">  .throttleTime(1000)</div><div class="line">  .map(event =&gt; event.clientX)</div><div class="line">  .scan((count, clientX) =&gt; count + clientX, 0)</div><div class="line">  .subscribe(count =&gt; console.log(count));</div></pre></td></tr></table></figure>
<p>其他产生值的操作符有 pluck、pairwise、 sample 等等。</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>Observables 是多个值的惰性推送集合。它填补了下面表格中的空白：</p>
<table><br>        <tr><br>            <th>行为</th><br>            <th>单个值</th><br>            <th>多个值</th><br>        </tr><br>         <tr><br>            <th>拉取</th><br>            <th>Function</th><br>            <th>Iterator</th><br>        </tr><br>         <tr><br>            <th>推送</th><br>            <th>Promise</th><br>            <th>Observable</th><br>        </tr><br></table>

<p>例如：当订阅下面代码中的 Observable 的时候会立即(同步地)推送值1、2、3，然后1秒后会推送值4，再然后是完成流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(4);</div><div class="line">    observer.complete();</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>要调用 Observable 并看到这些值，我们需要订阅 Observable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(4);</div><div class="line">    observer.complete();</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(&#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>控制台执行的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">just before subscribe</div><div class="line">got value 1</div><div class="line">got value 2</div><div class="line">got value 3</div><div class="line">just after subscribe</div><div class="line">got value 4</div><div class="line">done</div></pre></td></tr></table></figure>
<h2 id="拉取-Pull-vs-推送-Push"><a href="#拉取-Pull-vs-推送-Push" class="headerlink" title="拉取 (Pull) vs. 推送 (Push)"></a>拉取 (Pull) vs. 推送 (Push)</h2><p>拉取和推送是两种不同的协议，用来描述数据生产者 (Producer)如何与数据消费者 (Consumer)如何进行通信的。</p>
<p>什么是拉取？ - 在拉取体系中，由消费者来决定何时从生产者那接收数据。生产者本身不知道数据是何时交付到消费者手中的。</p>
<p>每个 JavaScript 函数都是拉取体系。函数是数据的生产者，调用该函数的代码通过从函数调用中“取出”一个单个返回值来对该函数进行消费。</p>
<p>ES2015 引入了 generator 函数和 iterators (function*)，这是另外一种类型的拉取体系。调用 iterator.next() 的代码是消费者，它会从 iterator(生产者) 那“取出”多个值。</p>
<table><br>        <tr><br>            <th>行为</th><br>            <th>生产者</th><br>            <th>消费者</th><br>        </tr><br>         <tr><br>            <th>拉取</th><br>            <th>被动的: 当被请求时产生数据。</th><br>            <th>主动的: 决定何时请求数据。</th><br>        </tr><br>         <tr><br>            <th>推送</th><br>            <th>主动的: 按自己的节奏产生数据。</th><br>            <th>被动的: 对收到的数据做出反应。</th><br>        </tr><br></table>

<p>什么是推送？ - 在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据。</p>
<p>在当今的 JavaScript 世界中，Promises 是最常见的推送体系类型。Promise(生产者) 将一个解析过的值传递给已注册的回调函数(消费者)，但不同于函数的是，由 Promise 来决定何时把值“推送”给回调函数。</p>
<p>RxJS 引入了 Observables，一个新的 JavaScript 推送体系。Observable 是多个值的生产者，并将值“推送”给观察者(消费者)。</p>
<ul>
<li><strong>Function</strong> 是惰性的评估运算，调用时会同步地返回一个单一值。</li>
<li><strong>Generator</strong> 是惰性的评估运算，调用时会同步地返回零到(有可能的)无限多个值。</li>
<li><strong>Promise</strong> 是最终可能(或可能不)返回单个值的运算。</li>
<li><strong>Observable</strong> 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到(有可能的)无限多个值。</li>
</ul>
<h2 id="Observables-作为函数的泛化"><a href="#Observables-作为函数的泛化" class="headerlink" title="Observables 作为函数的泛化"></a>Observables 作为函数的泛化</h2><p>与流行的说法正好相反，Observables 既不像 EventEmitters，也不像多个值的 Promises 。在某些情况下，即当使用 RxJS 的 Subjects 进行多播时， Observables 的行为可能会比较像 EventEmitters，但通常情况下 Observables 的行为并不像 EventEmitters 。</p>
<p>考虑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  return 42;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var x = foo.call(); // 等同于 foo()</div><div class="line">console.log(x);</div><div class="line">var y = foo.call(); // 等同于 foo()</div><div class="line">console.log(y);</div></pre></td></tr></table></figure>
<p>我们期待看到的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div></pre></td></tr></table></figure>
<p>可以使用 Observables 重写上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">foo.subscribe(function (y) &#123;</div><div class="line">  console.log(y);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div></pre></td></tr></table></figure>
<p>这是因为函数和 Observables 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observables 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observables 与之相反，不会共享副作用并且是延迟执行。<br>一些人声称 Observables 是异步的。那不是真的。如果你用日志包围一个函数调用，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;before&apos;);</div><div class="line">console.log(foo.call());</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">&quot;after&quot;</div></pre></td></tr></table></figure>
<p>使用 Observables 来做同样的事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>这证明了 foo 的订阅完全是同步的，就像函数一样。那么 Observable 和 函数的区别是什么呢？Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。例如，下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  return 42;</div><div class="line">  return 100; // 死代码，永远不会执行</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数只能返回一个值。但 Observables 可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">  observer.next(100); // “返回”另外一个值</div><div class="line">  observer.next(200); // 还可以再“返回”值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">100</div><div class="line">200</div><div class="line">&quot;after&quot;</div></pre></td></tr></table></figure>
<p>同时，你还可以异步地“返回”值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var foo = Rx.Observable.create(function (observer) &#123;</div><div class="line">  console.log(&apos;Hello&apos;);</div><div class="line">  observer.next(42);</div><div class="line">  observer.next(100);</div><div class="line">  observer.next(200);</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    observer.next(300); // 异步执行</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;before&apos;);</div><div class="line">foo.subscribe(function (x) &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;after&apos;);</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;before&quot;</div><div class="line">&quot;Hello&quot;</div><div class="line">42</div><div class="line">100</div><div class="line">200</div><div class="line">&quot;after&quot;</div><div class="line">300</div></pre></td></tr></table></figure>
<p>结论:</p>
<p>func.call() 意思是 “同步地给我一个值”</p>
<p>observable.subscribe() 意思是 “给我任意数量的值，无论是同步还是异步”。</p>
<h1 id="Observable-剖析"><a href="#Observable-剖析" class="headerlink" title="Observable 剖析"></a>Observable 剖析</h1><p>Observables 是使用 Rx.Observable.create 或创建操作符创建的，并使用观察者来订阅它，然后执行它并发送 next / error / complete 通知给观察者，而且执行可能会被清理。这四个方面全部编码在 Observables 实例中，但某些方面是与其他类型相关的，像 Observer (观察者) 和 Subscription (订阅)。</p>
<p>Observable 的核心有4点：</p>
<ul>
<li>创建 Observables</li>
<li>订阅 Observables</li>
<li>执行 Observables</li>
<li>清理 Observables</li>
</ul>
<h2 id="创建-Observables"><a href="#创建-Observables" class="headerlink" title="创建 Observables"></a>创建 Observables</h2><p>Rx.Observable.create 是 Observable 构造函数的别名，它接收一个参数：subscribe 函数。下面的示例创建了一个 Observable，它每隔一秒会向观察者发送字符串 ‘hi’ 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  var id = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;)</div><div class="line">  &#125;, 1000);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Observables 可以使用 create 来创建, 但通常我们使用所谓的创建操作符, 像 of、from、interval、等等。在上面的示例中，subscribe 函数是用来描述 Observable 最重要的一块。我们来看下订阅是什么意思。</p>
<h2 id="订阅-Observables"><a href="#订阅-Observables" class="headerlink" title="订阅 Observables"></a>订阅 Observables</h2><p>示例中的 Observable 对象 observable 可以订阅，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>observable.subscribe 和 Observable.create(function subscribe(observer) {…}) 中的 subscribe 有着同样的名字，这并不是一个巧合。在库中，它们是不同的，但从实际出发，你可以认为在概念上它们是等同的。</p>
<p>这表明 subscribe 调用在同一 Observable 的多个观察者之间是不共享的。当使用一个观察者调用 observable.subscribe 时，Observable.create(function subscribe(observer) {…}) 中的 subscribe 函数只服务于给定的观察者。对 observable.subscribe 的每次调用都会触发针对给定观察者的独立设置。</p>
<p><strong>订阅 Observable 像是调用函数, 并提供接收数据的回调函数。</strong></p>
<p>这与像 addEventListener / removeEventListener 这样的事件处理方法 API 是完全不同的。使用 observable.subscribe，在 Observable 中不会将给定的观察者注册为监听器。Observable 甚至不会去维护一个附加的观察者列表。</p>
<p>subscribe 调用是启动 “Observable 执行”的一种简单方式， 并将值或事件传递给本次执行的观察者。</p>
<h2 id="执行-Observables"><a href="#执行-Observables" class="headerlink" title="执行 Observables"></a>执行 Observables</h2><p>Observable.create(function subscribe(observer) {…}) 中…的代码表示 “Observable 执行”，它是惰性运算，只有在每个观察者订阅后才会执行。随着时间的推移，执行会以同步或异步的方式产生多个值。</p>
<p>Observable 执行可以传递三种类型的值：</p>
<ul>
<li>“Next” 通知： 发送一个值，比如数字、字符串、对象，等等。</li>
<li>“Error” 通知： 发送一个 JavaScript 错误 或 异常。</li>
<li>“Complete” 通知： 不再发送任何值。</li>
</ul>
<p>“Next” 通知是最重要，也是最常见的类型：它们表示传递给观察者的实际数据。”Error” 和 “Complete” 通知可能只会在 Observable 执行期间发生一次，并且只会执行其中的一个。</p>
<p>这些约束用所谓的 Observable 语法或合约表达最好，写为正则表达式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next*(error|complete)?</div></pre></td></tr></table></figure>
<p><strong>在 Observable 执行中, 可能会发送零个到无穷多个 “Next” 通知。如果发送的是 “Error” 或 “Complete” 通知的话，那么之后不会再发送任何通知了。</strong></p>
<p>下面是 Observable 执行的示例，它发送了三个 “Next” 通知，然后是 “Complete” 通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Observable 严格遵守自身的规约，所以下面的代码不会发送 “Next” 通知 4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">  observer.next(4); // 因为违反规约，所以不会发送</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 subscribe 中用 try/catch 代码块来包裹任意代码是个不错的主意，如果捕获到异常的话，会发送 “Error” 通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  try &#123;</div><div class="line">    observer.next(1);</div><div class="line">    observer.next(2);</div><div class="line">    observer.next(3);</div><div class="line">    observer.complete();</div><div class="line">  &#125; catch (err) &#123;</div><div class="line">    observer.error(err); // 如果捕获到异常会发送一个错误</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="清理-Observable-执行"><a href="#清理-Observable-执行" class="headerlink" title="清理 Observable 执行"></a>清理 Observable 执行</h2><p>因为 Observable 执行可能会是无限的，并且观察者通常希望能在有限的时间内中止执行，所以我们需要一个 API 来取消执行。因为每个执行都是其对应观察者专属的，一旦观察者完成接收值，它必须要一种方法来停止执行，以避免浪费计算能力或内存资源。</p>
<p>当调用了 observable.subscribe ，观察者会被附加到新创建的 Observable 执行中。这个调用还返回一个对象，即 Subscription (订阅)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>Subscription 表示进行中的执行，它有最小化的 API 以允许你取消执行。想了解更多订阅相关的内容，请参见 Subscription 类型。使用 subscription.unsubscribe() 你可以取消进行中的执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.from([10, 20, 30]);</div><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div><div class="line">// 稍后：</div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
<p><strong>当你订阅了 Observable，你会得到一个 Subscription ，它表示进行中的执行。只要调用 unsubscribe() 方法就可以取消执行。</strong></p>
<p>当我们使用 create() 方法创建 Observable 时，Observable 必须定义如何清理执行的资源。你可以通过在 function subscribe() 中返回一个自定义的 unsubscribe 函数。</p>
<p>举例来说，这是我们如何清理使用了 setInterval 的 interval 执行集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">  // 追踪 interval 资源</div><div class="line">  var intervalID = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;);</div><div class="line">  &#125;, 1000);</div><div class="line"></div><div class="line">  // 提供取消和清理 interval 资源的方法</div><div class="line">  return function unsubscribe() &#123;</div><div class="line">    clearInterval(intervalID);</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正如 observable.subscribe 类似于 Observable.create(function subscribe() {…})，从 subscribe 返回的 unsubscribe 在概念上也等同于 subscription.unsubscribe。事实上，如果我们抛开围绕这些概念的 ReactiveX 类型，保留下来的只是相当简单的 JavaScript 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function subscribe(observer) &#123;</div><div class="line">  var intervalID = setInterval(() =&gt; &#123;</div><div class="line">    observer.next(&apos;hi&apos;);</div><div class="line">  &#125;, 1000);</div><div class="line"></div><div class="line">  return function unsubscribe() &#123;</div><div class="line">    clearInterval(intervalID);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var unsubscribe = subscribe(&#123;next: (x) =&gt; console.log(x)&#125;);</div><div class="line"></div><div class="line">// 稍后：</div><div class="line">unsubscribe(); // 清理资源</div></pre></td></tr></table></figure>
<p>为什么我们要使用像 Observable、Observer 和 Subscription 这样的 Rx 类型？原因是保证代码的安全性(比如 Observable 规约)和操作符的可组合性。</p>
<h1 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer (观察者)"></a>Observer (观察者)</h1><p>什么是观察者？ - 观察者是由 Observable 发送的值的消费者。观察者只是一组回调函数的集合，每个回调函数对应一种 Observable 发送的通知类型：next、error 和 complete 。下面的示例是一个典型的观察者对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var observer = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;Observer got a complete notification&apos;),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>要使用观察者，需要把它提供给 Observable 的 subscribe 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<p><strong>观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable 发送的通知类型。</strong></p>
<p>RxJS 中的观察者也可能是部分的。如果你没有提供某个回调函数，Observable 的执行也会正常运行，只是某些通知类型会被忽略，因为观察者中没有没有相对应的回调函数。</p>
<p>下面的示例是没有 complete 回调函数的观察者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observer = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当订阅 Observable 时，你可能只提供了一个回调函数作为参数，而并没有将其附加到观察者对象上，例如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(x =&gt; console.log(&apos;Observer got a next value: &apos; + x));</div></pre></td></tr></table></figure>
<p>在 observable.subscribe 内部，它会创建一个观察者对象并使用第一个回调函数参数作为 next 的处理方法。所有三种类型的回调函数都可以直接作为参数来提供：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(</div><div class="line">  x =&gt; console.log(&apos;Observer got a next value: &apos; + x),</div><div class="line">  err =&gt; console.error(&apos;Observer got an error: &apos; + err),</div><div class="line">  () =&gt; console.log(&apos;Observer got a complete notification&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h1 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription (订阅)"></a>Subscription (订阅)</h1><p>什么是 Subscription ？ - Subscription 是表示可清理资源的对象，通常是 Observable 的执行。Subscription 有一个重要的方法，即 unsubscribe，它不需要任何参数，只是用来清理由 Subscription 占用的资源。在上一个版本的 RxJS 中，Subscription 叫做 “Disposable” (可清理对象)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.interval(1000);</div><div class="line">var subscription = observable.subscribe(x =&gt; console.log(x));</div><div class="line">// 稍后：</div><div class="line">// 这会取消正在进行中的 Observable 执行</div><div class="line">// Observable 执行是通过使用观察者调用 subscribe 方法启动的</div><div class="line">subscription.unsubscribe();</div></pre></td></tr></table></figure>
<p><strong>Subscription 基本上只有一个 unsubscribe() 函数，这个函数用来释放资源或去取消 Observable 执行。</strong><br>Subscription 还可以合在一起，这样一个 Subscription 调用 unsubscribe() 方法，可能会有多个 Subscription 取消订阅 。你可以通过把一个 Subscription 添加到另一个上面来做这件事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var observable1 = Rx.Observable.interval(400);</div><div class="line">var observable2 = Rx.Observable.interval(300);</div><div class="line"></div><div class="line">var subscription = observable1.subscribe(x =&gt; console.log(&apos;first: &apos; + x));</div><div class="line">var childSubscription = observable2.subscribe(x =&gt; console.log(&apos;second: &apos; + x));</div><div class="line"></div><div class="line">subscription.add(childSubscription);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  // subscription 和 childSubscription 都会取消订阅</div><div class="line">  subscription.unsubscribe();</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>执行上面的代码，将看到如下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">second: 0</div><div class="line">first: 0</div><div class="line">second: 1</div><div class="line">first: 1</div><div class="line">second: 2</div></pre></td></tr></table></figure>
<p>Subscriptions 还有一个 remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription 。</p>
<h2 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject (主体)"></a>Subject (主体)</h2><p>什么是 Subject？ - RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，而普通的 Observables 是单播的(每个已订阅的观察者都拥有 Observable 的独立执行)。</p>
<p><strong>Subject 像是 Observalbe，但是可以多播给多个观察者。Subject 还像是 EventEmitters，维护着多个监听器的注册表。</strong></p>
<p><strong>每个 Subject 都是 Observable。</strong>  - 对于 Subject，你可以提供一个观察者并使用 subscribe 方法，就可以开始正常接收值。从观察者的角度而言，它无法判断 Observable 执行是来自普通的 Observable 还是 Subject 。<br>在 Subject 的内部，subscribe 不会调用发送值的新执行。它只是将给定的观察者注册到观察者列表中，类似于其他库或语言中的 addListener 的工作方式。</p>
<p><strong>每个 Subject 都是观察者。</strong> - Subject 是一个有如下方法的对象： next(v)、error(e) 和 complete() 。要给 Subjetc 提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该 Subject 的观察者们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div></pre></td></tr></table></figure>
<p>下面是控制台的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div></pre></td></tr></table></figure>
<p>因为 Subject 是观察者，这也就在意味着你可以把 Subject 作为参数传给任何 Observable 的 subscribe 方法，如下面的示例所展示的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.Subject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var observable = Rx.Observable.from([1, 2, 3]);</div><div class="line"></div><div class="line">observable.subscribe(subject); // 你可以提供一个 Subject 进行订阅</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div><div class="line">observerA: 3</div><div class="line">observerB: 3</div></pre></td></tr></table></figure>
<h2 id="多播的-Observables"><a href="#多播的-Observables" class="headerlink" title="多播的 Observables"></a>多播的 Observables</h2><p>“多播 Observable” 通过 Subject 来发送通知，这个 Subject 可能有多个订阅者，然而普通的 “单播 Observable” 只发送通知给单个观察者。</p>
<p><strong>多播 Observable 在底层是通过使用 Subject 使得多个观察者可以看见同一个 Observable 执行。</strong></p>
<p>在底层，这就是 multicast 操作符的工作原理：观察者订阅一个基础的 Subject，然后 Subject 订阅源 Observable 。下面的示例与前面使用 observable.subscribe(subject) 的示例类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.from([1, 2, 3]);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var multicasted = source.multicast(subject);</div><div class="line"></div><div class="line">// 在底层使用了 `subject.subscribe(&#123;...&#125;)`:</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 在底层使用了 `source.subscribe(subject)`:</div><div class="line">multicasted.connect();</div></pre></td></tr></table></figure>
<p>multicast 操作符返回一个 Observable，它看起来和普通的 Observable 没什么区别，但当订阅时就像是 Subject 。multicast 返回的是 ConnectableObservable，它只是一个有 connect() 方法的 Observable 。</p>
<p>connect() 方法十分重要，它决定了何时启动共享的 Observable 执行。因为 connect() 方法在底层执行了 source.subscribe(subject)，所以它返回的是 Subscription，你可以取消订阅以取消共享的 Observable 执行。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>手动调用 connect() 并处理 Subscription 通常太笨重。通常，当第一个观察者到达时我们想要自动地连接，而当最后一个观察者取消订阅时我们想要自动地取消共享执行。</p>
<ol>
<li>第一个观察者订阅了多播 Observable</li>
<li>多播 Observable 已连接</li>
<li>next 值 0 发送给第一个观察者</li>
<li>第二个观察者订阅了多播 Observable</li>
<li>next 值 1 发送给第一个观察者</li>
<li>next 值 1 发送给第二个观察者</li>
<li>第一个观察者取消了多播 Observable 的订阅</li>
<li>next 值 2 发送给第二个观察者</li>
<li>第二个观察者取消了多播 Observable 的订阅</li>
<li>多播 Observable 的连接已中断(底层进行的操作是取消订阅)</li>
</ol>
<p>要实现这点，需要显式地调用 connect()，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(500);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var multicasted = source.multicast(subject);</div><div class="line">var subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">subscription1 = multicasted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line">// 这里我们应该调用 `connect()`，因为 `multicasted` 的第一个</div><div class="line">// 订阅者关心消费值</div><div class="line">subscriptionConnect = multicasted.connect();</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription2 = multicasted.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 600);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, 1200);</div><div class="line"></div><div class="line">// 这里我们应该取消共享的 Observable 执行的订阅，</div><div class="line">// 因为此后 `multicasted` 将不再有订阅者</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subscription2.unsubscribe();</div><div class="line">  subscriptionConnect.unsubscribe(); // 用于共享的 Observable 执行</div><div class="line">&#125;, 2000);</div></pre></td></tr></table></figure>
<p>如果不想显式调用 connect()，我们可以使用 ConnectableObservable 的 refCount() 方法(引用计数)，这个方法返回 Observable，这个 Observable 会追踪有多少个订阅者。当订阅者的数量从0变成1，它会调用 connect() 以开启共享的执行。当订阅者数量从1变成0时，它会完全取消订阅，停止进一步的执行。</p>
<p><strong>refCount 的作用是，当有第一个订阅者时，多播 Observable 会自动地启动执行，而当最后一个订阅者离开时，多播 Observable 会自动地停止执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var source = Rx.Observable.interval(500);</div><div class="line">var subject = new Rx.Subject();</div><div class="line">var refCounted = source.multicast(subject).refCount();</div><div class="line">var subscription1, subscription2, subscriptionConnect;</div><div class="line"></div><div class="line">// 这里其实调用了 `connect()`，</div><div class="line">// 因为 `refCounted` 有了第一个订阅者</div><div class="line">console.log(&apos;observerA subscribed&apos;);</div><div class="line">subscription1 = refCounted.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerB subscribed&apos;);</div><div class="line">  subscription2 = refCounted.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 600);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerA unsubscribed&apos;);</div><div class="line">  subscription1.unsubscribe();</div><div class="line">&#125;, 1200);</div><div class="line"></div><div class="line">// 这里共享的 Observable 执行会停止，</div><div class="line">// 因为此后 `refCounted` 将不再有订阅者</div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  console.log(&apos;observerB unsubscribed&apos;);</div><div class="line">  subscription2.unsubscribe();</div><div class="line">&#125;, 2000);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">observerA subscribed</div><div class="line">observerA: 0</div><div class="line">observerB subscribed</div><div class="line">observerA: 1</div><div class="line">observerB: 1</div><div class="line">observerA unsubscribed</div><div class="line">observerB: 2</div><div class="line">observerB unsubscribed</div></pre></td></tr></table></figure>
<p>refCount() 只存在于 ConnectableObservable，它返回的是 Observable，而不是另一个 ConnectableObservable 。</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>Subject 的其中一个变体就是 BehaviorSubject，它有一个“当前值”的概念。它保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”。</p>
<p><strong>BehaviorSubjects 适合用来表示“随时间推移的值”。举例来说，生日的流是一个 Subject，但年龄的流应该是一个 BehaviorSubject 。</strong></p>
<p>在下面的示例中，BehaviorSubject 使用值0进行初始化，当第一个观察者订阅时会得到0。第二个观察者订阅时会得到值2，尽管它是在值2发送之后订阅的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.BehaviorSubject(0); // 0是初始值</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(3);</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">observerA: 0</div><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerB: 2</div><div class="line">observerA: 3</div><div class="line">observerB: 3</div></pre></td></tr></table></figure>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>ReplaySubject 类似于 BehaviorSubject，它可以发送旧值给新的订阅者，但它还可以记录 Observable 执行的一部分。</p>
<p><strong>ReplaySubject 记录 Observable 执行中的多个值并将其回放给新的订阅者。</strong></p>
<p>当创建 ReplaySubject 时，你可以指定回放多少个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.ReplaySubject(3); // 为新的订阅者缓冲3个值</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerA: 3</div><div class="line">observerA: 4</div><div class="line">observerB: 2</div><div class="line">observerB: 3</div><div class="line">observerB: 4</div><div class="line">observerA: 5</div><div class="line">observerB: 5</div></pre></td></tr></table></figure>
<p>除了缓冲数量，你还可以指定 window time (以毫秒为单位)来确定多久之前的值可以记录。在下面的示例中，我们使用了较大的缓存数量100，但 window time 参数只设置了500毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.ReplaySubject(100, 500 /* windowTime */);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var i = 1;</div><div class="line">setInterval(() =&gt; subject.next(i++), 200);</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  subject.subscribe(&#123;</div><div class="line">    next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">  &#125;);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>从下面的输出可以看出，第二个观察者得到的值是3、4、5，这三个值是订阅发生前的500毫秒内发生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observerA: 1</div><div class="line">observerA: 2</div><div class="line">observerA: 3</div><div class="line">observerA: 4</div><div class="line">observerA: 5</div><div class="line">observerB: 3</div><div class="line">observerB: 4</div><div class="line">observerB: 5</div><div class="line">observerA: 6</div><div class="line">observerB: 6</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>AsyncSubject 是另一个 Subject 变体，只有当 Observable 执行完成时(执行 complete())，它才会将执行的最后一个值发送给观察者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var subject = new Rx.AsyncSubject();</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerA: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(1);</div><div class="line">subject.next(2);</div><div class="line">subject.next(3);</div><div class="line">subject.next(4);</div><div class="line"></div><div class="line">subject.subscribe(&#123;</div><div class="line">  next: (v) =&gt; console.log(&apos;observerB: &apos; + v)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">subject.next(5);</div><div class="line">subject.complete();</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">observerA: 5</div><div class="line">observerB: 5</div></pre></td></tr></table></figure>
<p>AsyncSubject 和 last() 操作符类似，因为它也是等待 complete 通知，以发送一个单个值。</p>
<h2 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators (操作符)"></a>Operators (操作符)</h2><p>尽管 RxJS 的根基是 Observable，但最有用的还是它的操作符。操作符是允许复杂的异步代码以声明式的方式进行轻松组合的基础代码单元。</p>
<h3 id="操作符？"><a href="#操作符？" class="headerlink" title="操作符？"></a>操作符？</h3><p>操作符是 Observable 类型上的方法，比如 .map(…)、.filter(…)、.merge(…)，等等。当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable 。</p>
<p><strong>操作符是函数，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。</strong></p>
<p>操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。订阅输出 Observalbe 同样会订阅输入 Observable 。在下面的示例中，我们创建一个自定义操作符函数，它将从输入 Observable 接收的每个值都乘以10：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function multiplyByTen(input) &#123;</div><div class="line">  var output = Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">    input.subscribe(&#123;</div><div class="line">      next: (v) =&gt; observer.next(10 * v),</div><div class="line">      error: (err) =&gt; observer.error(err),</div><div class="line">      complete: () =&gt; observer.complete()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  return output;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var input = Rx.Observable.from([1, 2, 3, 4]);</div><div class="line">var output = multiplyByTen(input);</div><div class="line">output.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">20</div><div class="line">30</div><div class="line">40</div></pre></td></tr></table></figure>
<p>注意，订阅 output 会导致 input Observable 也被订阅。我们称之为“操作符订阅链”。</p>
<h2 id="实例操作符-vs-静态操作符"><a href="#实例操作符-vs-静态操作符" class="headerlink" title="实例操作符 vs. 静态操作符"></a>实例操作符 vs. 静态操作符</h2><p>什么是实例操作符？ - 通常提到操作符时，我们指的是实例操作符，它是 Observable 实例上的方法。举例来说，如果上面的 multiplyByTen 是官方提供的实例操作符，它看起来大致是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Rx.Observable.prototype.multiplyByTen = function multiplyByTen() &#123;</div><div class="line">  var input = this;</div><div class="line">  return Rx.Observable.create(function subscribe(observer) &#123;</div><div class="line">    input.subscribe(&#123;</div><div class="line">      next: (v) =&gt; observer.next(10 * v),</div><div class="line">      error: (err) =&gt; observer.error(err),</div><div class="line">      complete: () =&gt; observer.complete()</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实例运算符是使用 this 关键字来指代输入的 Observable 的函数。</strong></p>
<p>注意，这里的 input Observable 不再是一个函数参数，它现在是 this 对象。下面是我们如何使用这样的实例运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.from([1, 2, 3, 4]).multiplyByTen();</div><div class="line">observable.subscribe(x =&gt; console.log(x));</div></pre></td></tr></table></figure>
<p>什么是静态操作符？ - 除了实例操作符，还有静态操作符，它们是直接附加到 Observable 类上的。静态操作符在内部不使用 this 关键字，而是完全依赖于它的参数。</p>
<p><strong>静态操作符是附加到 Observalbe 类上的纯函数，通常用来从头开始创建 Observalbe。</strong></p>
<p>最常用的静态操作符类型是所谓的创建操作符。它们只接收非 Observable 参数，比如数字，然后创建一个新的 Observable ，而不是将一个输入 Observable 转换为输出 Observable 。</p>
<p>一个典型的静态操作符例子就是 interval 函数。它接收一个数字(非 Observable)作为参数，并生产一个 Observable 作为输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.interval(1000 /* 毫秒数 */);</div></pre></td></tr></table></figure>
<p>创建操作符的另一个例子就是 create，已经在前面的示例中广泛使用。点击这里查看所有静态操作符列表。</p>
<p>然而，有些静态操作符可能不同于简单的创建。一些组合操作符可能是静态的，比如 merge、combineLatest、concat，等等。这些作为静态运算符是有道理的，因为它们将多个 Observables 作为输入，而不仅仅是一个，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var observable1 = Rx.Observable.interval(1000);</div><div class="line">var observable2 = Rx.Observable.interval(400);</div><div class="line"></div><div class="line">var merged = Rx.Observable.merge(observable1, observable2);</div></pre></td></tr></table></figure>
<h2 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler (调度器)"></a>Scheduler (调度器)</h2><p>什么是调度器？ - 调度器控制着何时启动 subscription 和何时发送通知。它由三部分组成：</p>
<ul>
<li>调度器是一种数据结构。 它知道如何根据优先级或其他标准来存储任务和将任务进行排序。</li>
<li>调度器是执行上下文。 它表示在何时何地执行任务(举例来说，立即的，或另一种回调函数机制(比如 setTimeout 或 process.nextTick)，或动画帧)。</li>
<li>调度器有一个(虚拟的)时钟。 调度器功能通过它的 getter 方法 now()<br>提供了“时间”的概念。在具体调度器上安排的任务将严格遵循该时钟所表示的时间。</li>
</ul>
<p><strong>调度器可以让你规定 Observable 在什么样的执行上下文中发送通知给它的观察者。</strong></p>
<p>在下面的示例中，我们采用普通的 Observable ，它同步地发出值1、2、3，并使用操作符 observeOn 来指定 async 调度器发送这些值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (observer) &#123;</div><div class="line">  observer.next(1);</div><div class="line">  observer.next(2);</div><div class="line">  observer.next(3);</div><div class="line">  observer.complete();</div><div class="line">&#125;)</div><div class="line">.observeOn(Rx.Scheduler.async);</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(&#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">just before subscribe</div><div class="line">just after subscribe</div><div class="line">got value 1</div><div class="line">got value 2</div><div class="line">got value 3</div><div class="line">done</div></pre></td></tr></table></figure>
<p>注意通知 got value… 在 just after subscribe 之后才发送，这与我们到目前为止所见的默认行为是不一样的。这是因为 observeOn(Rx.Scheduler.async) 在 Observable.create 和最终的观察者之间引入了一个代理观察者。在下面的示例代码中，我们重命名了一些标识符，使得其中的区别变得更明显：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var observable = Rx.Observable.create(function (proxyObserver) &#123;</div><div class="line">  proxyObserver.next(1);</div><div class="line">  proxyObserver.next(2);</div><div class="line">  proxyObserver.next(3);</div><div class="line">  proxyObserver.complete();</div><div class="line">&#125;)</div><div class="line">.observeOn(Rx.Scheduler.async);</div><div class="line"></div><div class="line">var finalObserver = &#123;</div><div class="line">  next: x =&gt; console.log(&apos;got value &apos; + x),</div><div class="line">  error: err =&gt; console.error(&apos;something wrong occurred: &apos; + err),</div><div class="line">  complete: () =&gt; console.log(&apos;done&apos;),</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(&apos;just before subscribe&apos;);</div><div class="line">observable.subscribe(finalObserver);</div><div class="line">console.log(&apos;just after subscribe&apos;);</div></pre></td></tr></table></figure>
<p>proxyObserver 是在 observeOn(Rx.Scheduler.async) 中创建的，它的 next(val) 函数大概是下面这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var proxyObserver = &#123;</div><div class="line">  next: (val) =&gt; &#123;</div><div class="line">    Rx.Scheduler.async.schedule(</div><div class="line">      (x) =&gt; finalObserver.next(x),</div><div class="line">      0 /* 延迟时间 */,</div><div class="line">      val /* 会作为上面函数所使用的 x */</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>async 调度器操作符使用了 setTimeout 或 setInterval，即使给定的延迟时间为0。照例，在 JavaScript 中，我们已知的是 setTimeout(fn, 0) 会在下一次事件循环迭代的最开始运行 fn 。这也解释了为什么发送给 finalObserver 的 got value 1 发生在 just after subscribe 之后。</p>
<p>调度器的 schedule() 方法接收一个 delay 参数，它指的是相对于调度器内部时钟的一段时间。调度器的时钟不需要与实际的挂钟时间有任何关系。这也就是为什么像 delay 这样的时间操作符不是在实际时间上操作的，而是取决于调度器的时钟时间。这在测试中极其有用，可以使用虚拟时间调度器来伪造挂钟时间，同时实际上是在同步执行计划任务。</p>
<h3 id="调度器类型"><a href="#调度器类型" class="headerlink" title="调度器类型"></a>调度器类型</h3><p>async 调度器是 RxJS 提供的内置调度器中的一个。可以通过使用 Scheduler 对象的静态属性创建并返回其中的每种类型的调度器。</p>
<table><br>        <tr><br>            <th>调度器</th><br>            <th>目的</th><br>        </tr><br>         <tr><br>            <th>null</th><br>            <th>不传递任何调度器的话，会以同步递归的方式发送通知，用于定时操作或尾递归操作。</th><br>        </tr><br>         <tr><br>            <th>Rx.Scheduler.queue</th><br>            <th>当前事件帧中的队列调度(蹦床调度器)，用于迭代操作。</th><br>        </tr><br>        <tr><br>            <th>Rx.Scheduler.asap</th><br>            <th>    微任务的队列调度，它使用可用的最快速的传输机制，比如 Node.js 的 process.nextTick() 或 Web Worker 的 MessageChannel 或 setTimeout 或其他。用于异步转换。</th><br>        </tr><br>        <tr><br>            <th>Rx.Scheduler.async</th><br>            <th>使用 setInterval 的调度。用于基于时间的操作符。</th><br>        </tr><br></table>

<h3 id="使用调度器"><a href="#使用调度器" class="headerlink" title="使用调度器"></a>使用调度器</h3><p>你可能在你的 RxJS 代码中已经使用过调度器了，只是没有明确地指明要使用的调度器的类型。这是因为所有的 Observable 操作符处理并发性都有可选的调度器。如果没有提供调度器的话，RxJS 会通过使用最小并发原则选择一个默认调度器。这意味着引入满足操作符需要的最小并发量的调度器会被选择。例如，对于返回有限和少量消息的 observable 的操作符，RxJS 不使用调度器，即 null 或 undefined 。对于返回潜在大量的或无限数量的消息的操作符，使用 queue 调度器。对于使用定时器的操作符，使用 aysnc 调度器。</p>
<p>因为 RxJS 使用最少的并发调度器，如果出于性能考虑，你想要引入并发，那么可以选择不同的调度器。要指定具体的调度器，可以使用那些采用调度器的操作符方法，例如 from([10, 20, 30], Rx.Scheduler.async) 。</p>
<p>静态创建操作符通常可以接收调度器作为参数。 举例来说，from(array, scheduler) 可以让你指定调度器，当发送从 array 转换的每个通知的时候使用。调度器通常作为操作符的最后一个参数。下面的静态创建操作符接收调度器参数：</p>
<ul>
<li>bindCallback</li>
<li>bindNodeCallback</li>
<li>combineLatest</li>
<li>concat</li>
<li>empty</li>
<li>from</li>
<li>fromPromise</li>
<li>interval</li>
<li>merge</li>
<li>of</li>
<li>range</li>
<li>throw</li>
<li>timer</li>
</ul>
<p>使用 subscribeOn 来调度 subscribe() 调用在什么样的上下文中执行。 默认情况下，Observable 的 subscribe() 调用会立即同步地执行。然而，你可能会延迟或安排在给定的调度器上执行实际的 subscription ，使用实例操作符 subscribeOn(scheduler)，其中 scheduler 是你提供的参数。<br>使用 observeOn 来调度发送通知的的上下文。 正如我们在上面的示例中所看到的，实例操作符 observeOn(scheduler) 在源 Observable 和目标观察者之间引入了一个中介观察者，中介负责调度，它使用给定的 scheduler 来调用目标观察者。</p>
<p>实例操作符可能会接收调度器作为参数。</p>
<p>像 bufferTime、debounceTime、delay、auditTime、sampleTime、throttleTime、timeInterval、timeout、timeoutWith、windowTime 这样时间相关的操作符全部接收调度器作为最后的参数，并且默认的操作是在 Rx.Scheduler.async 调度器上。</p>
<p>其他接收调度器作为参数的实例操作符：cache、combineLatest、concat、expand、merge、publishReplay、startWith。</p>
<p><strong>注意：</strong>cache 和 publishReplay 都接收调度器是因为它们使用了 ReplaySubject 。ReplaySubjects 的构造函数接收一个可选的调度器作为最后的参数，因为 ReplaySubject 可能会处理时间，这只在调度器的上下文中才有意义。默认情况下，ReplaySubject 使用 queue 调度器来提供时钟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两年，各种异步编程框架，上面RxJava,RxAndroid,RxSwift等等，今天要聊的是RxJs，对于我等入门不久的前端工程师来说，这个框架还是比较有新颖的，中文官网地址：&lt;a href=&quot;http://cn.rx.js.org/&quot; target=&quot;_blank&quot; 
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>将Kotlin代码编译成Javascript 代码</title>
    <link href="http://www.xiangzhihong.com/2017/10/22/%E5%B0%86Kotlin%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E6%88%90Javascript%20%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.xiangzhihong.com/2017/10/22/将Kotlin代码编译成Javascript 代码/</id>
    <published>2017-10-21T16:00:00.000Z</published>
    <updated>2018-02-11T03:27:28.959Z</updated>
    
    <content type="html"><![CDATA[<p>在Kotlin和Javascript平台的互操作过程中，往往会涉及Kotlin代码和 Javascript 代码相互转换的过程，本文主要介绍如何将Kotlin代码编译成Javascript 代码。</p>
<h2 id="1，创建JavaScript的应用程序"><a href="#1，创建JavaScript的应用程序" class="headerlink" title="1，创建JavaScript的应用程序"></a>1，创建JavaScript的应用程序</h2><p>首先创建一个新的应用程序或目标JavaScript模块时，并需要选择Kotlin - JavaScript作为编译运行目标。<br><img src="http://img.blog.csdn.net/20180209150539778" alt="这里写图片描述"></p>
<p>默认情况下，插件选择与当前安装版本关联的插件。除非我们要创建一个不同的项目，否则我们可以在输入项目名称和位置后点击Finish。<br><img src="http://img.blog.csdn.net/20180209150607704" alt="这里写图片描述"></p>
<p>项目创建完成后，项目结构如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180209151011292" alt="这里写图片描述"></p>
<h2 id="2，新建项目"><a href="#2，新建项目" class="headerlink" title="2，新建项目"></a>2，新建项目</h2><p>接下来，可以开始编写Kotlin代码。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val message = &quot;Hello JavaScript!&quot;</div><div class="line">    println(message)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在需要一个HTML页面来加载代码，所以我们创建一个名为index.html的文件。</p>
<h2 id="编译输出代码说明"><a href="#编译输出代码说明" class="headerlink" title="编译输出代码说明"></a>编译输出代码说明</h2><p>将 Kotlin 代码编译为 Javascript 代码后会得到两个主要的文件：</p>
<ul>
<li>Kotlin.js. ：运行时和标准库，这部分代码只与 Kotlin 的版本有关而不会因为不同的应用而有所不同。</li>
<li>{module}.js：真正的应用代码，所有的应用代码最终都会编译成一个 JavaScript 文件并与模块的名字同名。</li>
</ul>
<p>除此之外，每一个源码文件都会有一个关联的 {file}.meta.js 元文件，该文件可用来做反射或是其他的功能。Kotlin 编译器将会输出如下代码：<br><img src="http://img.blog.csdn.net/20180209162547125" alt="这里写图片描述"></p>
<p>而大家最关心的莫过于ConsoleOutput.js，该文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var ConsoleOutput = function (Kotlin) &#123;</div><div class="line">  &apos;use strict&apos;;</div><div class="line">var _ = Kotlin.defineRootPackage(null, /** @lends _ */ &#123;</div><div class="line">    main_kand9s$: function (args) &#123;</div><div class="line">      Kotlin.println(&apos;Hello JavaScript!&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  Kotlin.defineModule(&apos;ConsoleOutput&apos;, _);</div><div class="line">  _.main_kand9s$([]);</div><div class="line">return _;</div><div class="line">&#125;(kotlin);</div></pre></td></tr></table></figure>
<p>如上代码就是 kotlin main 函数编译后得到的代码，我们可以看到编译后的代码定义了一个函数并赋值给了一个与模块名同名的变量，然后通过传入的 Kotlin 变量来调用 define  rootPackage 函数。通过 Kotlin 变量我们可以使用 kotlin.js 标准库中的方法。</p>
<p>编译前的代码只有一个 main 函数，编译之后该函数被添加了后缀，这么做的目的主要是为了防止重载 Kotlin 中的代码，Kotlin 中的这部分功能是为了将源码转换成对应的 javascript 代码。</p>
<p>最后定义为一个立即执行函数，当这部分代码加载之后就会立即执行，并将 Kotlin 做为参数传进去，这样就可以使用 Kotlin.js 中定义的方法了。</p>
<h2 id="运行编译后的代码"><a href="#运行编译后的代码" class="headerlink" title="运行编译后的代码"></a>运行编译后的代码</h2><p>这部分代码的目的是为了通过 console 输出文本，在这里我们需要通过 HTML 页面加载并在浏览器中运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">&lt;title&gt;Console Output&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;out/production/ConsoleOutput/lib/kotlin.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;out/production/ConsoleOutput/ConsoleOutput.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>注：我们需要先加载 kotlin.js 文件，再加载我们的应用文件。</strong></p>
<p><img src="http://img.blog.csdn.net/20180209162800453" alt="这里写图片描述"></p>
<h2 id="调试应用程序"><a href="#调试应用程序" class="headerlink" title="调试应用程序"></a>调试应用程序</h2><p>为了使用IntelliJ IDEA调试应用程序，我们需要执行两个步骤：</p>
<ul>
<li>安装JetBrains Chrome扩展，它允许通过Chrome在IntelliJ IDEA中进行调试。这对于用IntelliJ IDEA开发的任何类型的Web应用程序都很有用，而不仅仅是Kotlin；</li>
<li>配置Kotlin编译器生成源地图，可通过 Preferences|Kotlin Compiler。<br><img src="http://img.blog.csdn.net/20180209162941236" alt="这里写图片描述"><br>一旦完成，我们只需右键单击我们的index.html文件，然后选择调试选项。这将启动Chrome，然后在IntelliJ IDEA中的代码中定义的断点处停止，我们可以在其中评估表达式，逐步执行代码等。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20180209163123149" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180209163149634" alt="这里写图片描述"></p>
<p>也可以使用标准的Chrome调试器来调试Kotlin应用程序，只要确保你生成源地图。</p>
<h3 id="配置编译器选项"><a href="#配置编译器选项" class="headerlink" title="配置编译器选项"></a>配置编译器选项</h3><p>Kotlin提供了一系列可在IntelliJ IDEA中访问的编译器选项。常见的如下：</p>
<ul>
<li><strong>输出文件前缀</strong>。我们可以在编译器生成的输出前加上额外的JavaScript。为了做到这一点，我们在这个框中指出了包含我们想要的JavaScript的文件的名字。</li>
<li><strong>输出文件后缀</strong>。同上，但在这种情况下，编译器会将所选文件的内容追加到输出中。</li>
<li><strong>复制运行时库文件</strong>。指示我们希望将该kotlin.js库输出到哪个子文件夹中。默认情况下，lib这就是为什么在HTML中我们引用这个路径。</li>
<li><strong>模块种类</strong>。指示要遵循的模块标准。这在“ 使用模块”教程中有更深入的介绍。</li>
</ul>
<p>附：<a href="http://kotlinlang.org/docs/tutorials/javascript/getting-started-idea/getting-started-with-intellij-idea.html" target="_blank" rel="external">http://kotlinlang.org/docs/tutorials/javascript/getting-started-idea/getting-started-with-intellij-idea.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Kotlin和Javascript平台的互操作过程中，往往会涉及Kotlin代码和 Javascript 代码相互转换的过程，本文主要介绍如何将Kotlin代码编译成Javascript 代码。&lt;/p&gt;
&lt;h2 id=&quot;1，创建JavaScript的应用程序&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>腾讯前端面试题集锦</title>
    <link href="http://www.xiangzhihong.com/2017/10/16/%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://www.xiangzhihong.com/2017/10/16/腾讯前端面试题集锦/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-11-20T02:22:27.696Z</updated>
    
    <content type="html"><![CDATA[<p>想要进入腾讯，首先会进行一些基础知识的考核，这些基础及时包括数据结构、算法、数据库、安全等方面，最后是关于性格和项目经验的问题。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>prototype和<strong>proto</strong>的关系是什么</li>
<li>meta viewport原理</li>
<li>域名收敛是什么</li>
<li>float和display：inline-block；的区别</li>
<li>前端优化策略列举</li>
<li>首屏、白屏时间如何计算</li>
<li>闭包</li>
<li>作用域链</li>
<li>ajax如何实现、readyState五中状态的含义</li>
<li>jsonp如何实现</li>
<li>怎么处理跨域</li>
<li>restful的method解释</li>
<li>get和post的区别</li>
<li>事件模型解释</li>
<li>编写一个元素拖拽的插件</li>
<li>编写一个contextmenu的插件</li>
<li>编写web端cookie的设置和获取方法</li>
<li>兼容ie６的水平垂直居中</li>
<li>兼容ie的事件封装</li>
<li>h5和原生android的优缺点</li>
<li>编写h5需要注意什么</li>
<li>xss和crsf的原理以及怎么预防</li>
<li>css优先级</li>
<li>如何实现点击radio的文字描述控制radio的状态（通过label实现）</li>
<li>delegate如何实现</li>
<li>jsonp有什么安全问题？为什么有这些安全问题？</li>
<li>单链表和双向链表的区别？</li>
<li>有用过reactjs？简单说一下其生命周期方法</li>
</ol>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>如何了解这些前端的框架？如angular，react，vue。</p>
<h3 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h3><ol>
<li>angular的directive怎么写</li>
<li>angular的脏检查（双向绑定）是如何实现的</li>
<li>依赖注入如何实现</li>
<li>scope如何实现</li>
<li>$parse模块如何实现（主要自己写了一个类似的库）</li>
</ol>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ol>
<li>react在setState后发生了什么，请结合源码说说你的理解。</li>
<li>flux解释。</li>
<li>说说你对React框架的理解。</li>
</ol>
<h3 id="requirejs"><a href="#requirejs" class="headerlink" title="requirejs"></a>requirejs</h3><ol>
<li>amd和cmd区别，怎么了解到这些区别的，是否是去看了规范。</li>
<li>requirejs那些经常用的方法，然后对其进行解释。</li>
</ol>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ol>
<li>Buffer模块是干什么的。</li>
<li>Stream是什么，使用的两种模式。</li>
<li>http模块如何将异步处理方式实现成同步处理方式。</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol>
<li>utf8和gbk的区别。</li>
<li>知道页面上某个点的坐标，如何获取该坐标上的所有元素。</li>
<li>angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）。</li>
<li>7点15分小于180度的夹角是多少。</li>
<li>如何实现大数相加。</li>
<li>给５升和６升的水杯如何倒出３升的水。</li>
<li>一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少。</li>
<li>前端异常监测如何实现。</li>
<li>直播点赞按钮的冒泡功能如何实现。</li>
<li>js的uglify如何实现。</li>
</ol>
<h3 id="优化方面"><a href="#优化方面" class="headerlink" title="优化方面"></a>优化方面</h3><ol>
<li>前端工程化方面做了哪些东西，怎么做。</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>什么二叉树，从一堆大数中选出满足条件的数要求最快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要进入腾讯，首先会进行一些基础知识的考核，这些基础及时包括数据结构、算法、数据库、安全等方面，最后是关于性格和项目经验的问题。&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础
    
    </summary>
    
      <category term="前端" scheme="http://www.xiangzhihong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://www.xiangzhihong.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前缀、中缀、后缀表达式</title>
    <link href="http://www.xiangzhihong.com/2017/10/12/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.xiangzhihong.com/2017/10/12/前缀、中缀、后缀表达式/</id>
    <published>2017-10-11T16:00:00.000Z</published>
    <updated>2018-02-11T03:26:27.954Z</updated>
    
    <content type="html"><![CDATA[<p>在函数式编程语言中，为了表示方便，出现了一些新的语法格式。所谓前缀、中缀、后缀表达式，它们之间的区别在于运算符相对与操作数的位置不同，为了说明它们的概念，首先来看一下中缀表达式。</p>
<p>所谓中缀表达式，就是将函数名放到两个操作数中间的表达式，其中，左侧的操作数代表函数对象或值，右侧的操作数代表函数的参数值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(3 + 4) × 5 - 6 就是中缀表达式</div><div class="line">- × + 3 4 5 6 前缀表达式</div><div class="line">3 4 + 5 × 6 - 后缀表达式</div></pre></td></tr></table></figure>
<h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><p>前缀表达式又称为前缀记法、波兰式，主要用于表示运算符位于操作数之前的表达式。</p>
<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p>中缀表达式又称为中缀记法，操作符以中缀形式处于操作数的中间。</p>
<p>中缀表达式是人们常用的算术表示方法，虽然人的大脑很容易理解与分析中缀表达式，但对计算机来说中缀表达式却是很复杂的，因此计算表达式的值时，通常需要先将中缀表达式转换为前缀或后缀表达式，然后再进行求值。对计算机来说，计算前缀或后缀表达式的值非常简单。</p>
<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>后缀表达式又称为后缀记法、逆波兰式，后缀表达式与前缀表达式类似，只是运算符位于操作数之后。</p>
<h2 id="前缀表达式求值"><a href="#前缀表达式求值" class="headerlink" title="前缀表达式求值"></a>前缀表达式求值</h2><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。</p>
<p>例如前缀表达式“- × + 3 4 5 6”计算的步骤如下：<br>(1) 从右至左扫描，将6、5、4、3压入堆栈；<br>(2) 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈；<br>(3) 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈；<br>(4) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。<br>可以看出，用计算机计算前缀表达式的值是很容易的。</p>
<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><p>与前缀表达式类似，只是顺序是从左至右：<br>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。</p>
<p>例如后缀表达式“3 4 + 5 × 6 -”的计算步骤如下：<br>(1) 从左至右扫描，将3和4压入堆栈；<br>(2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；<br>(3) 将5入栈；<br>(4) 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；<br>(5) 将6入栈；<br>(6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</p>
<h1 id="前缀、中缀、后缀表达式相互转换"><a href="#前缀、中缀、后缀表达式相互转换" class="headerlink" title="前缀、中缀、后缀表达式相互转换"></a>前缀、中缀、后缀表达式相互转换</h1><h3 id="将中缀表达式转换为前缀表达式"><a href="#将中缀表达式转换为前缀表达式" class="headerlink" title="将中缀表达式转换为前缀表达式"></a>将中缀表达式转换为前缀表达式</h3><p>遵循以下步骤：<br>(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；<br>(2) 从右至左扫描中缀表达式；<br>(3) 遇到操作数时，将其压入S2；<br>(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：<br>(4-1) 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；<br>(4-2) 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；<br>(4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；<br>(5) 遇到括号时：<br>(5-1) 如果是右括号“)”，则直接压入S1；<br>(5-2) 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；<br>(6) 重复步骤(2)至(5)，直到表达式的最左边；<br>(7) 将S1中剩余的运算符依次弹出并压入S2；<br>(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。</p>
<h3 id="将中缀表达式转换为后缀表达式"><a href="#将中缀表达式转换为后缀表达式" class="headerlink" title="将中缀表达式转换为后缀表达式"></a>将中缀表达式转换为后缀表达式</h3><p>与转换为前缀表达式相似，遵循以下步骤：<br>(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；<br>(2) 从左至右扫描中缀表达式；<br>(3) 遇到操作数时，将其压入S2；<br>(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：<br>(4-1) 如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br>(4-2) 否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；<br>(4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；<br>(5) 遇到括号时：<br>(5-1) 如果是左括号“(”，则直接压入S1；<br>(5-2) 如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；<br>(6) 重复步骤(2)至(5)，直到表达式的最右边；<br>(7) 将S1中剩余的运算符依次弹出并压入S2；<br>(8) 依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div></pre></td><td class="code"><pre><div class="line">package com.xzh;</div><div class="line"></div><div class="line">import java.util.Scanner;</div><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Demo &#123;</div><div class="line">    public static final String USAGE = &quot;== usage ==\n&quot;</div><div class="line">            + &quot;input the expressions, and then the program &quot;</div><div class="line">            + &quot;will calculate them and show the result.\n&quot;</div><div class="line">            + &quot;input &apos;bye&apos; to exit.\n&quot;;</div><div class="line">   </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(USAGE);</div><div class="line">        Scanner scanner = new Scanner(System.in);</div><div class="line">        String input = &quot;&quot;;</div><div class="line">        final String CLOSE_MARK = &quot;bye&quot;;</div><div class="line">        System.out.println(&quot;input an expression:&quot;);</div><div class="line">        input = scanner.nextLine();</div><div class="line">        while (input.length() != 0</div><div class="line">                &amp;&amp; !CLOSE_MARK.equals((input))) &#123;</div><div class="line">            System.out.print(&quot;Polish Notation (PN):&quot;);</div><div class="line">            try &#123;</div><div class="line">                toPolishNotation(input);</div><div class="line">            &#125; catch (NumberFormatException e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error, not a number.&quot;);</div><div class="line">            &#125; catch (IllegalArgumentException e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error:&quot; + e.getMessage());</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error, invalid expression.&quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.print(&quot;Reverse Polish Notation (RPN):&quot;);</div><div class="line">            try &#123;</div><div class="line">                toReversePolishNotation(input);</div><div class="line">            &#125; catch (NumberFormatException e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error, not a number.&quot;);</div><div class="line">            &#125; catch (IllegalArgumentException e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error:&quot; + e.getMessage());</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                System.out.println(&quot;\ninput error, invalid expression.&quot;);</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;input a new expression:&quot;);</div><div class="line">            input = scanner.nextLine();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;program exits&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * parse the expression , and calculate it.</div><div class="line">     * @param input</div><div class="line">     * @throws IllegalArgumentException</div><div class="line">     * @throws NumberFormatException</div><div class="line">     */</div><div class="line">    private static void toPolishNotation(String input)</div><div class="line">            throws IllegalArgumentException, NumberFormatException &#123;</div><div class="line">        int len = input.length();</div><div class="line">        char c, tempChar;</div><div class="line">        Stack&lt;Character&gt; s1 = new Stack&lt;Character&gt;();</div><div class="line">        Stack&lt;Double&gt; s2 = new Stack&lt;Double&gt;();</div><div class="line">        Stack&lt;Object&gt; expression = new Stack&lt;Object&gt;();</div><div class="line">        double number;</div><div class="line">        int lastIndex = -1;</div><div class="line">        for (int i=len-1; i&gt;=0; --i) &#123;</div><div class="line">            c = input.charAt(i);</div><div class="line">            if (Character.isDigit(c)) &#123;</div><div class="line">                lastIndex = readDoubleReverse(input, i);</div><div class="line">                number = Double.parseDouble(input.substring(lastIndex, i+1));</div><div class="line">                s2.push(number);</div><div class="line">                i = lastIndex;</div><div class="line">                if ((int) number == number)</div><div class="line">                    expression.push((int) number);</div><div class="line">                else</div><div class="line">                    expression.push(number);</div><div class="line">            &#125; else if (isOperator(c)) &#123;</div><div class="line">                while (!s1.isEmpty()</div><div class="line">                        &amp;&amp; s1.peek() != &apos;)&apos;</div><div class="line">                        &amp;&amp; priorityCompare(c, s1.peek()) &lt; 0) &#123;</div><div class="line">                    expression.push(s1.peek());</div><div class="line">                    s2.push(calc(s2.pop(), s2.pop(), s1.pop()));</div><div class="line">                &#125;</div><div class="line">                s1.push(c);</div><div class="line">            &#125; else if (c == &apos;)&apos;) &#123;</div><div class="line">                s1.push(c);</div><div class="line">            &#125; else if (c == &apos;(&apos;) &#123;</div><div class="line">                while ((tempChar=s1.pop()) != &apos;)&apos;) &#123;</div><div class="line">                    expression.push(tempChar);</div><div class="line">                    s2.push(calc(s2.pop(), s2.pop(), tempChar));</div><div class="line">                    if (s1.isEmpty()) &#123;</div><div class="line">                        throw new IllegalArgumentException(</div><div class="line">                                &quot;bracket dosen&apos;t match, missing right bracket &apos;)&apos;.&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else if (c == &apos; &apos;) &#123;</div><div class="line">                // ignore</div><div class="line">            &#125; else &#123;</div><div class="line">                throw new IllegalArgumentException(</div><div class="line">                        &quot;wrong character &apos;&quot; + c + &quot;&apos;&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while (!s1.isEmpty()) &#123;</div><div class="line">            tempChar = s1.pop();</div><div class="line">            expression.push(tempChar);</div><div class="line">            s2.push(calc(s2.pop(), s2.pop(), tempChar));</div><div class="line">        &#125;</div><div class="line">        while (!expression.isEmpty()) &#123;</div><div class="line">            System.out.print(expression.pop() + &quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        double result = s2.pop();</div><div class="line">        if (!s2.isEmpty())</div><div class="line">            throw new IllegalArgumentException(&quot;input is a wrong expression.&quot;);</div><div class="line">        System.out.println();</div><div class="line">        if ((int) result == result)</div><div class="line">            System.out.println(&quot;the result is &quot; + (int) result);</div><div class="line">        else</div><div class="line">            System.out.println(&quot;the result is &quot; + result);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * parse the expression, and calculate it.</div><div class="line">     * @param input</div><div class="line">     * @throws IllegalArgumentException</div><div class="line">     * @throws NumberFormatException</div><div class="line">     */</div><div class="line">    private static void toReversePolishNotation(String input)</div><div class="line">            throws IllegalArgumentException, NumberFormatException &#123;</div><div class="line">        int len = input.length();</div><div class="line">        char c, tempChar;</div><div class="line">        Stack&lt;Character&gt; s1 = new Stack&lt;Character&gt;();</div><div class="line">        Stack&lt;Double&gt; s2 = new Stack&lt;Double&gt;();</div><div class="line">        double number;</div><div class="line">        int lastIndex = -1;</div><div class="line">        for (int i=0; i&lt;len; ++i) &#123;</div><div class="line">            c = input.charAt(i);</div><div class="line">            if (Character.isDigit(c) || c == &apos;.&apos;) &#123;</div><div class="line">                lastIndex = readDouble(input, i);</div><div class="line">                number = Double.parseDouble(input.substring(i, lastIndex));</div><div class="line">                s2.push(number);</div><div class="line">                i = lastIndex - 1;</div><div class="line">                if ((int) number == number)</div><div class="line">                    System.out.print((int) number + &quot; &quot;);</div><div class="line">                else</div><div class="line">                    System.out.print(number + &quot; &quot;);</div><div class="line">            &#125; else if (isOperator(c)) &#123;</div><div class="line">                while (!s1.isEmpty()</div><div class="line">                        &amp;&amp; s1.peek() != &apos;(&apos;</div><div class="line">                        &amp;&amp; priorityCompare(c, s1.peek()) &lt;= 0) &#123;</div><div class="line">                    System.out.print(s1.peek() + &quot; &quot;);</div><div class="line">                    double num1 = s2.pop();</div><div class="line">                    double num2 = s2.pop();</div><div class="line">                    s2.push(calc(num2, num1, s1.pop()));</div><div class="line">                &#125;</div><div class="line">                s1.push(c);</div><div class="line">            &#125; else if (c == &apos;(&apos;) &#123;</div><div class="line">                s1.push(c);</div><div class="line">            &#125; else if (c == &apos;)&apos;) &#123;</div><div class="line">                while ((tempChar=s1.pop()) != &apos;(&apos;) &#123;</div><div class="line">                    System.out.print(tempChar + &quot; &quot;);</div><div class="line">                    double num1 = s2.pop();</div><div class="line">                    double num2 = s2.pop();</div><div class="line">                    s2.push(calc(num2, num1, tempChar));</div><div class="line">                    if (s1.isEmpty()) &#123;</div><div class="line">                        throw new IllegalArgumentException(</div><div class="line">                                &quot;bracket dosen&apos;t match, missing left bracket &apos;(&apos;.&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else if (c == &apos; &apos;) &#123;</div><div class="line">                // ignore</div><div class="line">            &#125; else &#123;</div><div class="line">                throw new IllegalArgumentException(</div><div class="line">                        &quot;wrong character &apos;&quot; + c + &quot;&apos;&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        while (!s1.isEmpty()) &#123;</div><div class="line">            tempChar = s1.pop();</div><div class="line">            System.out.print(tempChar + &quot; &quot;);</div><div class="line">            double num1 = s2.pop();</div><div class="line">            double num2 = s2.pop();</div><div class="line">            s2.push(calc(num2, num1, tempChar));</div><div class="line">        &#125;</div><div class="line">        double result = s2.pop();</div><div class="line">        if (!s2.isEmpty())</div><div class="line">            throw new IllegalArgumentException(&quot;input is a wrong expression.&quot;);</div><div class="line">        System.out.println();</div><div class="line">        if ((int) result == result)</div><div class="line">            System.out.println(&quot;the result is &quot; + (int) result);</div><div class="line">        else</div><div class="line">            System.out.println(&quot;the result is &quot; + result);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * calculate the two number with the operation.</div><div class="line">     * @param num1</div><div class="line">     * @param num2</div><div class="line">     * @param op</div><div class="line">     * @return</div><div class="line">     * @throws IllegalArgumentException</div><div class="line">     */</div><div class="line">    private static double calc(double num1, double num2, char op)</div><div class="line">            throws IllegalArgumentException &#123;</div><div class="line">        switch (op) &#123;</div><div class="line">            case &apos;+&apos;:</div><div class="line">                return num1 + num2;</div><div class="line">            case &apos;-&apos;:</div><div class="line">                return num1 - num2;</div><div class="line">            case &apos;*&apos;:</div><div class="line">                return num1 * num2;</div><div class="line">            case &apos;/&apos;:</div><div class="line">                if (num2 == 0) throw new IllegalArgumentException(&quot;divisor can&apos;t be 0.&quot;);</div><div class="line">                return num1 / num2;</div><div class="line">            default:</div><div class="line">                return 0; // will never catch up here</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static int priorityCompare(char op1, char op2) &#123;</div><div class="line">        switch (op1) &#123;</div><div class="line">            case &apos;+&apos;: case &apos;-&apos;:</div><div class="line">                return (op2 == &apos;*&apos; || op2 == &apos;/&apos; ? -1 : 0);</div><div class="line">            case &apos;*&apos;: case &apos;/&apos;:</div><div class="line">                return (op2 == &apos;+&apos; || op2 == &apos;-&apos; ? 1 : 0);</div><div class="line">        &#125;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * read the next number (reverse)</div><div class="line">     * @param input</div><div class="line">     * @param start</div><div class="line">     * @return</div><div class="line">     * @throws IllegalArgumentException</div><div class="line">     */</div><div class="line">    private static int readDoubleReverse(String input, int start)</div><div class="line">            throws IllegalArgumentException &#123;</div><div class="line">        int dotIndex = -1;</div><div class="line">        char c;</div><div class="line">        for (int i=start; i&gt;=0; --i) &#123;</div><div class="line">            c = input.charAt(i);</div><div class="line">            if (c == &apos;.&apos;) &#123;</div><div class="line">                if (dotIndex != -1)</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                            &quot;there have more than 1 dots in the number.&quot;);</div><div class="line">                else</div><div class="line">                    dotIndex = i;</div><div class="line">            &#125; else if (!Character.isDigit(c)) &#123;</div><div class="line">                return i + 1;</div><div class="line">            &#125; else if (i == 0) &#123;</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        throw new IllegalArgumentException(&quot;not a number.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * read the next number</div><div class="line">     * @param input</div><div class="line">     * @param start</div><div class="line">     * @return</div><div class="line">     * @throws IllegalArgumentException</div><div class="line">     */</div><div class="line">    private static int readDouble(String input, int start)</div><div class="line">            throws IllegalArgumentException &#123;</div><div class="line">        int len = input.length();</div><div class="line">        int dotIndex = -1;</div><div class="line">        char c;</div><div class="line">        for (int i=start; i&lt;len; ++i) &#123;</div><div class="line">            c = input.charAt(i);</div><div class="line">            if (c == &apos;.&apos;) &#123;</div><div class="line">                if (dotIndex != -1)</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                            &quot;there have more than 1 dots in the number.&quot;);</div><div class="line">                else if (i == len - 1)</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                            &quot;not a number, dot can&apos;t be the last part of a number.&quot;);</div><div class="line">                else</div><div class="line">                    dotIndex = i;</div><div class="line">            &#125; else if (!Character.isDigit(c)) &#123;</div><div class="line">                if (dotIndex == -1 || i - dotIndex &gt; 1)</div><div class="line">                    return i;</div><div class="line">                else</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                            &quot;not a number, dot can&apos;t be the last part of a number.&quot;);</div><div class="line">            &#125; else if (i == len - 1) &#123;</div><div class="line">                return len;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        throw new IllegalArgumentException(&quot;not a number.&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * return true if the character is an operator.</div><div class="line">     * @param c</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private static boolean isOperator(char c) &#123;</div><div class="line">        return (c==&apos;+&apos; || c==&apos;-&apos; || c==&apos;*&apos; || c==&apos;/&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在函数式编程语言中，为了表示方便，出现了一些新的语法格式。所谓前缀、中缀、后缀表达式，它们之间的区别在于运算符相对与操作数的位置不同，为了说明它们的概念，首先来看一下中缀表达式。&lt;/p&gt;
&lt;p&gt;所谓中缀表达式，就是将函数名放到两个操作数中间的表达式，其中，左侧的操作数代表函
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>一个ClassLoader引起的JNI链接错误</title>
    <link href="http://www.xiangzhihong.com/2017/10/09/%E4%B8%80%E4%B8%AAClassLoader%E5%BC%95%E8%B5%B7%E7%9A%84JNI%E9%93%BE%E6%8E%A5%E9%94%99%E8%AF%AF/"/>
    <id>http://www.xiangzhihong.com/2017/10/09/一个ClassLoader引起的JNI链接错误/</id>
    <published>2017-10-08T16:00:00.000Z</published>
    <updated>2017-11-20T02:21:18.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android插件化工程具有减少方法数和包大小，易于扩展等优势，深得大型工程的青睐，但同时插件化也会引起一些意想不到的麻烦。我们最近在做的插件工程就遇到了一个诡异的JNI链接错误。</p>
<p>我们的插件工程作为主工程的具体业务，主工程提供了基础的类库和工具，插件工程有自己的ClassLoader，并把主工程的ClassLoader设为自己的父ClassLoader，通过双亲委托，插件工程就可以访问主工程中的类。在主工程中有一个类库，有JNI方法，但为了减少主工程的包大小，so文件由插件在用到时自己下载和加载。</p>
<p>而这种加载方式，出现了诡异的UnsatisfiedLinkError错误。我们首先检查了System.load方法发现并没有出错，又查看了进程的内存映射信息，发现so文件确实已经加载，但调用JNI方法也确实一直出错。待排查了时序等相关情况后，还是不成功，于是我们只得求助于系统源码，希望能从源码中找到答案，以Android N为例，我们开始了源码分析过程。</p>
<h1 id="so加载流程分析"><a href="#so加载流程分析" class="headerlink" title="so加载流程分析"></a>so加载流程分析</h1><p>so既然要先加载才能用，那我们就先来看so是怎么加载的，先来分析System.load方法。<br><img src="http://img.blog.csdn.net/20171106091841055?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>方法很简单，直接调用了Runtime类的load方法，传入了so的名称和当前的ClassLoader，再来看这个方法。<br><img src="http://img.blog.csdn.net/20171106092114044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到，load校验了参数后调用了doLoad方法，doLoad取得ldLibraryPath和dexPath后调用了native层的nativeLoad函数。继续看nativeLoad函数。<br><img src="http://img.blog.csdn.net/20171106103122578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>还是很简单的函数，设置完LdLibraryPath后，调用JavaVM的LoadNtiveLibrary函数，继续看。<br><img src="http://img.blog.csdn.net/20171106103415424?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171106103426253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>该函数较长，但逻辑还是很清晰的，我们只列出了关键代码，libraries保存了一个以so路径和SharedLibrary对象为记录的Map，保存了当前所有已经加载的so。首先从libraries中查找记录，如果有说明该so已经加载过，再判断和so关联的ClassLoader是不是当前的ClassLoader，如果不是，返回false，这说明同一个路径的so只能被一个ClassLoader加载，如果没找到记录，说明该so没有加载过，则通过dlopen打开该so，保存相关信息到SharedLibrary对象中，把SharedLibrary添加到libraries中，用dlsym查找JNI_OnLoad函数，如果找到了则执行该函数。 在看代码时第一反应是会不会isSameObject判断这里有问题，so已经被另一个ClassLoader给加载了，但转念一想，如果这里有问题那么load的时候会直接报错，而不是在执行的时候才报错。所以so的加载流程没有找到有问题的点，那么我们再看执行流程。</p>
<h1 id="native方法执行流程分析"><a href="#native方法执行流程分析" class="headerlink" title="native方法执行流程分析"></a>native方法执行流程分析</h1><p>我们知道，在ART环境下，类的方法都会用ArtMethod表示，而ArtMethod的PtrSizedFields字段保存了该方法的跳转地址。<br><img src="http://img.blog.csdn.net/20171106104030852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中entry_point_from<em>jni</em>就是native函数执行时的跳转地址，那么这个地址是什么呢？其实这个地址是Class在加载的时候设置的，我们来看下代码：<br><img src="http://img.blog.csdn.net/20171106104112000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>ClassLinker负责在ART中加载Class，通过FindClass-&gt;DefineClass-&gt;LoadClass-&gt;LoadClassMembers，会解析出ArtMethod，最后通过LinkCode对ArtMethod的跳转地址进行赋值，这里我们只看native方法的情况，执行了UnregisterNative函数。<br><img src="http://img.blog.csdn.net/20171106104344854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>SetEntryPointFromJni就是对entry_point_from<em>jni</em>做了赋值，值是通过GetJniDlsymLookupStub()获得，就是一个artjnidlsymlookupstub函数地址，到这里我们知道类加载后其native方法地址被设置成了artjnidlsymlookupstub这个入口函数，当native方法被执行时，会调用这个入口函数执行，我们来看这个函数。<br><img src="http://img.blog.csdn.net/20171106104523247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>art_jni_dlsym_lookup_stub在汇编中定义，与平台相关，我们用arm64平台代码作为例子。<br><img src="http://img.blog.csdn.net/20171106104624924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171106104731125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到这个函数又跳转到了artFindNativeMethod函数。<br><img src="http://img.blog.csdn.net/20171106104943470?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>该函数首先查询native函数的地址，查到后会通过RegisterNative设置给ArtMethod，这样以后就ArtMethod就可以直接跳转到native层的地址，而不用每次都经过该函数，RegisterNative同样调用了SetEntryPointFromJni来设置跳转地址，接下来看FindCodeForNativeMethod函数。<br><img src="http://img.blog.csdn.net/20171106105044641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这里又看到了熟悉的libraries，前边分析so加载部分已经知道它保存了所有已经加载的so，所以这就是从已经加载的so里查找native函数，如果没找到，则抛出UnsatisfiedLinkError。我们再来看看FindNativeMethod。<br><img src="http://img.blog.csdn.net/20171106105137715?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20171106105220501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>FindSymbol就是调用dlsym获取native函数的地址，所以到此native函数的地址就真正的找到了，但是我们注意到了其中的一个判断，library-&gt;GetClassLoader()==declaring_class_loader，也就是和so关联的ClassLoader要和当前的ClassLoader是同一个才行，不然会放弃查找，到此我们的疑惑也就解开了，因为JAVA层的代码是在主工程的ClassLoader里，而加载so用的是插件的ClassLoader，两个ClassLoader不相等，所以在这里放弃了查找而抛出了异常。</p>
<p>#解决方案<br>知道了原因解决自然也就容易了，只要用同一个ClassLoader加载类和so就行了，因为Java层的ClassLoader是变不了的，所以我们就改变加载so的ClassLoader：<br>1、使用主工程中的类来加载so。<br>2、如果主工程不好添加代码的话，我们也可以在插件里改变Runtime.load()所使用的ClassLoader，但是Runtime的load方法只有一个参数的公开方法，传ClassLoader的方法是私有的，所以我们只能通过反射去传入主工程的ClassLoader。<br><img src="http://img.blog.csdn.net/20171106105353900?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>附件：<a href="http://blog.csdn.net/xiangzhihong8/article/details/50854001" target="_blank" rel="external">java基础之反射</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Android插件化工程具有减少方法数和包大小，易于扩展等优势，深得大型工程的青睐，但同时插件化也会引起一些意想不到的麻烦。我们最近在做的插
    
    </summary>
    
      <category term="Android" scheme="http://www.xiangzhihong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.xiangzhihong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发之逆向分析</title>
    <link href="http://www.xiangzhihong.com/2017/10/07/IOS%E5%BC%80%E5%8F%91%E4%B9%8B%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://www.xiangzhihong.com/2017/10/07/IOS开发之逆向分析/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2018-02-11T03:29:21.150Z</updated>
    
    <content type="html"><![CDATA[<p>首先，本逆向分析是系列文章，会分别从常见的逆向技巧来介绍iOS开发中常见的逆向技术。</p>
<h1 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h1><p> 在逆向过程中很多时候需要分析APP和Web端数据交互的内容那么最简单的方式即是抓包网络分析，而使用Charles、Tcpdump也是逆袭分析最基本的手段。本文以Charles为例来介绍网络相关的内容。</p>
<p> Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p>
<p>Charles 主要的功能包括：</p>
<ul>
<li>截取 Http 和 Https 网络封包;</li>
<li>支持重发网络请求，方便后端调试;</li>
<li>支持修改网络请求参数;</li>
<li>支持网络请求的截获并动态修改;</li>
<li>支持模拟慢速网络。</li>
</ul>
<p>Charles安装好后只需自己设置成代理服务器来完成封包的截取，设置也很简单选择菜单中的 “Proxy” –&gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。<br><img src="http://img.blog.csdn.net/20180201194601805" alt="这里写图片描述"></p>
<p>这样你就可以看到网络请求出现在 Charles 的界面中，包括你模拟器你的请求也会在这里，那么小伙伴会有疑问iPhone真机设备的网络数据包如何截取呢，也很简单只需将手机的代理服务器设置为电脑IP即可，如下操作</p>
<p>第一步：Charles 的菜单栏上选择 “Proxy”–&gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。<br><img src="http://img.blog.csdn.net/20180201194711900" alt="这里写图片描述"></p>
<p>第二步：获取Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：<br><img src="http://img.blog.csdn.net/20180201194754301" alt="这里写图片描述"></p>
<p>第三步：设置iPhone设备Http代理，在 iPhone 的 “ 设置 ”–&gt;“ 无线局域网 ” 中，点击当前连接的 wifi 名，可以看到当前连接上的 wifi 的详细信息，在其最底部有「HTTP 代理」一项，点击后，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20180201194931965" alt="这里写图片描述"></p>
<p>至此所有电脑，模拟器，iOS真机设备所有的Http请求都已经可以通过上边的方法抓包分析获取Request和Respone等具体网络请求数据，可是Https的加密请求如何抓取呢？如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。</p>
<p>第一步：我们需要在你要分析的设备上安装Charles证书。点击 Charles 的顶部菜单，选择 “Help” –&gt; “SSL Proxying” ，–&gt; “Install Charles Root Certificate”安装到Mac上抓取Mac产生的Https请求，Install Charles Root Certificate on a Mobile Device or Remote Browser”安装到iOS 真机设备抓取iOS设备产生的Https请求，如下图所示：<br><img src="http://img.blog.csdn.net/20180201195034514" alt="这里写图片描述"></p>
<p>第二步：Charles 的菜单栏上选择 “Proxy”–&gt;“SSL Proxy Settings”添加需要抓取的域名，如下图所示：<br><img src="http://img.blog.csdn.net/20180201195113800" alt="这里写图片描述"></p>
<p>这样就可以分析目标App的所有网络请求，对其进行逆向数据分析，学习下优秀的API设计规范，根据抓包分析的数据格式，通过脚本语言或其他方式伪造网络请求修改数据。比如想自己写个新闻类App就可以抓黄易，某条分析其网络数据，笔者之前分析时记得黄易的接口设计要比某条的清晰明了，然后将就可以在自己的App中使用了。</p>
<p>如果是返回https的接口，可以参考下面的文章：<a href="http://blog.csdn.net/xiangzhihong8/article/details/76651521" target="_blank" rel="external">Charles https使用</a></p>
<h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><p>在逆向过程中很多时候仅仅对数据交互的分析并不能看出业务大概实现逻辑，技术方案，这个时候我们就需要静态分析这个App，今天就浅显的讲下如何静态分析目标APP的方法论。</p>
<p>首先分析目标APP我们需要获取Ipa，那么怎么获取呢，上次我逆向冲顶大会后，有小伙伴问，怎么获取Ipa，其实很简单，虽然Itunes 在新版中去掉了AppStore，但我们可以通过其他渠道下载，如PP助手同步推、91等越狱市场下载。以最近很火小佛系游戏旅かえる（旅行青蛙）为例我们直接搜索如下图：<br><img src="http://img.blog.csdn.net/20180201195915084" alt="这里写图片描述"></p>
<p>获取Ipa文件后，把旅かえる旅行青蛙-1.0.1.ipa 后缀名改为zip，然后解压可以看到iTunesArtwork，iTunesMetadata，META-INF，Payload四个文件，其中iTunesMetadata里边有BundleId，bundleDisplayName，VersionString等等应用相关的信息。</p>
<p><img src="http://img.blog.csdn.net/20180201200012354" alt="这里写图片描述"></p>
<p>Payload里只有一个文件tabikaeru，这个文件也是我们重点要分析的文件，我们直接右键显示，可以看到如下内容，在这里可以看到一些三方库，界面nib文件，图片资源，数据等，其中_Codesignature里边包含了这个包的签名信息，如果我们修改了ipa内部的任一文件重新压缩改为ipa然后安装就会报签名错误，这就是下一节动态分析要用到的技术重签，最重要的可执行文件tabikaeru这个就是所有编译后的二进制代码块。</p>
<p><img src="http://img.blog.csdn.net/20180201200107744" alt="这里写图片描述"></p>
<p>这里简单讲下二进制可执行文件的结构，主要分三部分Object files，Sections，Symbols。其中Object files包括 .o , .framework,.a文件；Sections 对二进制文件进行了一级划分，描述可执行文件全部内容，提供segment，section位置和大小；Symbols 对Section中的各个段进行了二级划分。以下图为例，对于<strong>TEXT </strong>text,表示代码段中的代码内容，其对应地址为0x1000021B0，然后我们拿着这个地址去符号表中查询会发现，这一地址对应的代码0x1000021B0   -[ULWBigResponseButton pointInside:withEvent:]，理解了这个过程我们就可以更好的理解反编译的过程，也能理解友盟Crash分析是如何把那些你看不懂的错误信息还原成你看得懂的函数调用栈的过程。</p>
<p><img src="http://img.blog.csdn.net/20180201200349796" alt="这里写图片描述"></p>
<p>其实介绍到这里都还不是静态分析的重点内容，我们是要反编译，反汇编对不对，那么我们把二进制文件直接丢入<a href="https://www.hopperapp.com/blog/" target="_blank" rel="external">Hopper disassembler</a>（反编译工具）看下呢，试过的小伙伴肯定要说了，看到一堆没意义的字符，是的，因为开发者将自己的Ipa打包上传后，Apple对Ipa加了一层壳，也就是加固，怎么办呢？有很多方式如Dumpdecrypted，Clutch等工具可以砸壳，特别说明砸壳需要越狱手机，因为要使用SSH连接到手机，这里不对该过程展开说明，需要的同学自行学习，《iOS应用逆向工程》小黄书里边有讲，或者一些博客也有介绍。我在这里介绍另一种获取脱壳Ipa的方式，直接在PP助手搜越狱栏目下的Ipa，就是脱壳的Ipa。</p>
<p><img src="http://img.blog.csdn.net/20180201200927029" alt="这里写图片描述"></p>
<p>如上图我们可以看到游戏是基于Unity3D做的，可以看到定位服务LocationService，SplashScreen业务类,三方库GADSDK三方库等内容，如果要进一步看具体方法实现，就需要读图里的汇编代码了，关于ARM汇编一级的逆向知识就更低层包括ARM指令集，各种寄存器操作等不做展开讨论，另外如果是应用类APP分析到这里，整个APP的头文件就都看到，由于该游戏采用Unity3D引擎C#开发如果反编译C#代码还需要其他工具才能进一步看，这里笔者只是举例，有兴趣的同学可以进一步分析。</p>
<p> 最后静态分析在逆向中是非常重要的手段，很多时候我们需要静态分析提供线索，寻找蛛丝马迹，动态分析去论证，多种技术手段互相交替使用，逐步突破，才能一窥究竟，那么我会在下一节中讲解如何动态分析目标APP，如分析UI结构，分析关键技术，或者注入自己的代码改变业务流程，更多骚操作，尽在iOSTips。</p>
<p>附静态分析工具集：</p>
<ul>
<li>Dumpdecrypted：砸壳</li>
<li>class-dump-z: 用于简单分析出工程中的头文件和函数名</li>
<li>IDA：强大的反编译工具</li>
<li>Hopper Disassembler：类似IDA</li>
</ul>
<h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><p>下面以腾讯视频广告移除为例，来讲解如何做动态分析。首先我们进入视频播放页，点击最近的热片《战长沙》，进入详情页如下图，VIP可关闭广告，那么这个详情页肯定会有与与VIP广告相关的业务，我们只要找到对应的ViewController然后丢给Hooper反编译就应该可以看到VIP相关的业务函数。那么怎么知道这一页对应的ViewController呢，有2种办法，一种全局hook viewDidLoad 在这里断点看vc，还有直接看视图堆栈。<br><img src="http://img.blog.csdn.net/20180201201433795" alt="这里写图片描述"></p>
<p>首先我们通过hook viewDidLoad方式书写如下代码，当点击详情时开启断点，可以看到程序被中断，控制台self=QLVideoDetailViewController，我们通过这种方式很容易确定详情播放的控制器为这个类。直接查看UI堆栈发现也是这个类，并且获得了更多信息，可以看到广告相关的View，这里想下下是不可以直接隐藏这个ad view呢?</p>
<p><img src="http://img.blog.csdn.net/20180201201558545" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20180201201629608" alt="这里写图片描述"></p>
<p>通过Hooper发现，和广告相关的代码真多啊，不知道企鹅的程序猿是怎么设计的。<br><img src="http://img.blog.csdn.net/20180201201747494" alt="这里写图片描述"></p>
<p>通过上面静态分析的内容并不能提供明显的思路让我去广告，我准备回到UI堆栈那里，我在这里发现了QNBPlayerVideoAdsViewController，看名字就知道播广告的，邪恶的笑下，鹅肠同学名字起得真是清晰明了，这次试一下直接hide这个控制器看广告会不会消失。</p>
<p><img src="http://img.blog.csdn.net/20180201201920649" alt="这里写图片描述"></p>
<p>我写了如下代码以后，很暴力直接隐藏了广告视图，发现广告会消失一会儿，然后又显示，经过静态分析发现QNBPlayerVideoAdsViewController这个类里边有adsStartPlay，那我更暴力一点，在这个方法里只要你播广告我就影藏这个view，command r运行，看电视剧，妥妥的没广告了，最终代码如下。<br><img src="http://img.blog.csdn.net/20180201202010128" alt="这里写图片描述"></p>
<p>故事讲到这里算是讲完了，有兴趣的同学可以进一步研究vip付费视频如何直接看，整体而言，这次分析的过程比较顺利，我们可以看到在逆向过程中是动态，静态分析结合相互提供线索一步步逼近真相，我们现在复盘，通过复盘来来解密我们使用的工具，以及这些工具背后的原理。</p>
<p>我们这次动态分析使用的是IPAPatch，和这个类似的有AloneMonkey的MonkeyDev，这俩库原理类似核心思想都是将我们自己写的代码编成动态库注入目标App，然后重签，作为一个有情怀的开发者，仅仅会使用工具肯定不是我们的目标对不对，我们要做的是探究这个过程是如何实现的，这里我抛出几个问题动态库是如何注入的？App重签名的过程是怎样的？今天我们大概简单聊聊有个印象，这些内容每一个点都很重要，都是逆向的基础知识，虽然枯燥但是，但可以让你更好的理解这些原理。</p>
<p>如果要理解动态库注入那还需要更深入的理解Mach-o的文件结构，我在上篇文章中简单讲了下，这里再详细的讲下，一个典型的Mach-O文件格式如图所示：<br><img src="http://img.blog.csdn.net/20180201202105763" alt="这里写图片描述"></p>
<p>通过上图，可以看出Mach-O主要由以下三部分组成：</p>
<p>Mach-O头部（mach header）。描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</p>
<p>加载命令（load command）。描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</p>
<p>Data。Data中的每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个Section，它们存放了具体的数据与代码。</p>
<p>二进制当中所有引用到的动态库都放在Load commands段当中，那么我们只要，通过给这个段增加记录，就可以注入我们自己写的动态库了，对不对。那么问题来了，在这里插入我们自己的动态库有什么用？我们自己写的代码没有执行的入口，一样什么都不能干，我们还需要一个”main”函数来执行我们自己的代码，不要忘了，这个”main”函数在oc里面称为构造函数，只要在函数前声明 “attribute((constructor)) static” 即可，这样你的代码就可以被目标APP执行了。</p>
<p>关于重签名，有兴趣的同学可以学习下整个签名过程，包括代码如何签名，证书如何校验等，重签名大概过程如下，<br>1、解压ipa安装包 cp test.ipa olinone.zip<br>2、替换证书配置文件（文件名必须为embedded）<br>cp embedded.mobileprovision Payload/test.app<br>3、重签名（certifierName为重签名证书文件名，可以加证书ID后缀）<br>certifierName=”iPhone Distribution: olinone Information Technology Limited(6a5LOVE58MYX)” codesign -f -s $certifierName  –entitlements entitlements.plist Payload/test.app<br>4、打包 zip -r test.ipa Payload</p>
<p> 至此逆向系列的入门教程已经全部更完，现在应该拿到一个App应该已经可以自己玩了，篇幅有限，有很多内容不能展开讲，也没讲到，比如有攻就有防，了解防才可以更好的绕过，如何为自己的App加固，再比如一些细节符号表是怎样恢复的，砸壳的原理到底是怎样的，这些有趣的话题我们只能后边再聊，更多骚操作，尽在iOSTips，关注公众号，第一时间get新姿势。  </p>
<p>附静态分析工具集：</p>
<ul>
<li>Dumpdecrypted：砸壳</li>
<li>class-dump-z: 用于简单分析出工程中的头文件和函数名</li>
<li>IDA：强大的反编译工具</li>
<li>Hopper Disassembler：类似IDA</li>
</ul>
<p>附动态分析工具集：</p>
<ul>
<li>IPAPatch，MonkeyDev：</li>
<li>Reveal 界面分析</li>
<li>CaptainHook，Tweak 编写hook代码，或自定义功能</li>
</ul>
<p>附：<br>《iOS Hacker’s Handbook》<br>《iOS应用逆向工程:分析与实战》小黄书<br>  iOSRE 中文逆向论坛</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，本逆向分析是系列文章，会分别从常见的逆向技巧来介绍iOS开发中常见的逆向技术。&lt;/p&gt;
&lt;h1 id=&quot;网络分析&quot;&gt;&lt;a href=&quot;#网络分析&quot; class=&quot;headerlink&quot; title=&quot;网络分析&quot;&gt;&lt;/a&gt;网络分析&lt;/h1&gt;&lt;p&gt; 在逆向过程中很多时候需
    
    </summary>
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.xiangzhihong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>移动工程师如何学习人工智能</title>
    <link href="http://www.xiangzhihong.com/2017/10/05/%E7%A7%BB%E5%8A%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://www.xiangzhihong.com/2017/10/05/移动工程师如何学习人工智能/</id>
    <published>2017-10-04T16:00:00.000Z</published>
    <updated>2017-12-07T13:35:30.544Z</updated>
    
    <content type="html"><![CDATA[<p>当前和未来两年，人工智能是技术行业的发展主流。用来开发机器学习主要有三门语言：Python Java C++，其中Python是主流。学习人工智能技术之前，得先好好复习下高数，比如说，高数，微积分，线性代数，微积分，数理统计，概率论等，还有一些典型的算法等。</p>
<p>结合最近对人工智能的学习思路，现对移动工程师学习人工智能的学习之旅总结如下。本门课程总共分为10章，并配相关的案例讲解。<br><img src="http://img.blog.csdn.net/20171205134440906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第一部分：Python语言基础"><a href="#第一部分：Python语言基础" class="headerlink" title="第一部分：Python语言基础"></a>第一部分：Python语言基础</h2><p>此部分是Python的基础语法部分，主要分为如下小节。<br><img src="http://img.blog.csdn.net/20171205134538958?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第二部分：数据库开发"><a href="#第二部分：数据库开发" class="headerlink" title="第二部分：数据库开发"></a>第二部分：数据库开发</h2><p>此部分会对关系型数据库做基本的讲解。<br><img src="http://img.blog.csdn.net/20171205134629088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第三部分：web前端"><a href="#第三部分：web前端" class="headerlink" title="第三部分：web前端"></a>第三部分：web前端</h2><p>此部分会结合前端的一些基础知识点，做web前端技术做简单的讲解。<br><img src="http://img.blog.csdn.net/20171205134723472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第四部分：Python-web开发"><a href="#第四部分：Python-web开发" class="headerlink" title="第四部分：Python web开发"></a>第四部分：Python web开发</h2><p><img src="http://img.blog.csdn.net/20171205134746859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第五部分：Python-web项目"><a href="#第五部分：Python-web项目" class="headerlink" title="第五部分：Python web项目"></a>第五部分：Python web项目</h2><p>本部分结合项目实例来讲解Python。<br><img src="http://img.blog.csdn.net/20171205134835059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第六部分：Linux"><a href="#第六部分：Linux" class="headerlink" title="第六部分：Linux"></a>第六部分：Linux</h2><p><img src="http://img.blog.csdn.net/20171205140017912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第七部分：NoSQL"><a href="#第七部分：NoSQL" class="headerlink" title="第七部分：NoSQL"></a>第七部分：NoSQL</h2><p><img src="http://img.blog.csdn.net/20171205140034924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第八部分：数据可视化"><a href="#第八部分：数据可视化" class="headerlink" title="第八部分：数据可视化"></a>第八部分：数据可视化</h2><p><img src="http://img.blog.csdn.net/20171205140056101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第九部分：爬虫技术"><a href="#第九部分：爬虫技术" class="headerlink" title="第九部分：爬虫技术"></a>第九部分：爬虫技术</h2><p><img src="http://img.blog.csdn.net/20171205140116033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="第十部分：人工智能"><a href="#第十部分：人工智能" class="headerlink" title="第十部分：人工智能"></a>第十部分：人工智能</h2><p><img src="http://img.blog.csdn.net/20171205140135625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>除此之外，下面提供一些Android开发的开发图谱，包括从基础到高级，大家可以根据自身的情况选择学习。</p>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><img src="http://img.blog.csdn.net/20171205150010894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>##进阶篇<br><img src="http://img.blog.csdn.net/20171205150038260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><p><img src="http://img.blog.csdn.net/20171205150053982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhbmd6aGlob25nOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前和未来两年，人工智能是技术行业的发展主流。用来开发机器学习主要有三门语言：Python Java C++，其中Python是主流。学习人工智能技术之前，得先好好复习下高数，比如说，高数，微积分，线性代数，微积分，数理统计，概率论等，还有一些典型的算法等。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="人工智能" scheme="http://www.xiangzhihong.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="人工智能" scheme="http://www.xiangzhihong.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Node+React小爬虫：从开发到部署</title>
    <link href="http://www.xiangzhihong.com/2017/09/26/Node+React%E5%B0%8F%E7%88%AC%E8%99%AB%EF%BC%9A%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E9%83%A8%E7%BD%B2/"/>
    <id>http://www.xiangzhihong.com/2017/09/26/Node+React小爬虫：从开发到部署/</id>
    <published>2017-09-25T16:00:00.000Z</published>
    <updated>2017-12-07T13:22:41.747Z</updated>
    
    <content type="html"><![CDATA[<p>我一般都喜欢去一些技术类博客社区或者 UGC 社区浏览文章，相信与我同类的你应该也有这爱好。为了方便自己的阅读，而不用一个一个打开目标网站的地址，就基于 Node+React 写了一个小爬虫: Tech-Read，用于抓取常去的 UGC 社区的文章摘要。目前的版本大概样子如下：</p>
<p>version</p>
<p>在线地址：Tech-Read<br>github 地址：tech-read</p>
<p>开发</p>
<p>Tech-Read 是个人的一个业余项目，初衷是方便自己阅读，实在是懒于去社区网站阅读，其次用于练手喽，毕竟最近在学点新东西。</p>
<p>在工作上，接触的技术栈是 Node + React，所以 TR 也采用了 Node + React 的技术栈。React 用于前端界面渲染，Node 用于抓取网页，并将解析后的 DOM 数据返回给前端调用。</p>
<p>前端的请求是用 fetch 发起的，由于部分社区做了跨域设置，So 用 Node 能帮我解决一些跨域的问题：</p>
<p>cors</p>
<p>以及在 fetch 中解析 DOM 时碰到的诸如 Uncaught (in promise) TypeError: unexpected token &lt;… 等杂七杂八的错误。</p>
<p>并且 Node 端提供了直接操作 DOM 节点的 cheerio，它是 jQuery 的一个子集实现，能非常方便的操作 DOM 元素。所以，目前我把 DOM 解析放在了 Node 端，前端只负责渲染。</p>
<p>所以，现在的处理流程如下：</p>
<p>process</p>
<p>由于目前业务比较简单，前端的状态管理就用 Flux。Node 使用 Koa，匹配到 fetch 发起的路由后，通过 request 向目标网站发起请求，然后通过 cheerio 解析 body，获取 DOM 元素数据，以 json 形式返回给前端进行展示。</p>
<p>request 发起的异步请求的返回对象不带 Promise/Generator 等特性，所以不能同步写，但利用 Promise 简单封装下：</p>
<p>exports.parseBody = function (url) {<br>    return new Promise(function (resolve, reject) {<br>        request(url, (error, res, body) =&gt; {<br>           if(!error &amp;&amp; res.statusCode === 200) {<br>               resolve(body);<br>           } else {<br>               reject(error);<br>           }<br>        });<br>    });<br>};<br>就能同步的来写异步请求了：</p>
<p>let resBody = yield lib.parseBody(‘<a href="http://toutiao.io/&#39;).then((body" target="_blank" rel="external">http://toutiao.io/&#39;).then((body</a>) =&gt; {<br>        return body;<br>    });<br>另外一个选择是，利用 co-request，基于 generator 的一个网络请求库。</p>
<p>我个人很喜欢开发者头条，所以第一个抓取的也是开发者头条。由于我想在 TR 上直接看原文，就像这样子：</p>
<p>yunawen</p>
<p>所以我需要拿到原文链接，插入到 Iframe 里面去。抓取其它社区时，能在抓取首页时顺便拿到原文链接，但是抓取开发者头条的时候，并不能，因为它的 DOM 结构是这样的：</p>
<p>toutiao</p>
<p>这个 a 的 href 属性并不是原文的链接，要想拿到原文链接，还需要再向 <a href="http://toutiao.io/r/b04ku7/r/b04ku7" target="_blank" rel="external">http://toutiao.io/r/b04ku7/r/b04ku7</a> 发起一次 get 请求：</p>
<p>originUrl</p>
<p>但这个 Location 是不能直接拿到的，因为返回的状态码是 302，页面会被直接跳转到了 Location 指向的页面。但是，request 发起请求后的 response 中则包含了 host 和 path 信息：</p>
<p>req.on(‘response’, (res) =&gt; {<br>            if(res.statusCode === 200) {<br>                urlPath = res.client._httpMessage._headers.host + res.client._httpMessage.path;<br>                resolve(urlPath);<br>            }<br>        });<br>将二者拼接，就能得到原文的 URL 了。</p>
<p>开发者头条部分实现了无限加载：</p>
<p>let contents = document.getElementsByClassName(‘toutiao-contents’)[0];<br>let contentsHeight = contents.getBoundingClientRect().height;<br>contents.addEventListener(‘scroll’, (e) =&gt; {<br>            let triggerNextMinHeight = e.target.scrollHeight - e.target.scrollTop - contentsHeight;<br>            if(triggerNextMinHeight &lt; 22) {<br>                //fetch data &amp; update component state<br>            }<br>        },false);<br>无限加载调用的接口是：</p>
<p><a href="http://toutiao.io/prev/date" target="_blank" rel="external">http://toutiao.io/prev/date</a>   //date 形如 2016-04-26<br>部署</p>
<p>前文以抓取开发者头条为例，简单讲述了爬虫的实现思路，接下来就简单说说怎么部署 Node 服务。</p>
<p>由于服务器上已经跑了自己的博客，端口 80 已经被Apache 监听了，所以，你看到的 TR 的线上端口就是奇怪的 8080 了，这是 Nginx 监听的，然后被代理到本地的 9000 端口，这也是开发用的端口。</p>
<p>部署之前，先安装下 Node(系统是 CentOS 6.5 64bit)。</p>
<p>1、安装nvm</p>
<p>curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh" target="_blank" rel="external">https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh</a> | bash<br>或者：</p>
<p>wget -qO- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh" target="_blank" rel="external">https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh</a> | bash<br>建议使用 nvm 安装 Node，因为 nvm 会安装到用户的目录，而 n 会安装到全局的 /usr/ 目录下去。</p>
<p>2、安装 Node</p>
<p>nvm install 4.4.2<br>如果安装了多版本，则可以将默认的 Node 版本设置成 4.4.2：</p>
<p>nvm alias default 4.4.2<br>3、安装Nginx</p>
<p>切换到 /etc/yum.repos.d/ 创建文件 nginx.repo ，将下面的粘贴到文件中：</p>
<p>[nginx]<br>name=nginx repo<br>baseurl=<a href="http://nginx.org/packages/centos/$releasever/$basearch/" target="_blank" rel="external">http://nginx.org/packages/centos/$releasever/$basearch/</a><br>gpgcheck=0<br>enabled=1<br>然后安装 Nginx:</p>
<p>yum install nginx<br>Nginx 的相关配置:</p>
<p>/etc/init.d/nginx start/restart # 启动/重启Nginx服务</p>
<p>/etc/init.d/nginx stop # 停止Nginx服务</p>
<p>/etc/nginx/nginx.conf # Nginx配置文件位置<br>4、配置 Nginx</p>
<p>切换到 /etc/nginx/conf.d ，复制 default.conf 文件，按照需要配置新的 conf 文件：</p>
<p>conf</p>
<p>techread.conf 配置文件如下：</p>
<p>trconf</p>
<p>listen: 监听的线上端口<br>server_name: 访问的域名<br>root: 根目录<br>index: 默认访问的文件</p>
<p>nginx 可以有多个虚拟主机，每个虚拟主机一个对应的server配置项。</p>
<p>红框部分是 Nginx 的反向代理配置：</p>
<p>proxy_set_header X-Real-IP $remote_addr;<br>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>proxy_set_header HOST $http_host;<br>proxy_set_header X-Nginx_Proxy true;<br>proxy_pass <a href="http://127.0.0.1:9000/" target="_blank" rel="external">http://127.0.0.1:9000/</a>;<br>proxy_redirect off;<br>proxy_pass 是必备项，表示要被代理的服务地址，其它可有可无(至少对于 TR 来说)。</p>
<p>安利一份关于解读 Nginx 源码的资源：Nginx 福利</p>
<p>启动 Nginx 时，默认是读取 default.conf，现在需要将其更改为读取 techread.conf。 回到 /etc/nginx 下，修改 nginx.conf 文件， 将 include 的引用改为新建的文件：techread.conf：</p>
<p>include tr</p>
<p>重启 nginx，线上部署就 OK 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一般都喜欢去一些技术类博客社区或者 UGC 社区浏览文章，相信与我同类的你应该也有这爱好。为了方便自己的阅读，而不用一个一个打开目标网站的地址，就基于 Node+React 写了一个小爬虫: Tech-Read，用于抓取常去的 UGC 社区的文章摘要。目前的版本大概样子如
    
    </summary>
    
      <category term="后端" scheme="http://www.xiangzhihong.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="后端" scheme="http://www.xiangzhihong.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin与Java互操作</title>
    <link href="http://www.xiangzhihong.com/2017/09/23/Kotlin%E4%B8%8EJava%E4%BA%92%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.xiangzhihong.com/2017/09/23/Kotlin与Java互操作/</id>
    <published>2017-09-22T16:00:00.000Z</published>
    <updated>2018-02-11T03:12:43.617Z</updated>
    
    <content type="html"><![CDATA[<p>互操作就是在Kotlin中可以调用其他编程语言的接口，只要它们开放了接口，Kotlin就可以调用其成员属性和成员方法，这是其他编程语言所无法比拟的。同时，在进行Java编程时也可以调用Kotlin中的API接口。</p>
<h1 id="Kotlin调用Java"><a href="#Kotlin调用Java" class="headerlink" title="Kotlin调用Java"></a>Kotlin调用Java</h1><p>Kotlin在设计时就考虑了与Java的互操作性。可以从Kotlin中自然地调用现有的Java代码，在Java代码中也可以很顺利地调用Kotlin代码。例如，在Kotlin中调用Java的Util的list库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import java.util.*</div><div class="line"></div><div class="line">fun demo(source: List&lt;Int&gt;) &#123;</div><div class="line">    val list = ArrayList&lt;Int&gt;()</div><div class="line">    // “for”-循环用于 Java 集合：</div><div class="line">    for (item in source) &#123;</div><div class="line">        list.add(item)</div><div class="line">    &#125;</div><div class="line">    // 操作符约定同样有效：</div><div class="line">    for (i in 0..source.size - 1) &#123;</div><div class="line">        list[i] = source[i] // 调用 get 和 set</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本的互操作行为如下：</p>
<h2 id="属性读写"><a href="#属性读写" class="headerlink" title="属性读写"></a>属性读写</h2><p>Kotlin可以自动识别Java中的getter/setter函数，而在Java中可以过getter/setter操作Kotlin属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import java.util.Calendar</div><div class="line"></div><div class="line">fun calendarDemo() &#123;</div><div class="line">    val calendar = Calendar.getInstance()</div><div class="line">    if (calendar.firstDayOfWeek == Calendar.SUNDAY) &#123;  // 调用 getFirstDayOfWeek()</div><div class="line">        calendar.firstDayOfWeek = Calendar.MONDAY      // 调用ll setFirstDayOfWeek()</div><div class="line">    &#125;</div><div class="line">    if (!calendar.isLenient) &#123;                         // 调用 isLenient()</div><div class="line">        calendar.isLenient = true                      // 调用 setLenient()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循Java约定的getter和setter方法（名称以get开头的无参数方法和以set开头的单参数方法）在Kotlin中表示为属性。如果Java类只有一个setter，那么它在Kotlin中不会作为属性可见，因为Kotlin目前不支持只写（set-only）属性。</p>
<h2 id="空安全类型"><a href="#空安全类型" class="headerlink" title="空安全类型"></a>空安全类型</h2><p>Kotlin的空安全类型的原理是，Kotlin在编译过程中会增加一个函数调用，对参数类型或者返回类型进行控制，开发者可以在开发时通过注解@Nullable和@NotNull方式来限制Java中空值异常。<br>Java中的任何引用都可能是null，这使得Kotlin对来自Java的对象进行严格的空安全检查是不现实的。Java声明的类型在Kotlin中称为平台类型，并会被特别对待。对这种类型的空检查要求会放宽，因此对它们的安全保证与在Java中相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val list = ArrayList&lt;String&gt;() // 非空（构造函数结果）</div><div class="line">list.add(&quot;Item&quot;)</div><div class="line">val size = list.size // 非空（原生 int）</div><div class="line">val item = list[0] // 推断为平台类型（普通 Java 对象）</div></pre></td></tr></table></figure>
<p>当调用平台类型变量的方法时，Kotlin不会在编译时报告可空性错误，但是在运行时调用可能会失败，因为空指针异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">item.substring(1)//允许，如果item==null可能会抛出异常</div></pre></td></tr></table></figure>
<p>平台类型是不可标识的，这意味着不能在代码中明确地标识它们。当把一个平台值赋给一个Kotlin变量时，可以依赖类型推断（该变量会具有所推断出的平台类型，如上例中item所具有的类型），或者选择我们所期望的类型（可空的或非空类型均可）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val nullable:String?=item//允许，没有问题</div><div class="line">Val notNull:String=item//允许，运行时可能失败</div></pre></td></tr></table></figure>
<p>如果选择非空类型，编译器会在赋值时触发一个断言，这样可以防止Kotlin的非空变量保存空值。当把平台值传递给期待非空值等的Kotlin函数时，也会触发一个断言。总的来说，编译器尽力阻止空值的传播（由于泛型的原因，有时这不可能完全消除）。</p>
<h3 id="平台类型标识法"><a href="#平台类型标识法" class="headerlink" title="平台类型标识法"></a>平台类型标识法</h3><p>如上所述，平台类型不能在程序中显式表述，因此在语言中没有相应语法。 然而，编译器和 IDE 有时需要（在错误信息中、参数信息中等）显示他们，Koltin提供助记符来表示他们：</p>
<ul>
<li>T! 表示“T 或者 T?”；</li>
<li>(Mutable)Collection<t>! 表示“可以可变或不可变、可空或不可空的 T 的 Java 集合”；</t></li>
<li>Array&lt;(out) T&gt;! 表示“可空或者不可空的 T（或 T 的子类型）的 Java 数组”。</li>
</ul>
<h3 id="可空注解"><a href="#可空注解" class="headerlink" title="可空注解"></a>可空注解</h3><p> 由于泛型的原因，Kotlin在编译时可能出现空异常，而使用空注解可以有效的解决这一情况。编译器支持多种可空性注解：</p>
<ul>
<li><strong>JetBrains</strong>：org.jetbrains.annotations 包中的 @Nullable 和 @NotNull；</li>
<li><strong>Android</strong>：com.android.annotations 和 android.support.annotations；</li>
<li><strong>JSR-305</strong>：javax.annotation；</li>
<li><strong>FindBugs</strong>：edu.umd.cs.findbugs.annotations；</li>
<li><strong>Eclipse</strong>：org.eclipse.jdt.annotation；</li>
<li><strong>Lombok</strong>：lombok.NonNull；</li>
</ul>
<h3 id="JSR-305-支持"><a href="#JSR-305-支持" class="headerlink" title="JSR-305 支持"></a>JSR-305 支持</h3><p> 在JSR-305中，定义的 @Nonnull 注解来表示 Java 类型的可空性。<br> 如果 @Nonnull(when = …) 值为 When.ALWAYS，那么该注解类型会被视为非空；When.MAYBE 与 When.NEVER 表示可空类型；而 When.UNKNOWN 强制类型为平台类型。<br> 可针对 JSR-305 注解编译库，但不需要为库的消费者将注解构件（如 jsr305.jar）指定为编译依赖。Kotlin 编译器可以从库中读取 JSR-305 注解，并不需要该注解出现在类路径中。</p>
<p>自 Kotlin 1.1.50 起， 也支持<a href="https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md" target="_blank" rel="external">自定义可空限定符</a>（KEEP-79） </p>
<h4 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h4><p>如果一个注解类型同时标注有 @TypeQualifierNickname 与 JSR-305 @Nonnull（或者它的其他别称，如 @CheckForNull），那么该注解类型自身将用于 检索精确的可空性，且具有与该可空性注解相同的含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@TypeQualifierNickname</div><div class="line">@Nonnull(when = When.ALWAYS)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface MyNonnull &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@TypeQualifierNickname</div><div class="line">@CheckForNull // 另一个类型限定符别称的别称</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">public @interface MyNullable &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface A &#123;</div><div class="line">    @MyNullable String foo(@MyNonnull String x); </div><div class="line">    // 在 Kotlin（严格模式）中：`fun foo(x: String): String?`</div><div class="line">    </div><div class="line">    String bar(List&lt;@MyNonnull String&gt; x);       </div><div class="line">    // 在 Kotlin（严格模式）中：`fun bar(x: List&lt;String&gt;!): String!`</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类型限定符默认值"><a href="#类型限定符默认值" class="headerlink" title="类型限定符默认值"></a>类型限定符默认值</h4><p>@TypeQualifierDefault 引入应用时在所标注元素的作用域内定义默认可空性的注解。这些注解类型应自身同时标注有 @Nonnull（或其别称）与 @TypeQualifierDefault(…) 注解， 后者带有一到多个 ElementType 值。</p>
<ul>
<li>ElementType.METHOD 用于方法的返回值；</li>
<li>ElementType.PARAMETER 用于值参数；</li>
<li>ElementType.FIELD 用于字段；</li>
<li>ElementType.TYPE_USE（自 1.1.60 起）适用于任何类型，包括类型参数、类型参数的上界与通配符类型。</li>
</ul>
<p>当类型并未标注可空性注解时使用默认可空性，并且该默认值是由最内层标注有带有与所用类型相匹配的 ElementType 的类型限定符默认注解的元素确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Nonnull</div><div class="line">@TypeQualifierDefault(&#123;ElementType.METHOD, ElementType.PARAMETER&#125;)</div><div class="line">public @interface NonNullApi &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Nonnull(when = When.MAYBE)</div><div class="line">@TypeQualifierDefault(&#123;ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</div><div class="line">public @interface NullableApi &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@NullableApi</div><div class="line">interface A &#123;</div><div class="line">    String foo(String x); // fun foo(x: String?): String?</div><div class="line"> </div><div class="line">    @NotNullApi // 覆盖来自接口的默认值</div><div class="line">    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String </div><div class="line">    </div><div class="line">    // 由于 `@NullableApi` 具有 `TYPE_USE` 元素类型，</div><div class="line">    // 因此认为 List&lt;String&gt; 类型参数是可空的：</div><div class="line">    String baz(List&lt;String&gt; x); // fun baz(List&lt;String?&gt;?): String?</div><div class="line"></div><div class="line">    // “x”参数仍然是平台类型，因为有显式</div><div class="line">    // UNKNOWN 标记的可空性注解：</div><div class="line">    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也支持包级的默认可空性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@NonNullApi // 默认将“test”包中所有类型声明为不可空</div><div class="line">package test;</div></pre></td></tr></table></figure>
<h4 id="UnderMigration-注解"><a href="#UnderMigration-注解" class="headerlink" title="@UnderMigration 注解"></a>@UnderMigration 注解</h4><p>库的维护者可以使用 @UnderMigration 注解（在单独的构件 kotlin-annotations-jvm 中提供）来定义可为空性类型限定符的迁移状态。<br>@UnderMigration(status = …) 中的状态值指定了编译器如何处理 Kotlin 中注解类型的不当用法（例如，使用 @MyNullable 标注的类型值作为非空值）：</p>
<ul>
<li>MigrationStatus.STRICT 使注解像任何纯可空性注解一样工作，即对不当用法报错并影响注解声明内的类型在 Kotlin中的呈现；</li>
<li>对于 MigrationStatus.WARN，不当用法报为警告而不是错误； 但注解声明内的类型仍是平台类型；</li>
<li>MigrationStatus.IGNORE 则使编译器完全忽略可空性注解。</li>
</ul>
<p>库的维护者还可以将 @UnderMigration 状态添加到类型限定符别称与类型限定符默认值中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Nonnull(when = When.ALWAYS)</div><div class="line">@TypeQualifierDefault(&#123;ElementType.METHOD, ElementType.PARAMETER&#125;)</div><div class="line">@UnderMigration(status = MigrationStatus.WARN)</div><div class="line">public @interface NonNullApi &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 类中的类型是非空的，但是只报警告</div><div class="line">// 因为 `@NonNullApi` 标注了 `@UnderMigration(status = MigrationStatus.WARN)`</div><div class="line">@NonNullApi </div><div class="line">public class Test &#123;&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：可空性注解的迁移状态并不会从其类型限定符别称继承，而是适用于默认类型限定符的用法。如果默认类型限定符使用类型限定符别称，并且它们都标注有 @UnderMigration，那么使用默认类型限定符的状态。</p>
<h2 id="返回void的方法"><a href="#返回void的方法" class="headerlink" title="返回void的方法"></a>返回void的方法</h2><p>如果在Java中返回void，那么Kotlin返回的就是Unit。如果在调用时返回void，那么Kotlin会事先识别该返回值为void。</p>
<h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>@JvmField是Kotlin和Java互相操作属性经常遇到的注解；@JvmStatic是将对象方法编译成Java静态方法；@JvmOverloads主要是Kotlin定义默认参数生成重载方法；@file:JvmName指定Kotlin文件编译之后生成的类名。</p>
<h2 id="NoArg和AllOpen"><a href="#NoArg和AllOpen" class="headerlink" title="NoArg和AllOpen"></a>NoArg和AllOpen</h2><p>数据类本身属性没有默认的无参数的构造方法，因此Kotlin提供一个NoArg插件，支持JPA注解，如@Entity。AllOpen是为所标注的类去掉final，目的是为了使该类允许被继承，且支持Spring注解，如@Componet；支持自定义注解类型，如@Poko。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Kotlin 的泛型与 Java 有点不同，读者可以具体参考泛型章节。Kotlin中的通配符“”代替Java中的“？”；协变和逆变由Java中的extends和super变成了out和in，如ArrayList；在Kotlin中没有Raw类型，如Java中的List对应于Kotlin就是List&lt;&gt;。</p>
<p>与Java一样，Kotlin在运行时不保留泛型，也就是对象不携带传递到它们的构造器中的类型参数的实际类型，即ArrayList()和ArrayList()是不能区分的。这使得执行is检查不可能照顾到泛型，Kotlin只允许is检查星投影的泛型类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (a is List&lt;Int&gt;) // 错误：无法检查它是否真的是一个 Int 列表</div><div class="line">// but</div><div class="line">if (a is List&lt;*&gt;) // OK：不保证列表的内容</div></pre></td></tr></table></figure>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><p>与 Java 不同，Kotlin 中的数组是不型变的。这意味着 Kotlin 不允许我们把一个 Array<string> 赋值给一个 Array<any>， 从而避免了可能的运行时故障。Kotlin 也禁止我们把一个子类的数组当做超类的数组传递给 Kotlin 的方法， 但是对于 Java 方法，这是允许的（通过 Array&lt;(out) String&gt;! 这种形式的平台类型）。</any></string></p>
<p>Java 平台上，数组会使用原生数据类型以避免装箱/拆箱操作的开销。 由于 Kotlin 隐藏了这些实现细节，因此需要一个变通方法来与 Java 代码进行交互。 对于每种原生类型的数组都有一个特化的类（IntArray、 DoubleArray、 CharArray 等等）来处理这种情况。 它们与 Array 类无关，并且会编译成 Java 原生类型数组以获得最佳性能。</p>
<p>例如，假设有一个接受 int 数组索引的 Java 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class JavaArrayExample &#123;</div><div class="line">    public void removeIndices(int[] indices) &#123;</div><div class="line">        // 在此编码……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Kotlin 中调用该方法时，你可以这样传递一个原生类型的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val javaObj = JavaArrayExample()</div><div class="line">val array = intArrayOf(0, 1, 2, 3)</div><div class="line">javaObj.removeIndices(array)  // 将 int[] 传给方法</div></pre></td></tr></table></figure>
<p>当编译为 JVM 字节代码时，编译器会优化对数组的访问，这样就不会引入任何开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val array = arrayOf(1, 2, 3, 4)</div><div class="line">array[x] = array[x] * 2 // 不会实际生成对 get() 和 set() 的调用</div><div class="line">for (x in array) &#123; // 不会创建迭代器</div><div class="line">    print(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使当我们使用索引定位时，也不会引入任何开销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (i in array.indices) &#123;// 不会创建迭代器</div><div class="line">    array[i] += 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，in-检测也没有额外开销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (i in array.indices) &#123; // 同 (i &gt;= 0 &amp;&amp; i &lt; array.size)</div><div class="line">    print(array[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java-可变参数"><a href="#Java-可变参数" class="headerlink" title="Java 可变参数"></a>Java 可变参数</h2><p>Java 类有时声明一个具有可变数量参数（varargs）的方法来使用索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class JavaArrayExample &#123;</div><div class="line">    public void removeIndicesVarArg(int... indices) &#123;</div><div class="line">        // 函数体……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这种情况下，你需要使用展开运算符 * 来传递 IntArray。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val javaObj = JavaArrayExample()</div><div class="line">val array = intArrayOf(0, 1, 2, 3)</div><div class="line">javaObj.removeIndicesVarArg(*array)</div></pre></td></tr></table></figure>
<p>目前，无法传递 null 给一个声明为可变参数的方法。</p>
<h2 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h2><p>就像Java 8一样，Kotlin支持SAM转换，这意味着Kotlin函数字面值可以被自动转换成只有一个非默认方法的Java接口的实现，只要这个方法的参数类型能够与这个Kotlin函数的参数类型相匹配就行。</p>
<p>首先使用Java创建一个SAMInJava类，然后通过Kotlin调用Java中的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">public class SAMInJava&#123;</div><div class="line">    private ArrayList&lt;Runnable&gt;runnables=new ArrayList&lt;Runnable&gt;();</div><div class="line">    public void addTask(Runnable runnable)&#123;</div><div class="line">        runnables.add(runnable);</div><div class="line">System.out.println(&quot;add:&quot;+runnable+&quot;,size&quot;+runnables.size());</div><div class="line">    &#125;</div><div class="line">    Public void removeTask(Runnable runnable)&#123;</div><div class="line">        runnables.remove(runnable);</div><div class="line">System.out.println(&quot;remove:&quot;+runnable+&quot;size&quot;+runnables.size());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在Kotlin中调用该Java接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    var samJava=SAMJava()</div><div class="line">    val lamba=&#123;</div><div class="line">        print(&quot;hello&quot;)</div><div class="line">    &#125;</div><div class="line">    samJava.addTask(lamba)</div><div class="line">    samJava.removeTask(lamba)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add:SAMKotlinKt$sam$Runnable$8b8e16f1@4617c264,size1</div><div class="line">remove:SAMKotlinKt$sam$Runnable$8b8e16f1@36baf30csize1</div></pre></td></tr></table></figure>
<p>如果Java类有多个接受函数式接口的方法，那么可以通过使用将Lambda表达式转换为特定的SAM类型的适配器函数来选择需要调用的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">val lamba=&#123;</div><div class="line">    print(&quot;hello&quot;)</div><div class="line">&#125;</div><div class="line">samJava.addTask(lamba)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>SAM转换只适用于接口，而不适用于抽象类，即使这些抽象类只有一个抽象方法。此功能只适用于Java互操作；因为Kotlin具有合适的函数类型，所以不需要将函数自动转换为Kotlin接口的实现，因此不受支持。</p>
<p>除此之外，Kotlin调用Java还有很多的内容，读者可以通过下面的链接来了解：<a href="https://www.kotlincn.net/docs/reference/java-interop.html" target="_blank" rel="external">Kotlin调用Java</a></p>
<h1 id="Java调用Kotlin"><a href="#Java调用Kotlin" class="headerlink" title="Java调用Kotlin"></a>Java调用Kotlin</h1><p>Java 可以轻松调用 Kotlin 代码。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Kotlin属性会被编译成以下Java元素：</p>
<ul>
<li>getter方法，其名称通过加前缀get得到；</li>
<li>setter方法，其名称通过加前缀set得到（只适用于var属性）；</li>
<li>私有字段，与属性名称相同（仅适用于具有幕后字段的属性）。</li>
</ul>
<p>例如，将Kotlin变量编译成Java中的变量声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private String firstName;</div><div class="line"></div><div class="line">public String getFirstName() &#123;</div><div class="line">    return firstName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void setFirstName(String firstName) &#123;</div><div class="line">    this.firstName = firstName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果属性名称是以is开头的，则使用不同的名称映射规则：getter的名称与属性名称相同，并且setter的名称是通过将is替换成set获得的。例如，对于属性isOpen，其getter会称作isOpen()，而其setter会称作setOpen()。这一规则适用于任何类型的属性，并不仅限于Boolean。</p>
<h2 id="包级函数"><a href="#包级函数" class="headerlink" title="包级函数"></a>包级函数</h2><p>例如，在org.foo.bar 包内的 example.kt 文件中声明的所有的函数和属性，包括扩展函数， 该 类会编译成一个名为 org.foo.bar.ExampleKt 的 Java 类的静态方法。<br>首先，新建一个ExampleKt.kt的文件，并新建一个bar函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package demo</div><div class="line">class Foo</div><div class="line">fun bar()&#123;</div><div class="line">    println(&quot;这只是一个bar方法&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在Java中调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">package demo;</div><div class="line"></div><div class="line">public class Example &#123;</div><div class="line">    public static void main(String[]args)&#123;</div><div class="line">        demo.ExampleKtKt.bar();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，可以使用@JvmName注解修改所生成的Java类的类名。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@file:JvmName(&quot;Demo&quot;)</div><div class="line">package demo</div></pre></td></tr></table></figure>
<p>那么在Java调用时就需要修改类名。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Example &#123;</div><div class="line">    public static void main(String[]args)&#123;</div><div class="line">        demo.Demo.bar();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在多个文件中生成相同的Java类名（包名相同并且类名相同或者有相同的@JvmName注解）通常是错误的。然而，编译器能够生成一个单一的Java外观类，它具有指定的名称且包含来自于所有文件中具有该名称的所有声明。要生成这样的外观，请在所有的相关文件中使用@JvmMultifileClass注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@file:JvmName(&quot;example&quot;)</div><div class="line">@file:JvmMultifileClass</div><div class="line">package demo</div></pre></td></tr></table></figure>
<h2 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h2><p>如果需要在Java中将Kotlin属性作为字段暴露，那么就需要使用@JvmField注解对其进行标注。使用@JvmField注解标注后，该字段将具有与底层属性相同的可见性。如果一个属性有幕后字段（Backing Field）、非私有的、没有open/override或者const修饰符，并且不是被委托的属性，那么可以使用@JvmField注解该属性。</p>
<p>首先，新建一个kt类，并添加如下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class C(id: String) &#123;</div><div class="line">    @JvmField val ID = id</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在Java中调用该代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class JavaClient &#123;</div><div class="line">    public String getID(C c) &#123;</div><div class="line">        return c.ID;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>延迟初始化的属性（在Java中）也会暴露为字段， 该字段的可见性与 lateinit 属性的 setter 相同。</p>
<h2 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h2><p>在命名对象或伴生对象时，声明的 Kotlin 属性会在该命名对象或包含伴生对象的类中包含静态幕后字段。通常这些字段是私有的，但可以通过以下方式之一暴露出来。</p>
<ul>
<li>@JvmField 注解；</li>
<li>lateinit 修饰符；</li>
<li>const 修饰符。</li>
</ul>
<p>使用 @JvmField 标注的属性，可以使其成为与属性本身具有相同可见性的静态字段。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Key(val value: Int) &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField</div><div class="line">        val COMPARATOR: Comparator&lt;Key&gt; = compareBy&lt;Key&gt; &#123; it.value &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在Java代码中调用属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Key.COMPARATOR.compare(key1, key2);</div><div class="line">// Key 类中的 public static final 字段</div></pre></td></tr></table></figure>
<p>在命名对象或者伴生对象中的一个延迟初始化的属性具有与属性 setter 相同可见性的静态幕后字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object Singleton &#123;</div><div class="line">    lateinit var provider: Provider</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在Java中使用该字段的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">Singleton.provider = new Provider();</div><div class="line">// 在 Singleton 类中的 public static 非-final 字段</div></pre></td></tr></table></figure>
<p>用 const 标注的（在类中以及在顶层的）属性在 Java 中会成为静态字段，首先新建一个kt文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object Obj &#123;</div><div class="line">    const val CONST = 1</div><div class="line">&#125;</div><div class="line">class C &#123;</div><div class="line">    companion object &#123;</div><div class="line">        const val VERSION = 9</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">const val MAX = 239</div></pre></td></tr></table></figure>
<p>然后，在Java中可以直接调用该属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int c = Obj.CONST;</div><div class="line">int d = ExampleKt.MAX;</div><div class="line">int v = C.VERSION;</div></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>Kotlin将包级函数表示为静态方法。如果对这些函数使用@JvmStatic进行标注，那么Kotlin还可以为在命名对象或伴生对象中定义的函数生成静态方法。如果使用该注解，那么编译器既会在相应对象的类中生成静态方法，也会在对象自身中生成实例方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmStatic fun foo() &#123;&#125;</div><div class="line">        fun bar() &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，foo()在Java中是静态的，而bar()不是静态的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C.foo(); // 正确</div><div class="line">C.bar(); // 错误：不是一个静态方法</div><div class="line">C.Companion.foo(); // 保留实例方法</div><div class="line">C.Companion.bar(); // 唯一的工作方式</div></pre></td></tr></table></figure>
<p>对于命名对象，也存在同样的规律。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">object Obj &#123;</div><div class="line">    @JvmStatic fun foo() &#123;&#125;</div><div class="line">    fun bar() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Java 中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Obj.foo(); // 没问题</div><div class="line">Obj.bar(); // 错误</div><div class="line">Obj.INSTANCE.bar(); // 没问题，通过单例实例调用</div><div class="line">Obj.INSTANCE.foo(); // 也没问题</div></pre></td></tr></table></figure>
<p>@JvmStatic　注解也可以应用于对象或伴生对象的属性， 使其 getter 和 setter 方法在该对象或包含该伴生对象的类中是静态成员。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Kotlin的可见性以下列方式映射到Java代码中。</p>
<ul>
<li>private 成员编译成 private 成员；</li>
<li>private 的顶层声明编译成包级局部声明；</li>
<li>protected 保持 protected（注意 Java 允许访问同一个包中其他类的受保护成员， 而 Kotlin 不能，所以Java 类会访问更广泛的代码）；</li>
<li>internal 声明会成为 Java 中的 public。internal 类的成员会通过名字修饰，使其更难以在 Java 中意外使用到，并且根据 Kotlin 规则使其允许重载相同签名的成员而互不可见；</li>
<li>public 保持 public。</li>
</ul>
<h2 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h2><p>有时你需要调用有 KClass 类型参数的 Kotlin 方法。 因为没有从 Class 到 KClass 的自动转换，所以你必须通过调用 Class<t>.kotlin 扩展属性的等价形式来手动进行转换。例如：</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)</div></pre></td></tr></table></figure>
<h2 id="签名冲突"><a href="#签名冲突" class="headerlink" title="签名冲突"></a>签名冲突</h2><p>有时我们想让一个 Kotlin 中的命名函数在字节码中有另外一个 JVM 名称，最突出的例子是由于类型擦除引发的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun List&lt;String&gt;.filterValid(): List&lt;String&gt;</div><div class="line">fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</div></pre></td></tr></table></figure>
<p>这两个函数不能同时定义在一个类中，因为它们的 JVM 签名是一样的。如果我们真的希望它们在 Kotlin 中使用相同的名称，可以使用 @JvmName 去标注其中的一个（或两个），并指定不同的名称作为参数。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun List&lt;String&gt;.filterValid(): List&lt;String&gt;</div><div class="line">@JvmName(&quot;filterValidInt&quot;)</div><div class="line">fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</div></pre></td></tr></table></figure>
<p>在 Kotlin 中它们可以用相同的名称 filterValid 来访问，而在 Java 中，它们分别是 filterValid 和 filterValidInt。同样的技巧也适用于属性中。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val x: Int</div><div class="line">    @JvmName(&quot;getX_prop&quot;)</div><div class="line">    get() = 15</div><div class="line"></div><div class="line">fun getX() = 10</div></pre></td></tr></table></figure>
<h2 id="生成重载"><a href="#生成重载" class="headerlink" title="生成重载"></a>生成重载</h2><p>通常，如果你写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见，如果希望向 Java 调用者暴露多个重载，可以使用 @JvmOverloads 注解。该注解可以用于构造函数、静态方法中，但不能用于抽象方法和在接口中定义的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Foo @JvmOverloads constructor(x: Int, y: Double = 0.0) &#123;</div><div class="line">    @JvmOverloads fun f(a: String, b: Int = 0, c: String = &quot;abc&quot;) &#123;</div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉。在上例中，会生成以下代码 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 构造函数：</div><div class="line">Foo(int x, double y)</div><div class="line">Foo(int x)</div><div class="line"></div><div class="line">// 方法</div><div class="line">void f(String a, int b, String c) &#123; &#125;</div><div class="line">void f(String a, int b) &#123; &#125;</div><div class="line">void f(String a) &#123; &#125;</div></pre></td></tr></table></figure>
<p><strong>请注意</strong>，如次构造函数中所述，如果一个类的所有构造函数参数都有默认值，那么会为其生成一个公有的无参构造函数，此时就算没有 @JvmOverloads 注解也有效。</p>
<h2 id="受检异常"><a href="#受检异常" class="headerlink" title="受检异常"></a>受检异常</h2><p>如上所述，Kotlin 没有受检异常。 所以，通常 Kotlin 函数的 Java 签名不会声明抛出异常， 于是如果我们有一个这样的 Kotlin 函数。首先，新建一个kt文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//// example.kt</div><div class="line">package demo</div><div class="line">fun foo() &#123;</div><div class="line">    throw IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，在 Java 中调用它的时候，需要使用try{}catch{}来捕捉这个异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">try &#123;</div><div class="line">  demo.Example.foo();</div><div class="line">&#125;</div><div class="line">catch (IOException e) &#123; // 错误：foo() 未在 throws 列表中声明 IOException</div><div class="line">  // ……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 foo() 没有声明 IOException，我们从 Java 编译器得到了一个报错消息。 为了解决这个问题，要在 Kotlin 中使用 @Throws 注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Throws(IOException::class)</div><div class="line">fun foo() &#123;</div><div class="line">    throw IOException()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="空安全性"><a href="#空安全性" class="headerlink" title="空安全性"></a>空安全性</h2><p>当从Java中调用Kotlin函数时，没有任何方法可以阻止Kotlin中的空值传入。Kotlin在JVM虚拟机中运行时会检查所有的公共函数，可以检查非空值，这时候就可以通过NullPointerException得到Java中的非空值代码。</p>
<p>##型变的泛型<br>当 Kotlin 的类使用了声明处型变时，可以通过两种方式从Java代码中看到它们的用法。让我们假设我们有以下类和两个使用它的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Box&lt;out T&gt;(val value: T)</div><div class="line"></div><div class="line">interface Base</div><div class="line">class Derived : Base</div><div class="line"></div><div class="line">fun boxDerived(value: Derived): Box&lt;Derived&gt; = Box(value)</div><div class="line">fun unboxBase(box: Box&lt;Base&gt;): Base = box.value</div></pre></td></tr></table></figure>
<p>将这两个函数转换成Java代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div><div class="line">Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure>
<p>问题是，在 Kotlin 中我们可以这样写 unboxBase(boxDerived(“s”))，但是在 Java 中是行不通的，因为在 Java 中类 Box 在其泛型参数 T 上是不型变的，于是 Box<derived> 并不是 Box<base> 的子类。 要使其在 Java 中工作，我们按以下这样定义 unboxBase。</derived></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure>
<p>这里我们使用 Java 的通配符类型（? extends Base）来通过使用处型变来模拟声明处型变，因为在 Java 中只能这样。</p>
<p>当它作为参数出现时，为了让 Kotlin 的 API 在 Java 中工作，对于协变定义的 Box 我们生成 Box<super> 作为 Box&lt;? extends Super&gt; （或者对于逆变定义的 Foo 生成 Foo&lt;? super Bar&gt;）。当它是一个返回值时， 我们不生成通配符，因为否则 Java 客户端将必须处理它们（并且它违反常用 Java 编码风格）。因此，我们的示例中的对应函数实际上翻译如下：</super></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 作为返回类型——没有通配符</div><div class="line">Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div><div class="line"> </div><div class="line">// 作为参数——有通配符</div><div class="line">Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：当参数类型是 final 时，生成通配符通常没有意义，所以无论在什么地方 Box<string> 始终转换为 Box<string>。如果我们在默认不生成通配符的地方需要通配符，我们可以使用 @JvmWildcard 注解：</string></string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun boxDerived(value: Derived): Box&lt;@JvmWildcard Derived&gt; = Box(value)</div><div class="line">// 将被转换成</div><div class="line">// Box&lt;? extends Derived&gt; boxDerived(Derived value) &#123; …… &#125;</div></pre></td></tr></table></figure>
<p>另一方面，如果我们根本不需要默认的通配符转换，我们可以使用@JvmSuppressWildcards。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun unboxBase(box: Box&lt;@JvmSuppressWildcards Base&gt;): Base = box.value</div><div class="line">// 会翻译成</div><div class="line">// Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125;</div></pre></td></tr></table></figure>
<p>注意：@JvmSuppressWildcards 不仅可用于单个类型参数，还可用于整个声明（如函数或类），从而抑制其中的所有通配符。</p>
<h2 id="Nothing-类型"><a href="#Nothing-类型" class="headerlink" title="Nothing 类型"></a>Nothing 类型</h2><p>类型 Nothing 是特殊的，因为它在 Java 中没有自然的对应。确实，每个 Java 引用类型，包括 java.lang.Void 都可以接受 null 值，但是 Nothing 不行，以为这种类型不能在 Java 中被准确表示。这就是为什么在使用 Nothing 参数的地方 Kotlin 生成一个原始类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun emptyList(): List&lt;Nothing&gt; = listOf()</div><div class="line">// 会翻译成</div><div class="line">// List emptyList() &#123; …… &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互操作就是在Kotlin中可以调用其他编程语言的接口，只要它们开放了接口，Kotlin就可以调用其成员属性和成员方法，这是其他编程语言所无法比拟的。同时，在进行Java编程时也可以调用Kotlin中的API接口。&lt;/p&gt;
&lt;h1 id=&quot;Kotlin调用Java&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://www.xiangzhihong.com/tags/Kotlin/"/>
    
  </entry>
  
</feed>
