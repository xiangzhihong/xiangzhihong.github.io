<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="向志洪">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://www.xiangzhihong.com">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>iOS 组件化之路由设计思路分析 | 向志洪</title>


    <link rel="alternate" href="/atom.xml" title="向志洪" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css?rev=3.3.4">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    <div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>
    
</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header" style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner2.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="">
            <img src="/img/avatar.jpg" alt="logo头像">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题">  
             
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only">Toggle navigation</span>
                    <i class="fa fa-bars"></i>
                    </span>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation"><a href="/"><i class="fa fa-fw"></i>首页</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/前端/"><i class="fa fa-fw"></i>前端</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/后端/"><i class="fa fa-fw"></i>后端</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/工具/"><i class="fa fa-fw"></i>工具</a>
                            </li>
                        
                            <li role="presentation"><a href="/categories/资源/"><i class="fa fa-fw"></i>资源</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="iOS 组件化之路由设计思路分析">
            
	            iOS 组件化之路由设计思路分析
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/iOS">
            iOS
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a href="/tags/iOS">
               iOS
            </a>
            
        </span>
    </span>
    
    	
	
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">2016/06/25</span>
    </span>
	
	<span id="busuanzi_container_page_pv"> 阅读量<span id="busuanzi_value_page_pv"></span>次</span>
	
	
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>629</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着用户的需求越来越多，对App的用户体验也变的要求越来越高。为了更好的应对各种需求，开发人员从软件工程的角度，将App架构由原来简单的MVC变成MVVM，VIPER等复杂架构。更换适合业务的架构，是为了后期能更好的维护项目。</p>
<p>但是用户依旧不满意，继续对开发人员提出了更多更高的要求，不仅需要高质量的用户体验，还要求快速迭代，最好一天出一个新功能，而且用户还要求不更新就能体验到新功能。为了满足用户需求，于是开发人员就用H5，ReactNative，Weex等技术对已有的项目进行改造。项目架构也变得更加的复杂，纵向的会进行分层，网络层，UI层，数据持久层。每一层横向的也会根据业务进行组件化。尽管这样做了以后会让开发更加有效率，更加好维护，但是如何解耦各层，解耦各个界面和各个组件，降低各个组件之间的耦合度，如何能让整个系统不管多么复杂的情况下都能保持“高内聚，低耦合”的特点？这一系列的问题都摆在开发人员面前，亟待解决。今天就来谈谈解决这个问题的一些思路。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>1.引子</li>
<li>2.App路由能解决哪些问题</li>
<li>3.App之间跳转实现</li>
<li>4.App内组件间路由设计</li>
<li>5.各个方案优缺点</li>
<li>6.最好的方案</li>
</ul>
<h3 id="一-引子"><a href="#一-引子" class="headerlink" title="一. 引子"></a>一. 引子</h3><p>大前端发展这么多年了，相信也一定会遇到相似的问题。近两年SPA发展极其迅猛，React 和 Vue一直处于风口浪尖，那我们就看看他们是如何处理好这一问题的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-4fa5a120089e0580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在SPA单页面应用，路由起到了很关键的作用。路由的作用主要是保证视图和 URL 的同步。在前端的眼里看来，视图是被看成是资源的一种表现。当用户在页面中进行操作时，应用会在若干个交互状态中切换，路由则可以记录下某些重要的状态，比如用户查看一个网站，用户是否登录、在访问网站的哪一个页面。而这些变化同样会被记录在浏览器的历史中，用户可以通过浏览器的前进、后退按钮切换状态。总的来说，用户可以通过手动输入或者与页面进行交互来改变 URL，然后通过同步或者异步的方式向服务端发送请求获取资源，成功后重新绘制 UI，原理如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-012b64699f6d1222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p> react-router通过传入的location到最终渲染新的UI，流程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7868710ba2a1d637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>location的来源有2种，一种是浏览器的回退和前进，另外一种是直接点了一个链接。新的 location 对象后，路由内部的 matchRoutes 方法会匹配出 Route 组件树中与当前 location 对象匹配的一个子集，并且得到了 nextState，在this.setState(nextState) 时就可以实现重新渲染 Router 组件。</p>
<p>大前端的做法大概是这样的，我们可以把这些思想借鉴到iOS这边来。上图中的Back / Forward 在iOS这边很多情况下都可以被UINavgation所管理。所以iOS的Router主要处理绿色的那一块。</p>
<h3 id="二-App路由能解决哪些问题"><a href="#二-App路由能解决哪些问题" class="headerlink" title="二. App路由能解决哪些问题"></a>二. App路由能解决哪些问题</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-3626c70bc97e0547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>既然前端能在SPA上解决URL和UI的同步问题，那这种思想可以在App上解决哪些问题呢？</p>
<p>思考如下的问题，平时我们开发中是如何优雅的解决的：</p>
<p>1.3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。</p>
<p>比如微信的3D-Touch可以直接跳转到“我的二维码”。“我的二维码”界面在我的里面的第三级界面。或者再极端一点，产品需求给了更加变态的需求，要求跳转到App内部第十层的界面，怎么处理？</p>
<p>2.自家的一系列App之间如何相互跳转？</p>
<p>如果自己App有几个，相互之间还想相互跳转，怎么处理？</p>
<p>3.如何解除App组件之间和App页面之间的耦合性？</p>
<p>随着项目越来越复杂，各个组件，各个页面之间的跳转逻辑关联性越来越多，如何能优雅的解除各个组件和页面之间的耦合性？</p>
<p>4.如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？</p>
<p>项目里面某些模块会混合ReactNative，Weex，H5界面，这些界面还会调用Native的界面，以及Native的组件。那么，如何能统一Web端和Native端请求资源的方式？</p>
<p>5.如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？</p>
<p>6.如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？</p>
<p>比如App上线突然遇到了紧急bug，能否把页面动态降级成H5，ReactNative，Weex？或者是直接换成一个本地的错误界面？</p>
<p>7.如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？</p>
<p>8.如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？</p>
<p>9.如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？</p>
<p>比如App出现问题了，用户可能在任何界面，如何随时随地的让用户强制登出？或者强制都跳转到同一个本地的error界面？或者跳转到相应的H5，ReactNative，Weex界面？如何让用户在任何界面，随时随地的弹出一个View ？</p>
<p>以上这些问题其实都可以通过在App端设计一个路由来解决。那么我们怎么设计一个路由呢？</p>
<h3 id="三-App之间跳转实现"><a href="#三-App之间跳转实现" class="headerlink" title="三. App之间跳转实现"></a>三. App之间跳转实现</h3><p>在谈App内部的路由之前，先来谈谈在iOS系统间，不同App之间是怎么实现跳转的。</p>
<h4 id="1-URL-Scheme方式"><a href="#1-URL-Scheme方式" class="headerlink" title="1. URL Scheme方式"></a>1. URL Scheme方式</h4><p>iOS系统是默认支持URL Scheme的，具体见<a href="https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899" target="_blank" rel="external">官方文档</a>。</p>
<p>比如说，在iPhone的Safari浏览器上面输入如下的命令，会自动打开一些App：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 打开邮箱</span></div><div class="line">mailto:<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="comment">// 给110拨打电话</span></div><div class="line">tel:<span class="comment">//110</span></div></pre></td></tr></table></figure>
<p>在iOS 9 之前只要在App的info.plist里面添加URL types - URL Schemes，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-f76be42afc25b764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里就添加了一个com.ios.Qhomer的Scheme。这样就可以在iPhone的Safari浏览器上面输入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">com.ios.Qhomer:<span class="comment">//</span></div></pre></td></tr></table></figure>
<p>就可以直接打开这个App了。</p>
<p>关于其他一些常见的App，可以从iTunes里面下载到它的ipa文件，解压，显示包内容里面可以找到info.plist文件，打开它，在里面就可以相应的URL Scheme。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 手机QQ</span></div><div class="line">mqq:<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="comment">// 微信</span></div><div class="line">weixin:<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="comment">// 新浪微博</span></div><div class="line">sinaweibo:<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="comment">// 饿了么</span></div><div class="line">eleme:<span class="comment">//</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7bf9d12f40e43505.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当然了，某些App对于调用URL Scheme比较敏感，它们不希望其他的App随意的就调用自己。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</div><div class="line">            openURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">  sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication</div><div class="line">         annotation:(<span class="keyword">id</span>)annotation</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"sourceApplication: %@"</span>, sourceApplication);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"URL scheme:%@"</span>, [url scheme]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"URL query: %@"</span>, [url query]);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([sourceApplication isEqualToString:<span class="string">@"com.tencent.weixin"</span>])&#123;</div><div class="line">        <span class="comment">// 允许打开</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果待调用的App已经运行了，那么它的生命周期如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-a36c3d174d449288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果待调用的App在后台，那么它的生命周期如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-389be7fe4279db76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>明白了上面的生命周期之后，我们就可以通过调用<a href="https://developer.apple.com/reference/uikit/uiapplicationdelegate/1623073-application" target="_blank" rel="external">application:openURL:sourceApplication:annotation:</a>这个方法，来阻止一些App的随意调用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-92cfad91592aa7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-e71403244460b5de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如上图，饿了么App允许通过URL Scheme调用，那么我们可以在Safari里面调用到饿了么App。手机QQ不允许调用，我们在Safari里面也就没法跳转过去。</p>
<p>关于App间的跳转问题，感兴趣的可以查看官方文档<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW2" target="_blank" rel="external">Inter-App Communication</a>。</p>
<p>App也是可以直接跳转到系统设置的。比如有些需求要求检测用户有没有开启某些系统权限，如果没有开启就弹框提示，点击弹框的按钮直接跳转到系统设置里面对应的设置界面。</p>
<p><a href="https://www.zhihu.com/question/50635906/answer/125195317" target="_blank" rel="external">iOS 10 支持通过 URL Scheme 跳转到系统设置</a><br><a href="http://www.jianshu.com/p/bb3f42fdbc31" target="_blank" rel="external">iOS10跳转系统设置的正确姿势</a><br><a href="http://www.jianshu.com/p/32ca4bcda3d1" target="_blank" rel="external">关于 iOS 系统功能的 URL 汇总列表</a></p>
<h4 id="2-Universal-Links方式"><a href="#2-Universal-Links方式" class="headerlink" title="2. Universal Links方式"></a>2. Universal Links方式</h4><p>虽然在微信内部开网页会禁止所有的Scheme，但是iOS 9.0新增加了一项功能是Universal Links，使用这个功能可以使我们的App通过HTTP链接来启动App。<br>1.如果安装过App，不管在微信里面http链接还是在Safari浏览器，还是其他第三方浏览器，都可以打开App。<br>2.如果没有安装过App，就会打开网页。</p>
<p>具体设置需要3步：</p>
<p>1.App需要开启Associated Domains服务，并设置Domains，注意必须要applinks：开头。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-9d373eb510316c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>2.域名必须要支持HTTPS。</p>
<p>3.上传内容是Json格式的文件，文件名为apple-app-site-association到自己域名的根目录下，或者.well-known目录下。iOS自动会去读取这个文件。具体的文件内容请查看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html" target="_blank" rel="external">官方文档</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2d1b91f5fcb619cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如果App支持了Universal Links方式，那么可以在其他App里面直接跳转到我们自己的App里面。如下图，点击链接，由于该链接会Matcher到我们设置的链接，所以菜单里面会显示用我们的App打开。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-9e8a7004389c7a53.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在浏览器里面也是一样的效果，如果是支持了Universal Links方式，访问相应的URL，会有不同的效果。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-69233d229be05d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>以上就是iOS系统中App间跳转的二种方式。</p>
<p>从iOS 系统里面支持的URL Scheme方式，我们可以看出，对于一个资源的访问，苹果也是用URI的方式来访问的。</p>
<blockquote>
<p><strong>统一资源标识符</strong>（英语：Uniform Resource Identifier，或<strong>URI</strong>)是一个用于<a href="https://zh.wikipedia.org/wiki/%E6%A0%87%E8%AF%86" target="_blank" rel="external">标识</a>某一<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91" target="_blank" rel="external">互联网</a><a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%BA%90" target="_blank" rel="external">资源</a>名称的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="external">字符串</a>。 该种标识允许用户对网络中（一般指<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="external">万维网</a>）的资源通过特定的<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">协议</a>进行交互操作。URI的最常见的形式是<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">统一资源定位符</a>（URL）。</p>
</blockquote>
<p>举个例子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-59139927a45ec117.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这是一段URI，每一段都代表了对应的含义。对方接收到了这样一串字符串，按照规则解析出来，就能获取到所有的有用信息。</p>
<p>这个能给我们设计App组件间的路由带来一些思路么？如果我们想要定义一个三端（iOS，Android，H5）的统一访问资源的方式，能用URI的这种方式实现么？</p>
<h3 id="四-App内组件间路由设计"><a href="#四-App内组件间路由设计" class="headerlink" title="四. App内组件间路由设计"></a>四. App内组件间路由设计</h3><p>上一章节中我们介绍了iOS系统中，系统是如何帮我们处理App间跳转逻辑的。这一章节我们着重讨论一下，App内部，各个组件之间的路由应该怎么设计。关于App内部的路由设计，主要需要解决2个问题：</p>
<p>1.各个页面和组件之间的跳转问题。<br>2.各个组件之间相互调用。</p>
<p>先来分析一下这两个问题。</p>
<h4 id="1-关于页面跳转"><a href="#1-关于页面跳转" class="headerlink" title="1. 关于页面跳转"></a>1. 关于页面跳转</h4><p><img src="http://upload-images.jianshu.io/upload_images/1194012-1f01e4fc2f9a6e23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-35db9020069ee57b.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子：</p>
<p>假设一个按钮的执行逻辑都封装成了command。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  @weakify(self);</div><div class="line">  [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:^(id x) &#123;</div><div class="line">      @strongify(self);</div><div class="line">      // 跳转逻辑</div><div class="line">      [self.navigationController pushViewController:targetViewController animated:YES];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上述的代码本身没啥问题，但是可能会弱化MVVM框架的一个重要作用。</p>
<p>MVVM框架的目的除去解耦以外，还有2个很重要的目的：</p>
<ol>
<li>代码高复用率</li>
<li>方便进行单元测试</li>
</ol>
<p>如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。</p>
<p>页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。</p>
<p>把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看<a href="https://github.com/LPD-iOS/lpd-mvvm-kit" target="_blank" rel="external">lpd-mvvm-kit</a>这个库关于页面跳转的具体实现。</p>
<p>页面跳转相互的耦合性也就体现出来了：</p>
<p>1.由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。<br>2.由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。<br>3.推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。</p>
<h4 id="2-关于组件间调用"><a href="#2-关于组件间调用" class="headerlink" title="2. 关于组件间调用"></a>2. 关于组件间调用</h4><p><img src="http://upload-images.jianshu.io/upload_images/1194012-03b4d15460bb7449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。</p>
<h4 id="3-如何设计一个路由"><a href="#3-如何设计一个路由" class="headerlink" title="3. 如何设计一个路由"></a>3. 如何设计一个路由</h4><p>如何设计一个能完美解决上述2个问题的路由，让我们先来看看GitHub上优秀开源库的设计思路。以下是我从Github上面找的一些路由方案，按照Star从高到低排列。依次来分析一下它们各自的设计思路。</p>
<h4 id="（1）JLRoutes-Star-3189"><a href="#（1）JLRoutes-Star-3189" class="headerlink" title="（1）JLRoutes Star 3189"></a>（1）<strong><a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="external">JLRoutes</a></strong> Star 3189</h4><p>JLRoutes在整个Github上面Star最多，那就来从它来分析分析它的具体设计思路。</p>
<p>首先JLRoutes是受URL Scheme思路的影响。它把所有对资源的请求看成是一个URI。</p>
<p>首先来熟悉一下NSURLComponent的各个字段：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c1e6a1e29dc04850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>Note<br>The URLs employed by the NSURL<br> class are described in <a href="https://tools.ietf.org/html/rfc1808" target="_blank" rel="external">RFC 1808</a>, <a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="external">RFC 1738</a>, and <a href="https://tools.ietf.org/html/rfc2732" target="_blank" rel="external">RFC 2732</a>.</p>
</blockquote>
<p>JLRoutes会传入每个字符串，都按照上面的样子进行切分处理，分别根据RFC的标准定义，取到各个NSURLComponent。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-37f83ac95de14c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。</p>
<p>至于为何有这么多条路由，笔者认为，如果路由按照业务线进行划分的话，每个业务线可能会有不相同的逻辑，即使每个业务里面的组件名字可能相同，但是由于业务线不同，会有不同的路由规则。</p>
<p>举个例子：如果滴滴按照每个城市的打车业务进行组件化拆分，那么每个城市就对应着这里的每个scheme。每个城市的打车业务都有叫车，付款……等业务，但是由于每个城市的地方法规不相同，所以这些组件即使名字相同，但是里面的功能也许千差万别。所以这里划分出了多个route，也可以理解为不同的命名空间。</p>
<p>在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。</p>
<p>在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)_registerRoute:(<span class="built_in">NSString</span> *)routePattern priority:(<span class="built_in">NSUInteger</span>)priority handler:(<span class="built_in">BOOL</span> (^)(<span class="built_in">NSDictionary</span> *parameters))handlerBlock</div><div class="line">&#123;</div><div class="line">    JLRRouteDefinition *route = [[JLRRouteDefinition alloc] initWithScheme:<span class="keyword">self</span>.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (priority == <span class="number">0</span> || <span class="keyword">self</span>.routes.count == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span>.routes addObject:route];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</div><div class="line">        <span class="built_in">BOOL</span> addedRoute = <span class="literal">NO</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 找到当前已经存在的一条优先级比当前待插入的路由低的路由</span></div><div class="line">        <span class="keyword">for</span> (JLRRouteDefinition *existingRoute <span class="keyword">in</span> [<span class="keyword">self</span>.routes <span class="keyword">copy</span>]) &#123;</div><div class="line">            <span class="keyword">if</span> (existingRoute.priority &lt; priority) &#123;</div><div class="line">                <span class="comment">// 如果找到，就插入数组</span></div><div class="line">                [<span class="keyword">self</span>.routes insertObject:route atIndex:index];</div><div class="line">                addedRoute = <span class="literal">YES</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。</span></div><div class="line">        <span class="keyword">if</span> (!addedRoute) &#123;</div><div class="line">            [<span class="keyword">self</span>.routes addObject:route];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。</p>
<p>具体查找路由的过程如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5b4e7c887c48cce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)_routeURL:(<span class="built_in">NSURL</span> *)URL withParameters:(<span class="built_in">NSDictionary</span> *)parameters executeRouteBlock:(<span class="built_in">BOOL</span>)executeRouteBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!URL) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> _verboseLog:<span class="string">@"Trying to route URL %@"</span>, URL];</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> didRoute = <span class="literal">NO</span>;</div><div class="line">    JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (JLRRouteDefinition *route <span class="keyword">in</span> [<span class="keyword">self</span>.routes <span class="keyword">copy</span>]) &#123;</div><div class="line">        <span class="comment">// 检查每一个route，生成对应的response</span></div><div class="line">        JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols];</div><div class="line">        <span class="keyword">if</span> (!response.isMatch) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@"Successfully matched %@"</span>, route];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!executeRouteBlock) &#123;</div><div class="line">            <span class="comment">// 如果我们被要求不允许执行，但是又找了匹配的路由response。</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 装配最后的参数</span></div><div class="line">        <span class="built_in">NSMutableDictionary</span> *finalParameters = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        [finalParameters addEntriesFromDictionary:response.parameters];</div><div class="line">        [finalParameters addEntriesFromDictionary:parameters];</div><div class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@"Final parameters are %@"</span>, finalParameters];</div><div class="line">        </div><div class="line">        didRoute = [route callHandlerBlockWithParameters:finalParameters];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (didRoute) &#123;</div><div class="line">            <span class="comment">// 调用Handler成功</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!didRoute) &#123;</div><div class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@"Could not find a matching route"</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。</span></div><div class="line">    <span class="keyword">if</span> (!didRoute &amp;&amp; <span class="keyword">self</span>.shouldFallbackToGlobalRoutes &amp;&amp; ![<span class="keyword">self</span> _isGlobalRoutesController]) &#123;</div><div class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@"Falling back to global routes..."</span>];</div><div class="line">        didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>, after everything, we did not route anything and we have an unmatched URL handler, then call it</div><div class="line">    <span class="keyword">if</span> (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; <span class="keyword">self</span>.unmatchedURLHandler) &#123;</div><div class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@"Falling back to the unmatched URL handler"</span>];</div><div class="line">        <span class="keyword">self</span>.unmatchedURLHandler(<span class="keyword">self</span>, URL, parameters);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> didRoute;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p>我们先注册一个Router，规则如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[[JLRoutes globalRoutes] addRoute:<span class="string">@"/:object/:action"</span> handler:^<span class="built_in">BOOL</span>(<span class="built_in">NSDictionary</span> *parameters) &#123;</div><div class="line">  <span class="built_in">NSString</span> *object = parameters[<span class="string">@"object"</span>];</div><div class="line">  <span class="built_in">NSString</span> *action = parameters[<span class="string">@"action"</span>];</div><div class="line">  <span class="comment">// stuff</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>我们传入一个URL，让Router进行处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *editPost = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"ele://post/halfrost?debug=true&amp;foo=bar"</span>];</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] openURL:editPost];</div></pre></td></tr></table></figure>
<p>匹配成功之后，我们会得到下面这样一个字典：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="string">"object"</span>: <span class="string">"post"</span>,</div><div class="line">  <span class="string">"action"</span>: <span class="string">"halfrost"</span>,</div><div class="line">  <span class="string">"debug"</span>: <span class="string">"true"</span>,</div><div class="line">  <span class="string">"foo"</span>: <span class="string">"bar"</span>,</div><div class="line">  <span class="string">"JLRouteURL"</span>: <span class="string">"ele://post/halfrost?debug=true&amp;foo=bar"</span>,</div><div class="line">  <span class="string">"JLRoutePattern"</span>: <span class="string">"/:object/:action"</span>,</div><div class="line">  <span class="string">"JLRouteScheme"</span>: <span class="string">"JLRoutesGlobalRoutesScheme"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把上述过程图解出来，见下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-499ad0d66da3a745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/the(/foo/:a)(/bar/:b)</div></pre></td></tr></table></figure>
<p>JLRoutes 会帮我们默认注册如下4条路由规则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/the/foo/:a/bar/:b</div><div class="line">/the/foo/:a</div><div class="line">/the/bar/:b</div><div class="line">/the</div></pre></td></tr></table></figure>
<h4 id="（2）routable-ios-Star-1415"><a href="#（2）routable-ios-Star-1415" class="headerlink" title="（2）routable-ios Star 1415"></a>（2）<strong><a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a></strong> Star 1415</h4><p>Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在<a href="https://github.com/usepropeller/routable-android" target="_blank" rel="external">Android</a>上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-0543112d4d3bda48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>UPRouter里面保存了2个字典。routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (RouterParams *)routerParamsForUrl:(<span class="built_in">NSString</span> *)url extraParams: (<span class="built_in">NSDictionary</span> *)extraParams &#123;</div><div class="line">    <span class="keyword">if</span> (!url) &#123;</div><div class="line">        <span class="comment">//if we wait, caching this as key would throw an exception</span></div><div class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"RouteNotFoundException"</span></div><div class="line">                                       reason:[<span class="built_in">NSString</span> stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]</div><div class="line">                                     userInfo:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.cachedRoutes objectForKey:url];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">// 比对url通过/分割之后的参数个数和pathComponents的个数是否一样</span></div><div class="line">    <span class="built_in">NSArray</span> *givenParts = url.pathComponents;</div><div class="line">    <span class="built_in">NSArray</span> *legacyParts = [url componentsSeparatedByString:<span class="string">@"/"</span>];</div><div class="line">    <span class="keyword">if</span> ([legacyParts count] != [givenParts count]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release"</span>, url);</div><div class="line">        givenParts = legacyParts;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block RouterParams *openParams = <span class="literal">nil</span>;</div><div class="line">    [<span class="keyword">self</span>.routes enumerateKeysAndObjectsUsingBlock:</div><div class="line">     ^(<span class="built_in">NSString</span> *routerUrl, UPRouterOptions *routerOptions, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">         </div><div class="line">         <span class="built_in">NSArray</span> *routerParts = [routerUrl pathComponents];</div><div class="line">         <span class="keyword">if</span> ([routerParts count] == [givenParts count]) &#123;</div><div class="line">             </div><div class="line">             <span class="built_in">NSDictionary</span> *givenParams = [<span class="keyword">self</span> paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</div><div class="line">             <span class="keyword">if</span> (givenParams) &#123;</div><div class="line">                 openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</div><div class="line">                 *stop = <span class="literal">YES</span>;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!openParams) &#123;</div><div class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"RouteNotFoundException"</span></div><div class="line">                                       reason:[<span class="built_in">NSString</span> stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]</div><div class="line">                                     userInfo:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.cachedRoutes setObject:openParams forKey:url];</div><div class="line">    <span class="keyword">return</span> openParams;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSDictionary</span> *)paramsForUrlComponents:(<span class="built_in">NSArray</span> *)givenUrlComponents routerUrlComponents:(<span class="built_in">NSArray</span> *)routerUrlComponents &#123;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    [routerUrlComponents enumerateObjectsUsingBlock:</div><div class="line">     ^(<span class="built_in">NSString</span> *routerComponent, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">         </div><div class="line">         <span class="built_in">NSString</span> *givenComponent = givenUrlComponents[idx];</div><div class="line">         <span class="keyword">if</span> ([routerComponent hasPrefix:<span class="string">@":"</span>]) &#123;</div><div class="line">             <span class="built_in">NSString</span> *key = [routerComponent substringFromIndex:<span class="number">1</span>];</div><div class="line">             [params setObject:givenComponent forKey:key];</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (![routerComponent isEqualToString:givenComponent]) &#123;</div><div class="line">             params = <span class="literal">nil</span>;</div><div class="line">             *stop = <span class="literal">YES</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;];</div><div class="line">    <span class="keyword">return</span> params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"> <span class="built_in">NSDictionary</span> *givenParams = [<span class="keyword">self</span> paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</div><div class="line"><span class="keyword">if</span> (givenParams) &#123;</div><div class="line">       openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</div><div class="line">       *stop = <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有<br>routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="keyword">self</span>.cachedRoutes setObject:openParams forKey:url];</div></pre></td></tr></table></figure>
<p>最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-1a44ce14af0e084a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后将匹配封装出来的RouterParams转换成对应的Controller。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">UIViewController</span> *)controllerForRouterParams:(RouterParams *)params &#123;</div><div class="line">    SEL CONTROLLER_CLASS_SELECTOR = sel_registerName(<span class="string">"allocWithRouterParams:"</span>);</div><div class="line">    SEL CONTROLLER_SELECTOR = sel_registerName(<span class="string">"initWithRouterParams:"</span>);</div><div class="line">    <span class="built_in">UIViewController</span> *controller = <span class="literal">nil</span>;</div><div class="line">    Class controllerClass = params.routerOptions.openClass;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">    <span class="keyword">if</span> ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) &#123;</div><div class="line">        controller = [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) &#123;</div><div class="line">        controller = [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]];</div><div class="line">    &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">    <span class="keyword">if</span> (!controller) &#123;</div><div class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</div><div class="line">            <span class="keyword">return</span> controller;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"RoutableInitializerNotFound"</span></div><div class="line">                                       reason:[<span class="built_in">NSString</span> stringWithFormat:INVALID_CONTROLLER_FORMAT, <span class="built_in">NSStringFromClass</span>(controllerClass), <span class="built_in">NSStringFromSelector</span>(CONTROLLER_CLASS_SELECTOR),  <span class="built_in">NSStringFromSelector</span>(CONTROLLER_SELECTOR)]</div><div class="line">                                     userInfo:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    controller.modalTransitionStyle = params.routerOptions.transitionStyle;</div><div class="line">    controller.modalPresentationStyle = params.routerOptions.presentationStyle;</div><div class="line">    <span class="keyword">return</span> controller;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。</p>
<p>将Routable的大致流程图解如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-f1b04aee828d5ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（3）HHRouter-Star-1277"><a href="#（3）HHRouter-Star-1277" class="headerlink" title="（3）HHRouter  Star 1277"></a>（3）<strong><a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a></strong>  Star 1277</h4><p>这是布丁动画的一个Router，灵感来自于 <a href="https://github.com/aaronbrethorst/ABRouter" target="_blank" rel="external">ABRouter</a> 和 <a href="https://github.com/usepropeller/routable-ios" target="_blank" rel="external">Routable iOS</a>。</p>
<p>先来看看HHRouter的Api。它提供的方法非常清晰。</p>
<p>ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)map:(<span class="built_in">NSString</span> *)route toControllerClass:(Class)controllerClass;</div><div class="line">- (<span class="built_in">UIViewController</span> *)matchController:(<span class="built_in">NSString</span> *)route;</div></pre></td></tr></table></figure>
<p>block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)map:(<span class="built_in">NSString</span> *)route toBlock:(HHRouterBlock)block;</div><div class="line"></div><div class="line">- (HHRouterBlock)matchBlock:(<span class="built_in">NSString</span> *)route;</div><div class="line">- (<span class="keyword">id</span>)callBlock:(<span class="built_in">NSString</span> *)route;</div></pre></td></tr></table></figure>
<p>matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。</p>
<p>除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (HHRouteType)canRoute:(<span class="built_in">NSString</span> *)route;</div></pre></td></tr></table></figure>
<p>这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span> (<span class="built_in">NSInteger</span>, HHRouteType) &#123;</div><div class="line">    HHRouteTypeNone = <span class="number">0</span>,</div><div class="line">    HHRouteTypeViewController = <span class="number">1</span>,</div><div class="line">    HHRouteTypeBlock = <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HHRouter</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span> *routes;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-43d6dc07d7fc2326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)map:(<span class="built_in">NSString</span> *)route toBlock:(HHRouterBlock)block</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *subRoutes = [<span class="keyword">self</span> subRoutesToRoute:route];</div><div class="line">    subRoutes[<span class="string">@"_"</span>] = [block <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)map:(<span class="built_in">NSString</span> *)route toControllerClass:(Class)controllerClass</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *subRoutes = [<span class="keyword">self</span> subRoutesToRoute:route];</div><div class="line">    subRoutes[<span class="string">@"_"</span>] = controllerClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)subRoutesToRoute:(<span class="built_in">NSString</span> *)route</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *pathComponents = [<span class="keyword">self</span> pathComponentsFromRoute:route];</div><div class="line"></div><div class="line">    <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *subRoutes = <span class="keyword">self</span>.routes;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (index &lt; pathComponents.count) &#123;</div><div class="line">        <span class="built_in">NSString</span> *pathComponent = pathComponents[index];</div><div class="line">        <span class="keyword">if</span> (![subRoutes objectForKey:pathComponent]) &#123;</div><div class="line">            subRoutes[pathComponent] = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">        &#125;</div><div class="line">        subRoutes = subRoutes[pathComponent];</div><div class="line">        index++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> subRoutes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段函数就是来构造路由匹配规则的字典。</p>
<p>举个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[[HHRouter shared] map:<span class="string">@"/user/:userId/"</span></div><div class="line">         toControllerClass:[UserViewController <span class="keyword">class</span>]];</div><div class="line">[[HHRouter shared] map:<span class="string">@"/story/:storyId/"</span></div><div class="line">         toControllerClass:[StoryViewController <span class="keyword">class</span>]];</div><div class="line">[[HHRouter shared] map:<span class="string">@"/user/:userId/story/?a=0"</span></div><div class="line">         toControllerClass:[StoryListViewController <span class="keyword">class</span>]];</div></pre></td></tr></table></figure>
<p>设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    story =     &#123;</div><div class="line">        ":storyId" =         &#123;</div><div class="line">            "_" = StoryViewController;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    user =     &#123;</div><div class="line">        ":userId" =         &#123;</div><div class="line">            "_" = UserViewController;</div><div class="line">            story =             &#123;</div><div class="line">                "_" = StoryListViewController;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>路由规则字典生成之后，等到匹配的时候就会遍历这个字典。</p>
<p>假设这时候有一条路由过来：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[[[HHRouter shared] matchController:<span class="string">@"hhrouter20://user/1/"</span>] <span class="keyword">class</span>],</div></pre></td></tr></table></figure>
<p>HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。</p>
<p>然后再进行路由匹配，最后生成的参数字典如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="string">"controller_class"</span> = UserViewController;</div><div class="line">    route = <span class="string">"/user/1/"</span>;</div><div class="line">    userId = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的路由参数匹配的函数在</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">NSDictionary</span> *)paramsInRoute:(<span class="built_in">NSString</span> *)route</div></pre></td></tr></table></figure>
<p>这个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。</p>
<p>ViewController 的字典里面默认还会加上2项：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"controller_class"</span> = </div><div class="line">route =</div></pre></td></tr></table></figure>
<p>route里面都会保存传过来的完整的URL。</p>
<p>如果传进来的路由后面带访问字符串呢？那我们再来看看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[[HHRouter shared] matchController:<span class="string">@"/user/1/?a=b&amp;c=d"</span>]</div></pre></td></tr></table></figure>
<p>那么解析出所有的参数字典会是下面的样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    a = b;</div><div class="line">    c = d;</div><div class="line">    <span class="string">"controller_class"</span> = UserViewController;</div><div class="line">    route = <span class="string">"/user/1/?a=b&amp;c=d"</span>;</div><div class="line">    userId = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，如果是一个block闭包的情况呢？</p>
<p>还是先添加一条block闭包的路由规则：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">[[HHRouter shared] map:<span class="string">@"/user/add/"</span></div><div class="line">                   toBlock:^<span class="keyword">id</span>(<span class="built_in">NSDictionary</span>* params) &#123;</div><div class="line">                   &#125;];</div></pre></td></tr></table></figure>
<p>这条规则对应的会生成一个路由规则的字典。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    story =     &#123;</div><div class="line">        <span class="string">":storyId"</span> =         &#123;</div><div class="line">            <span class="string">"_"</span> = StoryViewController;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    user =     &#123;</div><div class="line">        <span class="string">":userId"</span> =         &#123;</div><div class="line">            <span class="string">"_"</span> = UserViewController;</div><div class="line">            story =             &#123;</div><div class="line">                <span class="string">"_"</span> = StoryListViewController;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        add =         &#123;</div><div class="line">            <span class="string">"_"</span> = <span class="string">"&lt;__NSMallocBlock__: 0x600000240480&gt;"</span>;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意”_”后面跟着是一个block。</p>
<p>匹配block闭包的方式有两种。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。</span></div><div class="line">    HHRouterBlock block = [[HHRouter shared] matchBlock:<span class="string">@"/user/add/?a=1&amp;b=2"</span>];</div><div class="line">    block(<span class="literal">nil</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2.第二种方式匹配block之后自动会调用改闭包。</span></div><div class="line">    [[HHRouter shared] callBlock:<span class="string">@"/user/add/?a=1&amp;b=2"</span>];</div></pre></td></tr></table></figure>
<p>匹配出来的参数字典是如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    a = <span class="number">1</span>;</div><div class="line">    b = <span class="number">2</span>;</div><div class="line">    block = <span class="string">"&lt;__NSMallocBlock__: 0x600000056b90&gt;"</span>;</div><div class="line">    route = <span class="string">"/user/add/?a=1&amp;b=2"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>block的字典里面会默认加上下面这2项：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">block = </div><div class="line">route =</div></pre></td></tr></table></figure>
<p>route里面都会保存传过来的完整的URL。</p>
<p>生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setParams:(<span class="built_in">NSDictionary</span> *)paramsDictionary</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSDictionary</span> *)params</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedParamsObjectKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个绑定的过程是在match匹配完成的时候进行的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">UIViewController</span> *)matchController:(<span class="built_in">NSString</span> *)route</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *params = [<span class="keyword">self</span> paramsInRoute:route];</div><div class="line">    Class controllerClass = params[<span class="string">@"controller_class"</span>];</div><div class="line"></div><div class="line">    <span class="built_in">UIViewController</span> *viewController = [[controllerClass alloc] init];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([viewController respondsToSelector:<span class="keyword">@selector</span>(setParams:)]) &#123;</div><div class="line">        [viewController performSelector:<span class="keyword">@selector</span>(setParams:)</div><div class="line">                             withObject:[params <span class="keyword">copy</span>]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> viewController;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。</p>
<p>将上述过程图解出来，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-1b1a038ed9120a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（4）MGJRouter-Star-633"><a href="#（4）MGJRouter-Star-633" class="headerlink" title="（4）MGJRouter Star 633"></a>（4）<strong><a href="https://github.com/mogujie/MGJRouter" target="_blank" rel="external">MGJRouter</a></strong> Star 633</h4><p>这是蘑菇街的一个路由的方法。</p>
<p>这个库的由来：</p>
<p>JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。</p>
<p>HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。</p>
<p>于是就有了 MGJRouter。</p>
<p>从数据结构来看，MGJRouter还是和HHRouter一模一样的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MGJRouter</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span> *routes;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-379b3ab298775280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>那么我们就来看看它对HHRouter做了哪些优化改进。</p>
<h5 id="1-MGJRouter支持openURL时，可以传一些-userinfo-过去"><a href="#1-MGJRouter支持openURL时，可以传一些-userinfo-过去" class="headerlink" title="1.MGJRouter支持openURL时，可以传一些 userinfo 过去"></a>1.MGJRouter支持openURL时，可以传一些 userinfo 过去</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[MGJRouter openURL:<span class="string">@"mgj://category/travel"</span> withUserInfo:@&#123;<span class="string">@"user_id"</span>: @<span class="number">1900</span>&#125; completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> (parameters) &#123;</div><div class="line">    MGJRouterHandler handler = parameters[<span class="string">@"block"</span>];</div><div class="line">    <span class="keyword">if</span> (completion) &#123;</div><div class="line">        parameters[MGJRouterParameterCompletion] = completion;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (userInfo) &#123;</div><div class="line">        parameters[MGJRouterParameterUserInfo] = userInfo;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (handler) &#123;</div><div class="line">        [parameters removeObjectForKey:<span class="string">@"block"</span>];</div><div class="line">        handler(parameters);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。</p>
<h5 id="2-支持中文的URL。"><a href="#2-支持中文的URL。" class="headerlink" title="2.支持中文的URL。"></a>2.支持中文的URL。</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[parameters enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="built_in">NSString</span> *obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这里就是需要注意一下编码。</p>
<h5 id="3-定义一个全局的-URL-Pattern-作为-Fallback。"><a href="#3-定义一个全局的-URL-Pattern-作为-Fallback。" class="headerlink" title="3.定义一个全局的 URL Pattern 作为 Fallback。"></a>3.定义一个全局的 URL Pattern 作为 Fallback。</h5><p>这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (parameters) &#123;</div><div class="line">    MGJRouterHandler handler = parameters[<span class="string">@"block"</span>];</div><div class="line">    <span class="keyword">if</span> (handler) &#123;</div><div class="line">        [parameters removeObjectForKey:<span class="string">@"block"</span>];</div><div class="line">        handler(parameters);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。</p>
<h5 id="4-当-OpenURL-结束时，可以执行-Completion-Block。"><a href="#4-当-OpenURL-结束时，可以执行-Completion-Block。" class="headerlink" title="4.当 OpenURL 结束时，可以执行 Completion Block。"></a>4.当 OpenURL 结束时，可以执行 Completion Block。</h5><p>在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> MGJRouterParameterURL = <span class="string">@"MGJRouterParameterURL"</span>;</div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> MGJRouterParameterCompletion = <span class="string">@"MGJRouterParameterCompletion"</span>;</div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> MGJRouterParameterUserInfo = <span class="string">@"MGJRouterParameterUserInfo"</span>;</div></pre></td></tr></table></figure>
<p>这3个key会分别保存一些信息：</p>
<p>MGJRouterParameterURL保存的传进来的完整的URL信息。<br>MGJRouterParameterCompletion保存的是completion闭包。<br>MGJRouterParameterUserInfo保存的是UserInfo字典。</p>
<p>举个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">[MGJRouter registerURLPattern:<span class="string">@"ele://name/:name"</span> toHandler:^(<span class="built_in">NSDictionary</span> *routerParameters) &#123;</div><div class="line">    <span class="keyword">void</span> (^completion)(<span class="built_in">NSString</span> *) = routerParameters[MGJRouterParameterCompletion];</div><div class="line">    <span class="keyword">if</span> (completion) &#123;</div><div class="line">        completion(<span class="string">@"完成了"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[MGJRouter openURL:<span class="string">@"ele://name/halfrost/?age=20"</span> withUserInfo:@&#123;<span class="string">@"user_id"</span>: @<span class="number">1900</span>&#125; completion:^(<span class="keyword">id</span> result) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"result = %@"</span>,result);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>上面的URL会匹配成功，那么生成的参数字典结构如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    MGJRouterParameterCompletion = <span class="string">"&lt;__NSGlobalBlock__: 0x107ffe680&gt;"</span>;</div><div class="line">    MGJRouterParameterURL = <span class="string">"ele://name/halfrost/?age=20"</span>;</div><div class="line">    MGJRouterParameterUserInfo =     &#123;</div><div class="line">        <span class="string">"user_id"</span> = <span class="number">1900</span>;</div><div class="line">    &#125;;</div><div class="line">    age = <span class="number">20</span>;</div><div class="line">    block = <span class="string">"&lt;__NSMallocBlock__: 0x608000252120&gt;"</span>;</div><div class="line">    name = halfrost;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-可以统一管理URL"><a href="#5-可以统一管理URL" class="headerlink" title="5.可以统一管理URL"></a>5.可以统一管理URL</h5><p>这个功能非常有用。</p>
<p>URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。</p>
<p>所以 MGJRouter 提供了一个类方法来处理这个问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#define TEMPLATE_URL @<span class="meta-string">"qq://name/:name"</span></span></div><div class="line"></div><div class="line">[MGJRouter registerURLPattern:TEMPLATE_URL  toHandler:^(<span class="built_in">NSDictionary</span> *routerParameters) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"routerParameters[name]:%@"</span>, routerParameters[<span class="string">@"name"</span>]); <span class="comment">// halfrost</span></div><div class="line">&#125;];</div><div class="line"></div><div class="line">[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:@[<span class="string">@"halfrost"</span>]]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。</p>
<p>将上述过程图解出来，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6d9f7fc2a69bd160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。</p>
<p>每个组件之间都有一个 Entry，这个 Entry，主要做了三件事：</p>
<ol>
<li>注册这个组件关心的 URL</li>
<li>注册这个组件能够被调用的方法/属性</li>
<li>在 App 生命周期的不同阶段做不同的响应</li>
</ol>
<p>页面间的openURL调用就是如下的样子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-202a46e5fe0b00cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。</p>
<p>在组件间的调用，蘑菇街采用了Protocol的方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-ebb6183e75b7341f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>[ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。</p>
<p>[ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。</p>
<p>这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。</p>
<p>我猜测，大概实现可能是下面的样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleProtocolManager</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registServiceProvide:(<span class="keyword">id</span>)provide forProtocol:(Protocol*)protocol;</div><div class="line">+ (<span class="keyword">id</span>)serviceProvideForProtocol:(Protocol *)protocol;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后这个是一个单例，在里面注册各个协议：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ModuleProtocolManager</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *serviceProvideSource;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ModuleProtocolManager</span></span></div><div class="line"></div><div class="line">+ (ModuleProtocolManager *)sharedInstance</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> ModuleProtocolManager * instance;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        instance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _serviceProvideSource = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)registServiceProvide:(<span class="keyword">id</span>)provide forProtocol:(Protocol*)protocol</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (provide == <span class="literal">nil</span> || protocol == <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    [[<span class="keyword">self</span> sharedInstance].serviceProvideSource setObject:provide forKey:<span class="built_in">NSStringFromProtocol</span>(protocol)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)serviceProvideForProtocol:(Protocol *)protocol</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> sharedInstance].serviceProvideSource objectForKey:<span class="built_in">NSStringFromProtocol</span>(protocol)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DetailModuleEntryProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@required</span>;</div><div class="line">- (<span class="built_in">UIViewController</span> *)detailViewControllerWithId:(<span class="built_in">NSString</span>*)Id Name:(<span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailModuleEntry</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"DetailModuleEntry.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"DetailViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailModuleEntry</span>()&lt;<span class="title">DetailModuleEntryProtocol</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DetailModuleEntry</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    [ModuleProtocolManager registServiceProvide:[[<span class="keyword">self</span> alloc] init] forProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">DetailModuleEntryProtocol</span>)];</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UIViewController</span> *)detailViewControllerWithId:(<span class="built_in">NSString</span>*)Id Name:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    DetailViewController *detailVC = [[DetailViewController alloc] initWithId:<span class="keyword">id</span> Name:name];</div><div class="line">    <span class="keyword">return</span> detailVC;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didClickDetailButton:(<span class="built_in">UIButton</span> *)button</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span>&lt; DetailModuleEntryProtocol &gt; DetailModuleEntry = [ModuleProtocolManager serviceProvideForProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">DetailModuleEntryProtocol</span>)];</span></div><div class="line">    <span class="built_in">UIViewController</span> *detailVC = [DetailModuleEntry detailViewControllerWithId:@“详情界面” Name:@“我的购物车”];</div><div class="line">    [<span class="keyword">self</span>.navigationController pushViewController:detailVC animated:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以调用到组件或者界面了。</p>
<p>如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-122920349fc0ac08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（5）CTMediator-Star-803"><a href="#（5）CTMediator-Star-803" class="headerlink" title="（5）CTMediator  Star 803"></a>（5）<strong><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a></strong>  Star 803</h4><p>再来说说@casatwy的方案，这方案是基于Mediator的。</p>
<p>传统的中间人Mediator的模式是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-eae91f827634d37c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？</p>
<p>看看@casatwy是怎么继续优化的。</p>
<p>主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">id</span>)performTarget:(<span class="built_in">NSString</span> *)targetName action:(<span class="built_in">NSString</span> *)actionName params:(<span class="built_in">NSDictionary</span> *)params shouldCacheTarget:(<span class="built_in">BOOL</span>)shouldCacheTarget</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *targetClassString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Target_%@"</span>, targetName];</div><div class="line">    <span class="built_in">NSString</span> *actionString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Action_%@:"</span>, actionName];</div><div class="line">    Class targetClass;</div><div class="line">    </div><div class="line">    <span class="built_in">NSObject</span> *target = <span class="keyword">self</span>.cachedTarget[targetClassString];</div><div class="line">    <span class="keyword">if</span> (target == <span class="literal">nil</span>) &#123;</div><div class="line">        targetClass = <span class="built_in">NSClassFromString</span>(targetClassString);</div><div class="line">        target = [[targetClass alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SEL action = <span class="built_in">NSSelectorFromString</span>(actionString);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (target == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">// 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (shouldCacheTarget) &#123;</div><div class="line">        <span class="keyword">self</span>.cachedTarget[targetClassString] = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">        <span class="keyword">return</span> [target performSelector:action withObject:params];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 有可能target是Swift对象</span></div><div class="line">        actionString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Action_%@WithParams:"</span>, actionName];</div><div class="line">        action = <span class="built_in">NSSelectorFromString</span>(actionString);</div><div class="line">        <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">            <span class="keyword">return</span> [target performSelector:action withObject:params];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span></div><div class="line">            SEL action = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"notFound:"</span>);</div><div class="line">            <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">                <span class="keyword">return</span> [target performSelector:action withObject:params];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span></div><div class="line">                [<span class="keyword">self</span>.cachedTarget removeObjectForKey:targetClassString];</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。</p>
<p>通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。</p>
<p>但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">UIViewController</span> *)<span class="built_in">CTMediator_viewControllerForDetail</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIViewController</span> *viewController = [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</div><div class="line">                                                    action:kCTMediatorActionNativFetchDetailViewController</div><div class="line">                                                    params:@&#123;<span class="string">@"key"</span>:<span class="string">@"value"</span>&#125;</div><div class="line">                                         shouldCacheTarget:<span class="literal">NO</span></div><div class="line">                                        ];</div><div class="line">    <span class="keyword">if</span> ([viewController isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="comment">// view controller 交付出去之后，可以由外界选择是push还是present</span></div><div class="line">        <span class="keyword">return</span> viewController;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 这里处理异常场景，具体如何处理取决于产品</span></div><div class="line">        <span class="keyword">return</span> [[<span class="built_in">UIViewController</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="built_in">CTMediator_presentImage</span>:(<span class="built_in">UIImage</span> *)image</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</div><div class="line">                     action:kCTMediatorActionNativePresentImage</div><div class="line">                     params:@&#123;<span class="string">@"image"</span>:image&#125;</div><div class="line">          shouldCacheTarget:<span class="literal">NO</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 这里处理image为nil的场景，如何处理取决于产品</span></div><div class="line">        [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</div><div class="line">                     action:kCTMediatorActionNativeNoImage</div><div class="line">                     params:@&#123;<span class="string">@"image"</span>:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"noImage"</span>]&#125;</div><div class="line">          shouldCacheTarget:<span class="literal">NO</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。</p>
<p>最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-33914ebfa0566e2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（6）一些并没有开源的方案"><a href="#（6）一些并没有开源的方案" class="headerlink" title="（6）一些并没有开源的方案"></a>（6）一些并没有开源的方案</h4><p>除了上面开源的路由方案，还有一些并没有开源的设计精美的方案。这里可以和大家一起分析交流一下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5e8372009b87f2ef.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个方案是Uber 骑手App的一个方案。</p>
<p>Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。</p>
<p>通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-677b5dd3b54ca42c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。</p>
<p>通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-fe7d2482d631de4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。</p>
<p>Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。</p>
<p>每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。</p>
<p>重点分析一下Riblet里面路由的职责。</p>
<h5 id="1-路由的职责"><a href="#1-路由的职责" class="headerlink" title="1.路由的职责"></a>1.路由的职责</h5><p>在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑：</p>
<p>1.提供关联和取消关联其他路由的方法。<br>2.在多个孩子之间决定最终状态的状态转换逻辑。</p>
<h5 id="2-拼装"><a href="#2-拼装" class="headerlink" title="2.拼装"></a>2.拼装</h5><p>每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。</p>
<p>举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。</p>
<h5 id="3-Riblets是如何工作的"><a href="#3-Riblets是如何工作的" class="headerlink" title="3.Riblets是如何工作的"></a>3.Riblets是如何工作的</h5><p>Riblet中的数据流</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-9f854b96f2fd41d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。</p>
<p>举两个例子：</p>
<ol>
<li><p>数据从后台到视图View上<br>一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。</p>
</li>
<li><p>数据从视图到服务器后台<br>当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。</p>
</li>
</ol>
<p>Riblet间的数据流</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-003acf4aae15a5ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。</p>
<p>如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。</p>
<p>在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。</p>
<h3 id="五-各个方案优缺点"><a href="#五-各个方案优缺点" class="headerlink" title="五. 各个方案优缺点"></a>五. 各个方案优缺点</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-8c99a2bb4fae9914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。</p>
<h4 id="1-URLRoute注册方案的优缺点"><a href="#1-URLRoute注册方案的优缺点" class="headerlink" title="1. URLRoute注册方案的优缺点"></a>1. URLRoute注册方案的优缺点</h4><p>首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。</p>
<p>URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。</p>
<p>但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。</p>
<p>但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。</p>
<p>所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。</p>
<p>URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。</p>
<p>其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。</p>
<p>真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。</p>
<p>最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。</p>
<h4 id="2-Protocol-Class注册方案的优缺点"><a href="#2-Protocol-Class注册方案的优缺点" class="headerlink" title="2. Protocol-Class注册方案的优缺点"></a>2. Protocol-Class注册方案的优缺点</h4><p>Protocol-Class方案的优点，这个方案没有硬编码。</p>
<p>Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。</p>
<p>这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。</p>
<p>最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。</p>
<h4 id="3-Target-Action方案的优缺点"><a href="#3-Target-Action方案的优缺点" class="headerlink" title="3. Target-Action方案的优缺点"></a>3. Target-Action方案的优缺点</h4><p>Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。</p>
<p>Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。</p>
<p>Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。</p>
<h4 id="4-组件如何拆分？"><a href="#4-组件如何拆分？" class="headerlink" title="4. 组件如何拆分？"></a>4. 组件如何拆分？</h4><p>这个问题其实应该是在打算实施组件化之前就应该考虑的问题。为何还要放在这里说呢？因为组件的拆分每个公司都有属于自己的拆分方案，按照业务线拆？按照最细小的业务功能模块拆？还是按照一个完成的功能进行拆分？这个就牵扯到了拆分粗细度的问题了。组件拆分的粗细度就会直接关系到未来路由需要解耦的程度。</p>
<p>假设，把登录的所有流程封装成一个组件，由于登录里面会涉及到多个页面，那么这些页面都会打包在一个组件里面。那么其他模块需要调用登录状态的时候，这时候就需要用到登录组件暴露在外面可以获取登录状态的接口。那么这个时候就可以考虑把这些接口写到Protocol里面，暴露给外面使用。或者用Target-Action的方法。这种把一个功能全部都划分成登录组件的话，划分粒度就稍微粗一点。</p>
<p>如果仅仅把登录状态的细小功能划分成一个元组件，那么外面想获取登录状态就直接调用这个组件就好。这种划分的粒度就非常细了。这样就会导致组件个数巨多。</p>
<p>所以在进行拆分组件的时候，也许当时业务并不复杂的时候，拆分成组件，相互耦合也不大。但是随着业务不管变化，之前划分的组件间耦合性越来越大，于是就会考虑继续把之前的组件再进行拆分。也许有些业务砍掉了，之前一些小的组件也许还会被组合到一起。总之，在业务没有完全固定下来之前，组件的划分可能一直进行时。</p>
<h3 id="六-最好的方案"><a href="#六-最好的方案" class="headerlink" title="六. 最好的方案"></a>六. 最好的方案</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-80d7e39d04c3a0b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>关于架构，我觉得抛开业务谈架构是没有意义的。因为架构是为了业务服务的，空谈架构只是一种理想的状态。所以没有最好的方案，只有最适合的方案。</p>
<p>最适合自己公司业务的方案才是最好的方案。分而治之，针对不同业务选择不同的方案才是最优的解决方案。如果非要笼统的采用一种方案，不同业务之间需要同一种方案，需要妥协牺牲的东西太多就不好了。</p>
<p>希望本文能抛砖引玉，帮助大家选择出最适合自家业务的路由方案。当然肯定会有更加优秀的方案，希望大家能多多指点我。</p>
<p>References:</p>
<p><a href="http://casatwy.com/modulization_in_action.html" target="_blank" rel="external">在现有工程中实施基于CTMediator的组件化方案</a><br><a href="http://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案</a><br><a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="external">蘑菇街 App 的组件化之路</a><br><a href="http://limboy.me/tech/2016/03/14/mgj-components-continued.html" target="_blank" rel="external">蘑菇街 App 的组件化之路·续</a><br><a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="external">ENGINEERING THE ARCHITECTURE BEHIND UBER’S NEW RIDER APP</a>  </p>
<blockquote>
<p>GitHub Repo：<a href="https://github.com/halfrost/Halfrost-Field" target="_blank" rel="external">Halfrost-Field</a></p>
<p>Follow: <a href="https://github.com/halfrost" target="_blank" rel="external">halfrost · GitHub</a></p>
<p>Source: <a href="https://halfrost.com/ios_router/" target="_blank" rel="external">https://halfrost.com/ios_router/</a></p>
</blockquote>
    </div>
	
	<!--打赏-->
		<div class="reward">
	   <div class="reward-button">赏 <span class="reward-code">
		<span class="alipay-code"> <img class="alipay-img wdp-appear" src="http://ohe65w0xx.bkt.clouddn.com/alipay.png"><b>支付宝打赏</b> </span> 
		<span class="wechat-code"> <img class="wechat-img wdp-appear" src="http://ohe65w0xx.bkt.clouddn.com/weipay.png"><b>微信打赏</b> </span> 
	   </span></div>
	  <p class="reward-notice">如果文章对你有帮助，欢迎点击上方按钮打赏作者</p>
      </div>

    <div class="post-footer">   
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
		
        <div>
            
        </div>  
    </div>
	
	
	
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2016/06/26/Koa源码分析/" class="pre-post btn btn-default"><i class="fa fa-angle-left fa-fw"></i>上一篇</a>
    
    
        <a href="/2016/06/20/VR技术大揭秘/" class="next-post btn btn-default">下一篇<i class="fa fa-angle-right fa-fw"></i></a>
    
</div>


    <div id="comments">
        <!--PC和WAP自适应版-->
<div id="SOHUCS"></div>
<script type="text/javascript">
	(function(){var appid='cyt8KmUC1';var conf='prod_855a68d3b3d91855360a6215672a505a';var width=window.innerWidth||document.documentElement.clientWidth;if(width<960){window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+appid+'&conf='+conf+'"><\/script>');}else{var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
	c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});}})();
</script>
    </div>
                </main>
                <aside class="col-md-4 sidebar">
        
        <div class="widget">    
        <h3 class="title">搜索</h3>
        <div id="search-form">
            <div id="result-mask" class="hide"></div>
            <div class="search-area">
                
                    <input id="search-key" type="search" autocomplete="off" placeholder="搜点什么呢?">
                    <button type="button" class="search-form-submit" id="search-local">站内搜索</button>
                
                
            </div>
            <div id="result-wrap" class="hide">
                <div id="search-result"></div>
            </div>
            <div class="hide">
                <template id="search-tpl">
                    <div class="item">
                        <a href="/{path}" title="{title}">
                            <div class="title">{title}</div>
                            <div class="content">{content}</div>
                        </a>
                    </div>
                </template>
            </div>
        </div>
    </div>
        
        <div class="widget notification">
        <h3 class="title">网站公告</h3>
        <div>
            <p>主题Snippet v1.2.0版本已经上线！欢迎更新~ <br>
主题下载：<a href="https://github.com/shenliyang/hexo-theme-snippet" title="fork me" target="_blank">Snippet主题</a> <br>
<hr>接受贡献，包括不限于提交问题与需求，修复代码。欢迎Pull Request<br>支持主题：<a href="https://github.com/shenliyang/hexo-theme-snippet/stargazers">Star一下</a>
</p>
        </div>
    </div>
        
        <div class="widget">
      <h3 class="title">社交</h3> 
        <div class="content social">
            
	            <a href="//github.com/shenliyang" rel="external nofollow" title="Github" target="_blank">
			    	<i class="git fa fa-git"></i>
			    </a>
            
	            <a href="mailto:snippet@91h5.cc" rel="external nofollow" title="邮箱" target="_blank">
			    	<i class="envelope-o fa fa-envelope-o"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="联系QQ" target="_blank">
			    	<i class="qq fa fa-qq"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="微博" target="_blank">
			    	<i class="weibo fa fa-weibo"></i>
			    </a>
            
	            <a href="/" rel="external nofollow" title="QQ群" target="_blank">
			    	<i class="users fa fa-users"></i>
			    </a>
            
	            <a href="/atom.xml" rel="external nofollow" title="RSS" target="_blank">
			    	<i class="feed fa fa-feed"></i>
			    </a>
            
        </div>
    </div>
        
        <div class="widget">
        <h3 class="title">分类</h3>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/"><i class="fa" aria-hidden="true">Android</i></a><span class="category-list-count">41</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/系统/"><i class="fa" aria-hidden="true">系统</i></a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/"><i class="fa" aria-hidden="true">Google</i></a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Google/VR/"><i class="fa" aria-hidden="true">VR</i></a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/"><i class="fa" aria-hidden="true">Java</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/"><i class="fa" aria-hidden="true">Kotlin</i></a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWA/"><i class="fa" aria-hidden="true">PWA</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/"><i class="fa" aria-hidden="true">Python</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/"><i class="fa" aria-hidden="true">React Native</i></a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/"><i class="fa" aria-hidden="true">Spring</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/"><i class="fa" aria-hidden="true">android</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/"><i class="fa" aria-hidden="true">iOS</i></a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/"><i class="fa" aria-hidden="true">ios</i></a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/"><i class="fa" aria-hidden="true">python</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/"><i class="fa" aria-hidden="true">人工智能</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">22</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/"><i class="fa" aria-hidden="true">区块链</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/"><i class="fa" aria-hidden="true">小程序</i></a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术人生/"><i class="fa" aria-hidden="true">技术人生</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/"><i class="fa" aria-hidden="true">机器学习</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/"><i class="fa" aria-hidden="true">编程语言</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/"><i class="fa" aria-hidden="true">设计模式</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资料库/"><i class="fa" aria-hidden="true">资料库</i></a><span class="category-list-count">1</span></li></ul>
    </div>
        
        <div class="widget">
      <h3 class="title">归档</h3>
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/"><i class="fa" aria-hidden="true">二月 2018</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/"><i class="fa" aria-hidden="true">一月 2018</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/"><i class="fa" aria-hidden="true">十二月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/"><i class="fa" aria-hidden="true">十一月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/"><i class="fa" aria-hidden="true">十月 2017</i></a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/"><i class="fa" aria-hidden="true">九月 2017</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/"><i class="fa" aria-hidden="true">八月 2017</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/"><i class="fa" aria-hidden="true">七月 2017</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/"><i class="fa" aria-hidden="true">六月 2017</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/"><i class="fa" aria-hidden="true">五月 2017</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/"><i class="fa" aria-hidden="true">四月 2017</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/"><i class="fa" aria-hidden="true">三月 2017</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/"><i class="fa" aria-hidden="true">二月 2017</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/"><i class="fa" aria-hidden="true">一月 2017</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/"><i class="fa" aria-hidden="true">十二月 2016</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/"><i class="fa" aria-hidden="true">十一月 2016</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/"><i class="fa" aria-hidden="true">十月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/"><i class="fa" aria-hidden="true">九月 2016</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/"><i class="fa" aria-hidden="true">八月 2016</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/"><i class="fa" aria-hidden="true">七月 2016</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/"><i class="fa" aria-hidden="true">六月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/"><i class="fa" aria-hidden="true">五月 2016</i></a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/"><i class="fa" aria-hidden="true">四月 2016</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/"><i class="fa" aria-hidden="true">三月 2016</i></a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/"><i class="fa" aria-hidden="true">二月 2016</i></a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/"><i class="fa" aria-hidden="true">一月 2016</i></a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/"><i class="fa" aria-hidden="true">九月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/"><i class="fa" aria-hidden="true">六月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/"><i class="fa" aria-hidden="true">五月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/"><i class="fa" aria-hidden="true">四月 2015</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/"><i class="fa" aria-hidden="true">三月 2015</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/"><i class="fa" aria-hidden="true">一月 2015</i></a><span class="archive-list-count">1</span></li></ul>
    </div>
        
        <div class="widget">
    <h3 class="title">标签云</h3>
    <div class="content tag-cloud">
        <a href="/tags/AR/" style="font-size: 10px">AR</a> <a href="/tags/Android/" style="font-size: 20px">Android</a> <a href="/tags/Angular2/" style="font-size: 10px">Angular2</a> <a href="/tags/FlexBox布局/" style="font-size: 10px">FlexBox布局</a> <a href="/tags/Google/" style="font-size: 10.77px">Google</a> <a href="/tags/Java/" style="font-size: 15.38px">Java</a> <a href="/tags/Kotlin/" style="font-size: 16.92px">Kotlin</a> <a href="/tags/Node/" style="font-size: 10.77px">Node</a> <a href="/tags/OpenGL/" style="font-size: 10px">OpenGL</a> <a href="/tags/PWA/" style="font-size: 10px">PWA</a> <a href="/tags/Promise/" style="font-size: 10px">Promise</a> <a href="/tags/Python/" style="font-size: 16.15px">Python</a> <a href="/tags/React-Native/" style="font-size: 18.46px">React Native</a> <a href="/tags/Spring/" style="font-size: 10.77px">Spring</a> <a href="/tags/Swift/" style="font-size: 10px">Swift</a> <a href="/tags/VR/" style="font-size: 10.77px">VR</a> <a href="/tags/Xcode/" style="font-size: 11.54px">Xcode</a> <a href="/tags/android/" style="font-size: 12.31px">android</a> <a href="/tags/eact-Native/" style="font-size: 10px">eact Native</a> <a href="/tags/gif/" style="font-size: 10px">gif</a> <a href="/tags/gulp/" style="font-size: 10px">gulp</a> <a href="/tags/https/" style="font-size: 10px">https</a> <a href="/tags/iOS/" style="font-size: 17.69px">iOS</a> <a href="/tags/ios/" style="font-size: 16.15px">ios</a> <a href="/tags/mac/" style="font-size: 10px">mac</a> <a href="/tags/react/" style="font-size: 10px">react</a> <a href="/tags/swift/" style="font-size: 10px">swift</a> <a href="/tags/webpack/" style="font-size: 10px">webpack</a> <a href="/tags/个人博客/" style="font-size: 10.77px">个人博客</a> <a href="/tags/人工智能/" style="font-size: 10px">人工智能</a> <a href="/tags/入门/" style="font-size: 10.77px">入门</a> <a href="/tags/全栈/" style="font-size: 10px">全栈</a> <a href="/tags/内存分配/" style="font-size: 10px">内存分配</a> <a href="/tags/前端/" style="font-size: 19.23px">前端</a> <a href="/tags/前端开发/" style="font-size: 11.54px">前端开发</a> <a href="/tags/区块链/" style="font-size: 10px">区块链</a> <a href="/tags/原理/" style="font-size: 10px">原理</a> <a href="/tags/原生/" style="font-size: 10px">原生</a> <a href="/tags/后端/" style="font-size: 14.62px">后端</a> <a href="/tags/垃圾回收/" style="font-size: 10px">垃圾回收</a> <a href="/tags/小程序/" style="font-size: 13.85px">小程序</a> <a href="/tags/微信/" style="font-size: 13.08px">微信</a> <a href="/tags/打包/" style="font-size: 10px">打包</a> <a href="/tags/搭建网站/" style="font-size: 10px">搭建网站</a> <a href="/tags/新特性/" style="font-size: 10.77px">新特性</a> <a href="/tags/机器学习/" style="font-size: 10.77px">机器学习</a> <a href="/tags/杂谈/" style="font-size: 14.62px">杂谈</a> <a href="/tags/流量/" style="font-size: 10px">流量</a> <a href="/tags/深入理解/" style="font-size: 10px">深入理解</a> <a href="/tags/深入系统/" style="font-size: 10px">深入系统</a> <a href="/tags/混淆打包/" style="font-size: 10px">混淆打包</a> <a href="/tags/环境/" style="font-size: 10px">环境</a> <a href="/tags/知识库/" style="font-size: 10.77px">知识库</a> <a href="/tags/硬件/" style="font-size: 10px">硬件</a> <a href="/tags/算法/" style="font-size: 10px">算法</a> <a href="/tags/系统服务/" style="font-size: 10px">系统服务</a> <a href="/tags/编程语言/" style="font-size: 10.77px">编程语言</a> <a href="/tags/设计模式/" style="font-size: 10px">设计模式</a> <a href="/tags/调试/" style="font-size: 10px">调试</a>
    </div>
  </div>
        
        <div class="widget">
        <h3 class="title">友链</h3>
        <div class="content friends-link">
        
            <a href="http://www.shenliyang.com" class="fa" target="_blank">个人博客</a>
        
        </div>
    </div>
        
    </aside>
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="hide">
	<i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
			    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>

<script src="/js/search.js?rev=@@hash"></script>


<script src="/js/app.js?rev=@@hash"></script>
</body>
